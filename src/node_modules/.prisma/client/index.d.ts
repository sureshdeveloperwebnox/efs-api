
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model organizations
 * 
 */
export type organizations = $Result.DefaultSelection<Prisma.$organizationsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model user_role
 * 
 */
export type user_role = $Result.DefaultSelection<Prisma.$user_rolePayload>
/**
 * Model currencies
 * 
 */
export type currencies = $Result.DefaultSelection<Prisma.$currenciesPayload>
/**
 * Model user_role_assignments
 * 
 */
export type user_role_assignments = $Result.DefaultSelection<Prisma.$user_role_assignmentsPayload>
/**
 * Model skills
 * 
 */
export type skills = $Result.DefaultSelection<Prisma.$skillsPayload>
/**
 * Model user_skills
 * 
 */
export type user_skills = $Result.DefaultSelection<Prisma.$user_skillsPayload>
/**
 * Model business_hours
 * 
 */
export type business_hours = $Result.DefaultSelection<Prisma.$business_hoursPayload>
/**
 * Model holidays
 * 
 */
export type holidays = $Result.DefaultSelection<Prisma.$holidaysPayload>
/**
 * Model time_off_requests
 * 
 */
export type time_off_requests = $Result.DefaultSelection<Prisma.$time_off_requestsPayload>
/**
 * Model crews
 * 
 */
export type crews = $Result.DefaultSelection<Prisma.$crewsPayload>
/**
 * Model crew_members
 * 
 */
export type crew_members = $Result.DefaultSelection<Prisma.$crew_membersPayload>
/**
 * Model equipments
 * 
 */
export type equipments = $Result.DefaultSelection<Prisma.$equipmentsPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model customers
 * 
 */
export type customers = $Result.DefaultSelection<Prisma.$customersPayload>
/**
 * Model services
 * 
 */
export type services = $Result.DefaultSelection<Prisma.$servicesPayload>
/**
 * Model assets
 * 
 */
export type assets = $Result.DefaultSelection<Prisma.$assetsPayload>
/**
 * Model parts
 * 
 */
export type parts = $Result.DefaultSelection<Prisma.$partsPayload>
/**
 * Model maintenance_plans
 * 
 */
export type maintenance_plans = $Result.DefaultSelection<Prisma.$maintenance_plansPayload>
/**
 * Model maintenance_plan_assets
 * 
 */
export type maintenance_plan_assets = $Result.DefaultSelection<Prisma.$maintenance_plan_assetsPayload>
/**
 * Model work_orders
 * 
 */
export type work_orders = $Result.DefaultSelection<Prisma.$work_ordersPayload>
/**
 * Model work_order_services
 * 
 */
export type work_order_services = $Result.DefaultSelection<Prisma.$work_order_servicesPayload>
/**
 * Model work_order_tasks
 * 
 */
export type work_order_tasks = $Result.DefaultSelection<Prisma.$work_order_tasksPayload>
/**
 * Model work_order_assets
 * 
 */
export type work_order_assets = $Result.DefaultSelection<Prisma.$work_order_assetsPayload>
/**
 * Model work_order_crew
 * 
 */
export type work_order_crew = $Result.DefaultSelection<Prisma.$work_order_crewPayload>
/**
 * Model work_order_approvals
 * 
 */
export type work_order_approvals = $Result.DefaultSelection<Prisma.$work_order_approvalsPayload>
/**
 * Model invoices
 * 
 */
export type invoices = $Result.DefaultSelection<Prisma.$invoicesPayload>
/**
 * Model invoice_items
 * 
 */
export type invoice_items = $Result.DefaultSelection<Prisma.$invoice_itemsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model email_templates
 * 
 */
export type email_templates = $Result.DefaultSelection<Prisma.$email_templatesPayload>
/**
 * Model audit_logs
 * 
 */
export type audit_logs = $Result.DefaultSelection<Prisma.$audit_logsPayload>
/**
 * Model tokens
 * 
 */
export type tokens = $Result.DefaultSelection<Prisma.$tokensPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PlanType: {
  FREE: 'FREE',
  STANDARD: 'STANDARD',
  PROFESSIONAL: 'PROFESSIONAL'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const UserRole: {
  ADMIN: 'ADMIN',
  STAFF: 'STAFF',
  TECHNICIAN: 'TECHNICIAN',
  DISPATCHER: 'DISPATCHER',
  CUSTOMER: 'CUSTOMER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProficiencyLevel: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  EXPERT: 'EXPERT'
};

export type ProficiencyLevel = (typeof ProficiencyLevel)[keyof typeof ProficiencyLevel]


export const DayOfWeek: {
  SUNDAY: 'SUNDAY',
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY'
};

export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek]


export const RequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  DENIED: 'DENIED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const EqupmentStatus: {
  AVAILABLE: 'AVAILABLE',
  IN_USE: 'IN_USE',
  UNDER_MAINTENANCE: 'UNDER_MAINTENANCE',
  DAMAGED: 'DAMAGED'
};

export type EqupmentStatus = (typeof EqupmentStatus)[keyof typeof EqupmentStatus]


export const AssetStatus: {
  OPERATIONAL: 'OPERATIONAL',
  NEEDS_MAINTENANCE: 'NEEDS_MAINTENANCE',
  UNDER_REPAIR: 'UNDER_REPAIR',
  DECOMMISSIONED: 'DECOMMISSIONED'
};

export type AssetStatus = (typeof AssetStatus)[keyof typeof AssetStatus]


export const Frequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  SEMIANNUALLY: 'SEMIANNUALLY',
  ANNUALLY: 'ANNUALLY',
  CUSTOM: 'CUSTOM'
};

export type Frequency = (typeof Frequency)[keyof typeof Frequency]


export const FrequencyUnitType: {
  DAYS: 'DAYS',
  WEEKS: 'WEEKS',
  MONTHS: 'MONTHS'
};

export type FrequencyUnitType = (typeof FrequencyUnitType)[keyof typeof FrequencyUnitType]


export const Prioirty: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Prioirty = (typeof Prioirty)[keyof typeof Prioirty]


export const WorkOrderStatus: {
  DRAFT: 'DRAFT',
  OPEN: 'OPEN',
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type WorkOrderStatus = (typeof WorkOrderStatus)[keyof typeof WorkOrderStatus]


export const WorkOrderTaskStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ON_HOLD: 'ON_HOLD'
};

export type WorkOrderTaskStatus = (typeof WorkOrderTaskStatus)[keyof typeof WorkOrderTaskStatus]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  OVERDUE: 'OVERDUE'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CASH: 'CASH',
  CHECK: 'CHECK',
  PAYPAL: 'PAYPAL'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const NotificationType: {
  ALERT: 'ALERT',
  WARNING: 'WARNING',
  ERROR: 'ERROR'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationStatus: {
  PENDING: 'PENDING',
  READ: 'READ',
  DISMISSED: 'DISMISSED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const LogType: {
  USER: 'USER',
  WORK_ORDER: 'WORK_ORDER',
  SERVICE: 'SERVICE',
  INVOICE: 'INVOICE',
  ASSET: 'ASSET'
};

export type LogType = (typeof LogType)[keyof typeof LogType]

}

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProficiencyLevel = $Enums.ProficiencyLevel

export const ProficiencyLevel: typeof $Enums.ProficiencyLevel

export type DayOfWeek = $Enums.DayOfWeek

export const DayOfWeek: typeof $Enums.DayOfWeek

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type EqupmentStatus = $Enums.EqupmentStatus

export const EqupmentStatus: typeof $Enums.EqupmentStatus

export type AssetStatus = $Enums.AssetStatus

export const AssetStatus: typeof $Enums.AssetStatus

export type Frequency = $Enums.Frequency

export const Frequency: typeof $Enums.Frequency

export type FrequencyUnitType = $Enums.FrequencyUnitType

export const FrequencyUnitType: typeof $Enums.FrequencyUnitType

export type Prioirty = $Enums.Prioirty

export const Prioirty: typeof $Enums.Prioirty

export type WorkOrderStatus = $Enums.WorkOrderStatus

export const WorkOrderStatus: typeof $Enums.WorkOrderStatus

export type WorkOrderTaskStatus = $Enums.WorkOrderTaskStatus

export const WorkOrderTaskStatus: typeof $Enums.WorkOrderTaskStatus

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type LogType = $Enums.LogType

export const LogType: typeof $Enums.LogType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organizations.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organizations.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.organizations`: Exposes CRUD operations for the **organizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organizations.findMany()
    * ```
    */
  get organizations(): Prisma.organizationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_role`: Exposes CRUD operations for the **user_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_role.findMany()
    * ```
    */
  get user_role(): Prisma.user_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currencies`: Exposes CRUD operations for the **currencies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currencies.findMany()
    * ```
    */
  get currencies(): Prisma.currenciesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_role_assignments`: Exposes CRUD operations for the **user_role_assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_role_assignments
    * const user_role_assignments = await prisma.user_role_assignments.findMany()
    * ```
    */
  get user_role_assignments(): Prisma.user_role_assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skills`: Exposes CRUD operations for the **skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skills.findMany()
    * ```
    */
  get skills(): Prisma.skillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_skills`: Exposes CRUD operations for the **user_skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_skills
    * const user_skills = await prisma.user_skills.findMany()
    * ```
    */
  get user_skills(): Prisma.user_skillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.business_hours`: Exposes CRUD operations for the **business_hours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Business_hours
    * const business_hours = await prisma.business_hours.findMany()
    * ```
    */
  get business_hours(): Prisma.business_hoursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holidays`: Exposes CRUD operations for the **holidays** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holidays.findMany()
    * ```
    */
  get holidays(): Prisma.holidaysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.time_off_requests`: Exposes CRUD operations for the **time_off_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Time_off_requests
    * const time_off_requests = await prisma.time_off_requests.findMany()
    * ```
    */
  get time_off_requests(): Prisma.time_off_requestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crews`: Exposes CRUD operations for the **crews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crews.findMany()
    * ```
    */
  get crews(): Prisma.crewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crew_members`: Exposes CRUD operations for the **crew_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crew_members
    * const crew_members = await prisma.crew_members.findMany()
    * ```
    */
  get crew_members(): Prisma.crew_membersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipments`: Exposes CRUD operations for the **equipments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipments
    * const equipments = await prisma.equipments.findMany()
    * ```
    */
  get equipments(): Prisma.equipmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.customersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.servicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assets`: Exposes CRUD operations for the **assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.assets.findMany()
    * ```
    */
  get assets(): Prisma.assetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parts`: Exposes CRUD operations for the **parts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parts
    * const parts = await prisma.parts.findMany()
    * ```
    */
  get parts(): Prisma.partsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance_plans`: Exposes CRUD operations for the **maintenance_plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenance_plans
    * const maintenance_plans = await prisma.maintenance_plans.findMany()
    * ```
    */
  get maintenance_plans(): Prisma.maintenance_plansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance_plan_assets`: Exposes CRUD operations for the **maintenance_plan_assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenance_plan_assets
    * const maintenance_plan_assets = await prisma.maintenance_plan_assets.findMany()
    * ```
    */
  get maintenance_plan_assets(): Prisma.maintenance_plan_assetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.work_orders`: Exposes CRUD operations for the **work_orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Work_orders
    * const work_orders = await prisma.work_orders.findMany()
    * ```
    */
  get work_orders(): Prisma.work_ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.work_order_services`: Exposes CRUD operations for the **work_order_services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Work_order_services
    * const work_order_services = await prisma.work_order_services.findMany()
    * ```
    */
  get work_order_services(): Prisma.work_order_servicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.work_order_tasks`: Exposes CRUD operations for the **work_order_tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Work_order_tasks
    * const work_order_tasks = await prisma.work_order_tasks.findMany()
    * ```
    */
  get work_order_tasks(): Prisma.work_order_tasksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.work_order_assets`: Exposes CRUD operations for the **work_order_assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Work_order_assets
    * const work_order_assets = await prisma.work_order_assets.findMany()
    * ```
    */
  get work_order_assets(): Prisma.work_order_assetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.work_order_crew`: Exposes CRUD operations for the **work_order_crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Work_order_crews
    * const work_order_crews = await prisma.work_order_crew.findMany()
    * ```
    */
  get work_order_crew(): Prisma.work_order_crewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.work_order_approvals`: Exposes CRUD operations for the **work_order_approvals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Work_order_approvals
    * const work_order_approvals = await prisma.work_order_approvals.findMany()
    * ```
    */
  get work_order_approvals(): Prisma.work_order_approvalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoices.findMany()
    * ```
    */
  get invoices(): Prisma.invoicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice_items`: Exposes CRUD operations for the **invoice_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoice_items
    * const invoice_items = await prisma.invoice_items.findMany()
    * ```
    */
  get invoice_items(): Prisma.invoice_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email_templates`: Exposes CRUD operations for the **email_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_templates
    * const email_templates = await prisma.email_templates.findMany()
    * ```
    */
  get email_templates(): Prisma.email_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_logs`: Exposes CRUD operations for the **audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_logs.findMany()
    * ```
    */
  get audit_logs(): Prisma.audit_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokens`: Exposes CRUD operations for the **tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.tokens.findMany()
    * ```
    */
  get tokens(): Prisma.tokensDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    organizations: 'organizations',
    users: 'users',
    user_role: 'user_role',
    currencies: 'currencies',
    user_role_assignments: 'user_role_assignments',
    skills: 'skills',
    user_skills: 'user_skills',
    business_hours: 'business_hours',
    holidays: 'holidays',
    time_off_requests: 'time_off_requests',
    crews: 'crews',
    crew_members: 'crew_members',
    equipments: 'equipments',
    companies: 'companies',
    customers: 'customers',
    services: 'services',
    assets: 'assets',
    parts: 'parts',
    maintenance_plans: 'maintenance_plans',
    maintenance_plan_assets: 'maintenance_plan_assets',
    work_orders: 'work_orders',
    work_order_services: 'work_order_services',
    work_order_tasks: 'work_order_tasks',
    work_order_assets: 'work_order_assets',
    work_order_crew: 'work_order_crew',
    work_order_approvals: 'work_order_approvals',
    invoices: 'invoices',
    invoice_items: 'invoice_items',
    payments: 'payments',
    notifications: 'notifications',
    email_templates: 'email_templates',
    audit_logs: 'audit_logs',
    tokens: 'tokens'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "organizations" | "users" | "user_role" | "currencies" | "user_role_assignments" | "skills" | "user_skills" | "business_hours" | "holidays" | "time_off_requests" | "crews" | "crew_members" | "equipments" | "companies" | "customers" | "services" | "assets" | "parts" | "maintenance_plans" | "maintenance_plan_assets" | "work_orders" | "work_order_services" | "work_order_tasks" | "work_order_assets" | "work_order_crew" | "work_order_approvals" | "invoices" | "invoice_items" | "payments" | "notifications" | "email_templates" | "audit_logs" | "tokens"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      organizations: {
        payload: Prisma.$organizationsPayload<ExtArgs>
        fields: Prisma.organizationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organizationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organizationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          findFirst: {
            args: Prisma.organizationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organizationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          findMany: {
            args: Prisma.organizationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>[]
          }
          create: {
            args: Prisma.organizationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          createMany: {
            args: Prisma.organizationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.organizationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>[]
          }
          delete: {
            args: Prisma.organizationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          update: {
            args: Prisma.organizationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          deleteMany: {
            args: Prisma.organizationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.organizationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.organizationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>[]
          }
          upsert: {
            args: Prisma.organizationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationsPayload>
          }
          aggregate: {
            args: Prisma.OrganizationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizations>
          }
          groupBy: {
            args: Prisma.organizationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.organizationsCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      user_role: {
        payload: Prisma.$user_rolePayload<ExtArgs>
        fields: Prisma.user_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          findFirst: {
            args: Prisma.user_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          findMany: {
            args: Prisma.user_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>[]
          }
          create: {
            args: Prisma.user_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          createMany: {
            args: Prisma.user_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>[]
          }
          delete: {
            args: Prisma.user_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          update: {
            args: Prisma.user_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          deleteMany: {
            args: Prisma.user_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>[]
          }
          upsert: {
            args: Prisma.user_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolePayload>
          }
          aggregate: {
            args: Prisma.User_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_role>
          }
          groupBy: {
            args: Prisma.user_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_roleCountArgs<ExtArgs>
            result: $Utils.Optional<User_roleCountAggregateOutputType> | number
          }
        }
      }
      currencies: {
        payload: Prisma.$currenciesPayload<ExtArgs>
        fields: Prisma.currenciesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.currenciesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.currenciesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>
          }
          findFirst: {
            args: Prisma.currenciesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.currenciesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>
          }
          findMany: {
            args: Prisma.currenciesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>[]
          }
          create: {
            args: Prisma.currenciesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>
          }
          createMany: {
            args: Prisma.currenciesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.currenciesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>[]
          }
          delete: {
            args: Prisma.currenciesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>
          }
          update: {
            args: Prisma.currenciesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>
          }
          deleteMany: {
            args: Prisma.currenciesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.currenciesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.currenciesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>[]
          }
          upsert: {
            args: Prisma.currenciesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currenciesPayload>
          }
          aggregate: {
            args: Prisma.CurrenciesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrencies>
          }
          groupBy: {
            args: Prisma.currenciesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrenciesGroupByOutputType>[]
          }
          count: {
            args: Prisma.currenciesCountArgs<ExtArgs>
            result: $Utils.Optional<CurrenciesCountAggregateOutputType> | number
          }
        }
      }
      user_role_assignments: {
        payload: Prisma.$user_role_assignmentsPayload<ExtArgs>
        fields: Prisma.user_role_assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_role_assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_role_assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>
          }
          findFirst: {
            args: Prisma.user_role_assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_role_assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>
          }
          findMany: {
            args: Prisma.user_role_assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>[]
          }
          create: {
            args: Prisma.user_role_assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>
          }
          createMany: {
            args: Prisma.user_role_assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_role_assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>[]
          }
          delete: {
            args: Prisma.user_role_assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>
          }
          update: {
            args: Prisma.user_role_assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.user_role_assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_role_assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_role_assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.user_role_assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_role_assignmentsPayload>
          }
          aggregate: {
            args: Prisma.User_role_assignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_role_assignments>
          }
          groupBy: {
            args: Prisma.user_role_assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_role_assignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_role_assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<User_role_assignmentsCountAggregateOutputType> | number
          }
        }
      }
      skills: {
        payload: Prisma.$skillsPayload<ExtArgs>
        fields: Prisma.skillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findFirst: {
            args: Prisma.skillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findMany: {
            args: Prisma.skillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          create: {
            args: Prisma.skillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          createMany: {
            args: Prisma.skillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.skillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          delete: {
            args: Prisma.skillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          update: {
            args: Prisma.skillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          deleteMany: {
            args: Prisma.skillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.skillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          upsert: {
            args: Prisma.skillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          aggregate: {
            args: Prisma.SkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkills>
          }
          groupBy: {
            args: Prisma.skillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.skillsCountArgs<ExtArgs>
            result: $Utils.Optional<SkillsCountAggregateOutputType> | number
          }
        }
      }
      user_skills: {
        payload: Prisma.$user_skillsPayload<ExtArgs>
        fields: Prisma.user_skillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_skillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_skillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>
          }
          findFirst: {
            args: Prisma.user_skillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_skillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>
          }
          findMany: {
            args: Prisma.user_skillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>[]
          }
          create: {
            args: Prisma.user_skillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>
          }
          createMany: {
            args: Prisma.user_skillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_skillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>[]
          }
          delete: {
            args: Prisma.user_skillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>
          }
          update: {
            args: Prisma.user_skillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>
          }
          deleteMany: {
            args: Prisma.user_skillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_skillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_skillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>[]
          }
          upsert: {
            args: Prisma.user_skillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_skillsPayload>
          }
          aggregate: {
            args: Prisma.User_skillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_skills>
          }
          groupBy: {
            args: Prisma.user_skillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_skillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_skillsCountArgs<ExtArgs>
            result: $Utils.Optional<User_skillsCountAggregateOutputType> | number
          }
        }
      }
      business_hours: {
        payload: Prisma.$business_hoursPayload<ExtArgs>
        fields: Prisma.business_hoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.business_hoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.business_hoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>
          }
          findFirst: {
            args: Prisma.business_hoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.business_hoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>
          }
          findMany: {
            args: Prisma.business_hoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>[]
          }
          create: {
            args: Prisma.business_hoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>
          }
          createMany: {
            args: Prisma.business_hoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.business_hoursCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>[]
          }
          delete: {
            args: Prisma.business_hoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>
          }
          update: {
            args: Prisma.business_hoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>
          }
          deleteMany: {
            args: Prisma.business_hoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.business_hoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.business_hoursUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>[]
          }
          upsert: {
            args: Prisma.business_hoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$business_hoursPayload>
          }
          aggregate: {
            args: Prisma.Business_hoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness_hours>
          }
          groupBy: {
            args: Prisma.business_hoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<Business_hoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.business_hoursCountArgs<ExtArgs>
            result: $Utils.Optional<Business_hoursCountAggregateOutputType> | number
          }
        }
      }
      holidays: {
        payload: Prisma.$holidaysPayload<ExtArgs>
        fields: Prisma.holidaysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.holidaysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.holidaysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>
          }
          findFirst: {
            args: Prisma.holidaysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.holidaysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>
          }
          findMany: {
            args: Prisma.holidaysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>[]
          }
          create: {
            args: Prisma.holidaysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>
          }
          createMany: {
            args: Prisma.holidaysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.holidaysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>[]
          }
          delete: {
            args: Prisma.holidaysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>
          }
          update: {
            args: Prisma.holidaysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>
          }
          deleteMany: {
            args: Prisma.holidaysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.holidaysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.holidaysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>[]
          }
          upsert: {
            args: Prisma.holidaysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidaysPayload>
          }
          aggregate: {
            args: Prisma.HolidaysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHolidays>
          }
          groupBy: {
            args: Prisma.holidaysGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidaysGroupByOutputType>[]
          }
          count: {
            args: Prisma.holidaysCountArgs<ExtArgs>
            result: $Utils.Optional<HolidaysCountAggregateOutputType> | number
          }
        }
      }
      time_off_requests: {
        payload: Prisma.$time_off_requestsPayload<ExtArgs>
        fields: Prisma.time_off_requestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.time_off_requestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.time_off_requestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>
          }
          findFirst: {
            args: Prisma.time_off_requestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.time_off_requestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>
          }
          findMany: {
            args: Prisma.time_off_requestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>[]
          }
          create: {
            args: Prisma.time_off_requestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>
          }
          createMany: {
            args: Prisma.time_off_requestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.time_off_requestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>[]
          }
          delete: {
            args: Prisma.time_off_requestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>
          }
          update: {
            args: Prisma.time_off_requestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>
          }
          deleteMany: {
            args: Prisma.time_off_requestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.time_off_requestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.time_off_requestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>[]
          }
          upsert: {
            args: Prisma.time_off_requestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$time_off_requestsPayload>
          }
          aggregate: {
            args: Prisma.Time_off_requestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTime_off_requests>
          }
          groupBy: {
            args: Prisma.time_off_requestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Time_off_requestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.time_off_requestsCountArgs<ExtArgs>
            result: $Utils.Optional<Time_off_requestsCountAggregateOutputType> | number
          }
        }
      }
      crews: {
        payload: Prisma.$crewsPayload<ExtArgs>
        fields: Prisma.crewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>
          }
          findFirst: {
            args: Prisma.crewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>
          }
          findMany: {
            args: Prisma.crewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>[]
          }
          create: {
            args: Prisma.crewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>
          }
          createMany: {
            args: Prisma.crewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.crewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>[]
          }
          delete: {
            args: Prisma.crewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>
          }
          update: {
            args: Prisma.crewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>
          }
          deleteMany: {
            args: Prisma.crewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.crewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.crewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>[]
          }
          upsert: {
            args: Prisma.crewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crewsPayload>
          }
          aggregate: {
            args: Prisma.CrewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrews>
          }
          groupBy: {
            args: Prisma.crewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.crewsCountArgs<ExtArgs>
            result: $Utils.Optional<CrewsCountAggregateOutputType> | number
          }
        }
      }
      crew_members: {
        payload: Prisma.$crew_membersPayload<ExtArgs>
        fields: Prisma.crew_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.crew_membersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.crew_membersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>
          }
          findFirst: {
            args: Prisma.crew_membersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.crew_membersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>
          }
          findMany: {
            args: Prisma.crew_membersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>[]
          }
          create: {
            args: Prisma.crew_membersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>
          }
          createMany: {
            args: Prisma.crew_membersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.crew_membersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>[]
          }
          delete: {
            args: Prisma.crew_membersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>
          }
          update: {
            args: Prisma.crew_membersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>
          }
          deleteMany: {
            args: Prisma.crew_membersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.crew_membersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.crew_membersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>[]
          }
          upsert: {
            args: Prisma.crew_membersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$crew_membersPayload>
          }
          aggregate: {
            args: Prisma.Crew_membersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrew_members>
          }
          groupBy: {
            args: Prisma.crew_membersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Crew_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.crew_membersCountArgs<ExtArgs>
            result: $Utils.Optional<Crew_membersCountAggregateOutputType> | number
          }
        }
      }
      equipments: {
        payload: Prisma.$equipmentsPayload<ExtArgs>
        fields: Prisma.equipmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>
          }
          findFirst: {
            args: Prisma.equipmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>
          }
          findMany: {
            args: Prisma.equipmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>[]
          }
          create: {
            args: Prisma.equipmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>
          }
          createMany: {
            args: Prisma.equipmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.equipmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>[]
          }
          delete: {
            args: Prisma.equipmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>
          }
          update: {
            args: Prisma.equipmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>
          }
          deleteMany: {
            args: Prisma.equipmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.equipmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.equipmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>[]
          }
          upsert: {
            args: Prisma.equipmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipmentsPayload>
          }
          aggregate: {
            args: Prisma.EquipmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipments>
          }
          groupBy: {
            args: Prisma.equipmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipmentsCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentsCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      customers: {
        payload: Prisma.$customersPayload<ExtArgs>
        fields: Prisma.customersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findFirst: {
            args: Prisma.customersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findMany: {
            args: Prisma.customersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          create: {
            args: Prisma.customersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          createMany: {
            args: Prisma.customersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          delete: {
            args: Prisma.customersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          update: {
            args: Prisma.customersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          deleteMany: {
            args: Prisma.customersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          upsert: {
            args: Prisma.customersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.customersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.customersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      services: {
        payload: Prisma.$servicesPayload<ExtArgs>
        fields: Prisma.servicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          findFirst: {
            args: Prisma.servicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          findMany: {
            args: Prisma.servicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>[]
          }
          create: {
            args: Prisma.servicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          createMany: {
            args: Prisma.servicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.servicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>[]
          }
          delete: {
            args: Prisma.servicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          update: {
            args: Prisma.servicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          deleteMany: {
            args: Prisma.servicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.servicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>[]
          }
          upsert: {
            args: Prisma.servicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicesPayload>
          }
          aggregate: {
            args: Prisma.ServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServices>
          }
          groupBy: {
            args: Prisma.servicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicesCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesCountAggregateOutputType> | number
          }
        }
      }
      assets: {
        payload: Prisma.$assetsPayload<ExtArgs>
        fields: Prisma.assetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>
          }
          findFirst: {
            args: Prisma.assetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>
          }
          findMany: {
            args: Prisma.assetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>[]
          }
          create: {
            args: Prisma.assetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>
          }
          createMany: {
            args: Prisma.assetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.assetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>[]
          }
          delete: {
            args: Prisma.assetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>
          }
          update: {
            args: Prisma.assetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>
          }
          deleteMany: {
            args: Prisma.assetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.assetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>[]
          }
          upsert: {
            args: Prisma.assetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assetsPayload>
          }
          aggregate: {
            args: Prisma.AssetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssets>
          }
          groupBy: {
            args: Prisma.assetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.assetsCountArgs<ExtArgs>
            result: $Utils.Optional<AssetsCountAggregateOutputType> | number
          }
        }
      }
      parts: {
        payload: Prisma.$partsPayload<ExtArgs>
        fields: Prisma.partsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.partsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.partsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>
          }
          findFirst: {
            args: Prisma.partsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.partsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>
          }
          findMany: {
            args: Prisma.partsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>[]
          }
          create: {
            args: Prisma.partsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>
          }
          createMany: {
            args: Prisma.partsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.partsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>[]
          }
          delete: {
            args: Prisma.partsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>
          }
          update: {
            args: Prisma.partsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>
          }
          deleteMany: {
            args: Prisma.partsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.partsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.partsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>[]
          }
          upsert: {
            args: Prisma.partsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$partsPayload>
          }
          aggregate: {
            args: Prisma.PartsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParts>
          }
          groupBy: {
            args: Prisma.partsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartsGroupByOutputType>[]
          }
          count: {
            args: Prisma.partsCountArgs<ExtArgs>
            result: $Utils.Optional<PartsCountAggregateOutputType> | number
          }
        }
      }
      maintenance_plans: {
        payload: Prisma.$maintenance_plansPayload<ExtArgs>
        fields: Prisma.maintenance_plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.maintenance_plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.maintenance_plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>
          }
          findFirst: {
            args: Prisma.maintenance_plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.maintenance_plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>
          }
          findMany: {
            args: Prisma.maintenance_plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>[]
          }
          create: {
            args: Prisma.maintenance_plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>
          }
          createMany: {
            args: Prisma.maintenance_plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.maintenance_plansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>[]
          }
          delete: {
            args: Prisma.maintenance_plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>
          }
          update: {
            args: Prisma.maintenance_plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>
          }
          deleteMany: {
            args: Prisma.maintenance_plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.maintenance_plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.maintenance_plansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>[]
          }
          upsert: {
            args: Prisma.maintenance_plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plansPayload>
          }
          aggregate: {
            args: Prisma.Maintenance_plansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance_plans>
          }
          groupBy: {
            args: Prisma.maintenance_plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Maintenance_plansGroupByOutputType>[]
          }
          count: {
            args: Prisma.maintenance_plansCountArgs<ExtArgs>
            result: $Utils.Optional<Maintenance_plansCountAggregateOutputType> | number
          }
        }
      }
      maintenance_plan_assets: {
        payload: Prisma.$maintenance_plan_assetsPayload<ExtArgs>
        fields: Prisma.maintenance_plan_assetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.maintenance_plan_assetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.maintenance_plan_assetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>
          }
          findFirst: {
            args: Prisma.maintenance_plan_assetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.maintenance_plan_assetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>
          }
          findMany: {
            args: Prisma.maintenance_plan_assetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>[]
          }
          create: {
            args: Prisma.maintenance_plan_assetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>
          }
          createMany: {
            args: Prisma.maintenance_plan_assetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.maintenance_plan_assetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>[]
          }
          delete: {
            args: Prisma.maintenance_plan_assetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>
          }
          update: {
            args: Prisma.maintenance_plan_assetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>
          }
          deleteMany: {
            args: Prisma.maintenance_plan_assetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.maintenance_plan_assetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.maintenance_plan_assetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>[]
          }
          upsert: {
            args: Prisma.maintenance_plan_assetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maintenance_plan_assetsPayload>
          }
          aggregate: {
            args: Prisma.Maintenance_plan_assetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance_plan_assets>
          }
          groupBy: {
            args: Prisma.maintenance_plan_assetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Maintenance_plan_assetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.maintenance_plan_assetsCountArgs<ExtArgs>
            result: $Utils.Optional<Maintenance_plan_assetsCountAggregateOutputType> | number
          }
        }
      }
      work_orders: {
        payload: Prisma.$work_ordersPayload<ExtArgs>
        fields: Prisma.work_ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.work_ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.work_ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>
          }
          findFirst: {
            args: Prisma.work_ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.work_ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>
          }
          findMany: {
            args: Prisma.work_ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>[]
          }
          create: {
            args: Prisma.work_ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>
          }
          createMany: {
            args: Prisma.work_ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.work_ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>[]
          }
          delete: {
            args: Prisma.work_ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>
          }
          update: {
            args: Prisma.work_ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>
          }
          deleteMany: {
            args: Prisma.work_ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.work_ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.work_ordersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>[]
          }
          upsert: {
            args: Prisma.work_ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_ordersPayload>
          }
          aggregate: {
            args: Prisma.Work_ordersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork_orders>
          }
          groupBy: {
            args: Prisma.work_ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Work_ordersGroupByOutputType>[]
          }
          count: {
            args: Prisma.work_ordersCountArgs<ExtArgs>
            result: $Utils.Optional<Work_ordersCountAggregateOutputType> | number
          }
        }
      }
      work_order_services: {
        payload: Prisma.$work_order_servicesPayload<ExtArgs>
        fields: Prisma.work_order_servicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.work_order_servicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.work_order_servicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>
          }
          findFirst: {
            args: Prisma.work_order_servicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.work_order_servicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>
          }
          findMany: {
            args: Prisma.work_order_servicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>[]
          }
          create: {
            args: Prisma.work_order_servicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>
          }
          createMany: {
            args: Prisma.work_order_servicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.work_order_servicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>[]
          }
          delete: {
            args: Prisma.work_order_servicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>
          }
          update: {
            args: Prisma.work_order_servicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>
          }
          deleteMany: {
            args: Prisma.work_order_servicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.work_order_servicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.work_order_servicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>[]
          }
          upsert: {
            args: Prisma.work_order_servicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_servicesPayload>
          }
          aggregate: {
            args: Prisma.Work_order_servicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork_order_services>
          }
          groupBy: {
            args: Prisma.work_order_servicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Work_order_servicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.work_order_servicesCountArgs<ExtArgs>
            result: $Utils.Optional<Work_order_servicesCountAggregateOutputType> | number
          }
        }
      }
      work_order_tasks: {
        payload: Prisma.$work_order_tasksPayload<ExtArgs>
        fields: Prisma.work_order_tasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.work_order_tasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.work_order_tasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>
          }
          findFirst: {
            args: Prisma.work_order_tasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.work_order_tasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>
          }
          findMany: {
            args: Prisma.work_order_tasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>[]
          }
          create: {
            args: Prisma.work_order_tasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>
          }
          createMany: {
            args: Prisma.work_order_tasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.work_order_tasksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>[]
          }
          delete: {
            args: Prisma.work_order_tasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>
          }
          update: {
            args: Prisma.work_order_tasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>
          }
          deleteMany: {
            args: Prisma.work_order_tasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.work_order_tasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.work_order_tasksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>[]
          }
          upsert: {
            args: Prisma.work_order_tasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_tasksPayload>
          }
          aggregate: {
            args: Prisma.Work_order_tasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork_order_tasks>
          }
          groupBy: {
            args: Prisma.work_order_tasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Work_order_tasksGroupByOutputType>[]
          }
          count: {
            args: Prisma.work_order_tasksCountArgs<ExtArgs>
            result: $Utils.Optional<Work_order_tasksCountAggregateOutputType> | number
          }
        }
      }
      work_order_assets: {
        payload: Prisma.$work_order_assetsPayload<ExtArgs>
        fields: Prisma.work_order_assetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.work_order_assetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.work_order_assetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>
          }
          findFirst: {
            args: Prisma.work_order_assetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.work_order_assetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>
          }
          findMany: {
            args: Prisma.work_order_assetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>[]
          }
          create: {
            args: Prisma.work_order_assetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>
          }
          createMany: {
            args: Prisma.work_order_assetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.work_order_assetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>[]
          }
          delete: {
            args: Prisma.work_order_assetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>
          }
          update: {
            args: Prisma.work_order_assetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>
          }
          deleteMany: {
            args: Prisma.work_order_assetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.work_order_assetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.work_order_assetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>[]
          }
          upsert: {
            args: Prisma.work_order_assetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_assetsPayload>
          }
          aggregate: {
            args: Prisma.Work_order_assetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork_order_assets>
          }
          groupBy: {
            args: Prisma.work_order_assetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Work_order_assetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.work_order_assetsCountArgs<ExtArgs>
            result: $Utils.Optional<Work_order_assetsCountAggregateOutputType> | number
          }
        }
      }
      work_order_crew: {
        payload: Prisma.$work_order_crewPayload<ExtArgs>
        fields: Prisma.work_order_crewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.work_order_crewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.work_order_crewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>
          }
          findFirst: {
            args: Prisma.work_order_crewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.work_order_crewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>
          }
          findMany: {
            args: Prisma.work_order_crewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>[]
          }
          create: {
            args: Prisma.work_order_crewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>
          }
          createMany: {
            args: Prisma.work_order_crewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.work_order_crewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>[]
          }
          delete: {
            args: Prisma.work_order_crewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>
          }
          update: {
            args: Prisma.work_order_crewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>
          }
          deleteMany: {
            args: Prisma.work_order_crewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.work_order_crewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.work_order_crewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>[]
          }
          upsert: {
            args: Prisma.work_order_crewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_crewPayload>
          }
          aggregate: {
            args: Prisma.Work_order_crewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork_order_crew>
          }
          groupBy: {
            args: Prisma.work_order_crewGroupByArgs<ExtArgs>
            result: $Utils.Optional<Work_order_crewGroupByOutputType>[]
          }
          count: {
            args: Prisma.work_order_crewCountArgs<ExtArgs>
            result: $Utils.Optional<Work_order_crewCountAggregateOutputType> | number
          }
        }
      }
      work_order_approvals: {
        payload: Prisma.$work_order_approvalsPayload<ExtArgs>
        fields: Prisma.work_order_approvalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.work_order_approvalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.work_order_approvalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>
          }
          findFirst: {
            args: Prisma.work_order_approvalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.work_order_approvalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>
          }
          findMany: {
            args: Prisma.work_order_approvalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>[]
          }
          create: {
            args: Prisma.work_order_approvalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>
          }
          createMany: {
            args: Prisma.work_order_approvalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.work_order_approvalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>[]
          }
          delete: {
            args: Prisma.work_order_approvalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>
          }
          update: {
            args: Prisma.work_order_approvalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>
          }
          deleteMany: {
            args: Prisma.work_order_approvalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.work_order_approvalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.work_order_approvalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>[]
          }
          upsert: {
            args: Prisma.work_order_approvalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$work_order_approvalsPayload>
          }
          aggregate: {
            args: Prisma.Work_order_approvalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWork_order_approvals>
          }
          groupBy: {
            args: Prisma.work_order_approvalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Work_order_approvalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.work_order_approvalsCountArgs<ExtArgs>
            result: $Utils.Optional<Work_order_approvalsCountAggregateOutputType> | number
          }
        }
      }
      invoices: {
        payload: Prisma.$invoicesPayload<ExtArgs>
        fields: Prisma.invoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          findFirst: {
            args: Prisma.invoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          findMany: {
            args: Prisma.invoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>[]
          }
          create: {
            args: Prisma.invoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          createMany: {
            args: Prisma.invoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>[]
          }
          delete: {
            args: Prisma.invoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          update: {
            args: Prisma.invoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          deleteMany: {
            args: Prisma.invoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>[]
          }
          upsert: {
            args: Prisma.invoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          aggregate: {
            args: Prisma.InvoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoices>
          }
          groupBy: {
            args: Prisma.invoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoicesCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicesCountAggregateOutputType> | number
          }
        }
      }
      invoice_items: {
        payload: Prisma.$invoice_itemsPayload<ExtArgs>
        fields: Prisma.invoice_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoice_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoice_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          findFirst: {
            args: Prisma.invoice_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoice_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          findMany: {
            args: Prisma.invoice_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>[]
          }
          create: {
            args: Prisma.invoice_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          createMany: {
            args: Prisma.invoice_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoice_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>[]
          }
          delete: {
            args: Prisma.invoice_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          update: {
            args: Prisma.invoice_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          deleteMany: {
            args: Prisma.invoice_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoice_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoice_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>[]
          }
          upsert: {
            args: Prisma.invoice_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoice_itemsPayload>
          }
          aggregate: {
            args: Prisma.Invoice_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice_items>
          }
          groupBy: {
            args: Prisma.invoice_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Invoice_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoice_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Invoice_itemsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      email_templates: {
        payload: Prisma.$email_templatesPayload<ExtArgs>
        fields: Prisma.email_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          findFirst: {
            args: Prisma.email_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          findMany: {
            args: Prisma.email_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          create: {
            args: Prisma.email_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          createMany: {
            args: Prisma.email_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          delete: {
            args: Prisma.email_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          update: {
            args: Prisma.email_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          deleteMany: {
            args: Prisma.email_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.email_templatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>[]
          }
          upsert: {
            args: Prisma.email_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_templatesPayload>
          }
          aggregate: {
            args: Prisma.Email_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_templates>
          }
          groupBy: {
            args: Prisma.email_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Email_templatesCountAggregateOutputType> | number
          }
        }
      }
      audit_logs: {
        payload: Prisma.$audit_logsPayload<ExtArgs>
        fields: Prisma.audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findFirst: {
            args: Prisma.audit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findMany: {
            args: Prisma.audit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          create: {
            args: Prisma.audit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          createMany: {
            args: Prisma.audit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.audit_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          delete: {
            args: Prisma.audit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          update: {
            args: Prisma.audit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.audit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.audit_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          upsert: {
            args: Prisma.audit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Audit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_logs>
          }
          groupBy: {
            args: Prisma.audit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsCountAggregateOutputType> | number
          }
        }
      }
      tokens: {
        payload: Prisma.$tokensPayload<ExtArgs>
        fields: Prisma.tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          findFirst: {
            args: Prisma.tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          findMany: {
            args: Prisma.tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          create: {
            args: Prisma.tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          createMany: {
            args: Prisma.tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          delete: {
            args: Prisma.tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          update: {
            args: Prisma.tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          deleteMany: {
            args: Prisma.tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          upsert: {
            args: Prisma.tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          aggregate: {
            args: Prisma.TokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokens>
          }
          groupBy: {
            args: Prisma.tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.tokensCountArgs<ExtArgs>
            result: $Utils.Optional<TokensCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    organizations?: organizationsOmit
    users?: usersOmit
    user_role?: user_roleOmit
    currencies?: currenciesOmit
    user_role_assignments?: user_role_assignmentsOmit
    skills?: skillsOmit
    user_skills?: user_skillsOmit
    business_hours?: business_hoursOmit
    holidays?: holidaysOmit
    time_off_requests?: time_off_requestsOmit
    crews?: crewsOmit
    crew_members?: crew_membersOmit
    equipments?: equipmentsOmit
    companies?: companiesOmit
    customers?: customersOmit
    services?: servicesOmit
    assets?: assetsOmit
    parts?: partsOmit
    maintenance_plans?: maintenance_plansOmit
    maintenance_plan_assets?: maintenance_plan_assetsOmit
    work_orders?: work_ordersOmit
    work_order_services?: work_order_servicesOmit
    work_order_tasks?: work_order_tasksOmit
    work_order_assets?: work_order_assetsOmit
    work_order_crew?: work_order_crewOmit
    work_order_approvals?: work_order_approvalsOmit
    invoices?: invoicesOmit
    invoice_items?: invoice_itemsOmit
    payments?: paymentsOmit
    notifications?: notificationsOmit
    email_templates?: email_templatesOmit
    audit_logs?: audit_logsOmit
    tokens?: tokensOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationsCountOutputType
   */

  export type OrganizationsCountOutputType = {
    users: number
    user_skills: number
    business_hours: number
    holidays: number
    crew_members: number
    equipments: number
    companies: number
    customers: number
    services: number
    assets: number
    parts: number
    maintenance_plans: number
    work_orders: number
  }

  export type OrganizationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationsCountOutputTypeCountUsersArgs
    user_skills?: boolean | OrganizationsCountOutputTypeCountUser_skillsArgs
    business_hours?: boolean | OrganizationsCountOutputTypeCountBusiness_hoursArgs
    holidays?: boolean | OrganizationsCountOutputTypeCountHolidaysArgs
    crew_members?: boolean | OrganizationsCountOutputTypeCountCrew_membersArgs
    equipments?: boolean | OrganizationsCountOutputTypeCountEquipmentsArgs
    companies?: boolean | OrganizationsCountOutputTypeCountCompaniesArgs
    customers?: boolean | OrganizationsCountOutputTypeCountCustomersArgs
    services?: boolean | OrganizationsCountOutputTypeCountServicesArgs
    assets?: boolean | OrganizationsCountOutputTypeCountAssetsArgs
    parts?: boolean | OrganizationsCountOutputTypeCountPartsArgs
    maintenance_plans?: boolean | OrganizationsCountOutputTypeCountMaintenance_plansArgs
    work_orders?: boolean | OrganizationsCountOutputTypeCountWork_ordersArgs
  }

  // Custom InputTypes
  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationsCountOutputType
     */
    select?: OrganizationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountUser_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_skillsWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountBusiness_hoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: business_hoursWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountHolidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: holidaysWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountCrew_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crew_membersWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipmentsWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assetsWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: partsWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountMaintenance_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maintenance_plansWhereInput
  }

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeCountWork_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_ordersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    user_skills: number
    time_off_requests: number
    crews: number
    crew_members: number
    notifications: number
    audit_logs: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_skills?: boolean | UsersCountOutputTypeCountUser_skillsArgs
    time_off_requests?: boolean | UsersCountOutputTypeCountTime_off_requestsArgs
    crews?: boolean | UsersCountOutputTypeCountCrewsArgs
    crew_members?: boolean | UsersCountOutputTypeCountCrew_membersArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    audit_logs?: boolean | UsersCountOutputTypeCountAudit_logsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_skillsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTime_off_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: time_off_requestsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCrew_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crew_membersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAudit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
  }


  /**
   * Count Type SkillsCountOutputType
   */

  export type SkillsCountOutputType = {
    user_skills: number
  }

  export type SkillsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_skills?: boolean | SkillsCountOutputTypeCountUser_skillsArgs
  }

  // Custom InputTypes
  /**
   * SkillsCountOutputType without action
   */
  export type SkillsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsCountOutputType
     */
    select?: SkillsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillsCountOutputType without action
   */
  export type SkillsCountOutputTypeCountUser_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_skillsWhereInput
  }


  /**
   * Count Type CrewsCountOutputType
   */

  export type CrewsCountOutputType = {
    crew_members: number
    work_order_crew: number
  }

  export type CrewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    crew_members?: boolean | CrewsCountOutputTypeCountCrew_membersArgs
    work_order_crew?: boolean | CrewsCountOutputTypeCountWork_order_crewArgs
  }

  // Custom InputTypes
  /**
   * CrewsCountOutputType without action
   */
  export type CrewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewsCountOutputType
     */
    select?: CrewsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrewsCountOutputType without action
   */
  export type CrewsCountOutputTypeCountCrew_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crew_membersWhereInput
  }

  /**
   * CrewsCountOutputType without action
   */
  export type CrewsCountOutputTypeCountWork_order_crewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_crewWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    customers: number
    work_orders: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CompaniesCountOutputTypeCountCustomersArgs
    work_orders?: boolean | CompaniesCountOutputTypeCountWork_ordersArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountWork_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_ordersWhereInput
  }


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    assets: number
    work_orders: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | CustomersCountOutputTypeCountAssetsArgs
    work_orders?: boolean | CustomersCountOutputTypeCountWork_ordersArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assetsWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountWork_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_ordersWhereInput
  }


  /**
   * Count Type ServicesCountOutputType
   */

  export type ServicesCountOutputType = {
    work_order_services: number
    invoice_items: number
  }

  export type ServicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_order_services?: boolean | ServicesCountOutputTypeCountWork_order_servicesArgs
    invoice_items?: boolean | ServicesCountOutputTypeCountInvoice_itemsArgs
  }

  // Custom InputTypes
  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     */
    select?: ServicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountWork_order_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_servicesWhereInput
  }

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeCountInvoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
  }


  /**
   * Count Type AssetsCountOutputType
   */

  export type AssetsCountOutputType = {
    work_orders: number
  }

  export type AssetsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | AssetsCountOutputTypeCountWork_ordersArgs
  }

  // Custom InputTypes
  /**
   * AssetsCountOutputType without action
   */
  export type AssetsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetsCountOutputType
     */
    select?: AssetsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetsCountOutputType without action
   */
  export type AssetsCountOutputTypeCountWork_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_ordersWhereInput
  }


  /**
   * Count Type PartsCountOutputType
   */

  export type PartsCountOutputType = {
    invoice_items: number
  }

  export type PartsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | PartsCountOutputTypeCountInvoice_itemsArgs
  }

  // Custom InputTypes
  /**
   * PartsCountOutputType without action
   */
  export type PartsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartsCountOutputType
     */
    select?: PartsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartsCountOutputType without action
   */
  export type PartsCountOutputTypeCountInvoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
  }


  /**
   * Count Type Maintenance_plansCountOutputType
   */

  export type Maintenance_plansCountOutputType = {
    maintenance_plan_assets: number
    work_orders: number
  }

  export type Maintenance_plansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenance_plan_assets?: boolean | Maintenance_plansCountOutputTypeCountMaintenance_plan_assetsArgs
    work_orders?: boolean | Maintenance_plansCountOutputTypeCountWork_ordersArgs
  }

  // Custom InputTypes
  /**
   * Maintenance_plansCountOutputType without action
   */
  export type Maintenance_plansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance_plansCountOutputType
     */
    select?: Maintenance_plansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Maintenance_plansCountOutputType without action
   */
  export type Maintenance_plansCountOutputTypeCountMaintenance_plan_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maintenance_plan_assetsWhereInput
  }

  /**
   * Maintenance_plansCountOutputType without action
   */
  export type Maintenance_plansCountOutputTypeCountWork_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_ordersWhereInput
  }


  /**
   * Count Type Work_ordersCountOutputType
   */

  export type Work_ordersCountOutputType = {
    work_order_services: number
    work_order_tasks: number
    work_order_assets: number
    work_order_crew: number
    work_order_approvals: number
    invoices: number
  }

  export type Work_ordersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_order_services?: boolean | Work_ordersCountOutputTypeCountWork_order_servicesArgs
    work_order_tasks?: boolean | Work_ordersCountOutputTypeCountWork_order_tasksArgs
    work_order_assets?: boolean | Work_ordersCountOutputTypeCountWork_order_assetsArgs
    work_order_crew?: boolean | Work_ordersCountOutputTypeCountWork_order_crewArgs
    work_order_approvals?: boolean | Work_ordersCountOutputTypeCountWork_order_approvalsArgs
    invoices?: boolean | Work_ordersCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * Work_ordersCountOutputType without action
   */
  export type Work_ordersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Work_ordersCountOutputType
     */
    select?: Work_ordersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Work_ordersCountOutputType without action
   */
  export type Work_ordersCountOutputTypeCountWork_order_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_servicesWhereInput
  }

  /**
   * Work_ordersCountOutputType without action
   */
  export type Work_ordersCountOutputTypeCountWork_order_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_tasksWhereInput
  }

  /**
   * Work_ordersCountOutputType without action
   */
  export type Work_ordersCountOutputTypeCountWork_order_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_assetsWhereInput
  }

  /**
   * Work_ordersCountOutputType without action
   */
  export type Work_ordersCountOutputTypeCountWork_order_crewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_crewWhereInput
  }

  /**
   * Work_ordersCountOutputType without action
   */
  export type Work_ordersCountOutputTypeCountWork_order_approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_approvalsWhereInput
  }

  /**
   * Work_ordersCountOutputType without action
   */
  export type Work_ordersCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
  }


  /**
   * Count Type InvoicesCountOutputType
   */

  export type InvoicesCountOutputType = {
    invoice_items: number
    payments: number
  }

  export type InvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_items?: boolean | InvoicesCountOutputTypeCountInvoice_itemsArgs
    payments?: boolean | InvoicesCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicesCountOutputType
     */
    select?: InvoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountInvoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model organizations
   */

  export type AggregateOrganizations = {
    _count: OrganizationsCountAggregateOutputType | null
    _avg: OrganizationsAvgAggregateOutputType | null
    _sum: OrganizationsSumAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  export type OrganizationsAvgAggregateOutputType = {
    id: number | null
    file_storage_limit: number | null
    data_storage_limit: number | null
    currencyid: number | null
  }

  export type OrganizationsSumAggregateOutputType = {
    id: bigint | null
    file_storage_limit: bigint | null
    data_storage_limit: bigint | null
    currencyid: bigint | null
  }

  export type OrganizationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    address: string | null
    phone: string | null
    organization_name: string | null
    industry_name: string | null
    pincode: string | null
    website: string | null
    timezone: string | null
    plan_type: $Enums.PlanType | null
    subscription_start_date: string | null
    subscription_end_date: string | null
    file_storage_limit: bigint | null
    data_storage_limit: bigint | null
    created_at: string | null
    updated_at: string | null
    currencyid: bigint | null
  }

  export type OrganizationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    address: string | null
    phone: string | null
    organization_name: string | null
    industry_name: string | null
    pincode: string | null
    website: string | null
    timezone: string | null
    plan_type: $Enums.PlanType | null
    subscription_start_date: string | null
    subscription_end_date: string | null
    file_storage_limit: bigint | null
    data_storage_limit: bigint | null
    created_at: string | null
    updated_at: string | null
    currencyid: bigint | null
  }

  export type OrganizationsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    address: number
    phone: number
    organization_name: number
    industry_name: number
    pincode: number
    website: number
    timezone: number
    plan_type: number
    subscription_start_date: number
    subscription_end_date: number
    file_storage_limit: number
    data_storage_limit: number
    created_at: number
    updated_at: number
    currencyid: number
    _all: number
  }


  export type OrganizationsAvgAggregateInputType = {
    id?: true
    file_storage_limit?: true
    data_storage_limit?: true
    currencyid?: true
  }

  export type OrganizationsSumAggregateInputType = {
    id?: true
    file_storage_limit?: true
    data_storage_limit?: true
    currencyid?: true
  }

  export type OrganizationsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    phone?: true
    organization_name?: true
    industry_name?: true
    pincode?: true
    website?: true
    timezone?: true
    plan_type?: true
    subscription_start_date?: true
    subscription_end_date?: true
    file_storage_limit?: true
    data_storage_limit?: true
    created_at?: true
    updated_at?: true
    currencyid?: true
  }

  export type OrganizationsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    phone?: true
    organization_name?: true
    industry_name?: true
    pincode?: true
    website?: true
    timezone?: true
    plan_type?: true
    subscription_start_date?: true
    subscription_end_date?: true
    file_storage_limit?: true
    data_storage_limit?: true
    created_at?: true
    updated_at?: true
    currencyid?: true
  }

  export type OrganizationsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    phone?: true
    organization_name?: true
    industry_name?: true
    pincode?: true
    website?: true
    timezone?: true
    plan_type?: true
    subscription_start_date?: true
    subscription_end_date?: true
    file_storage_limit?: true
    data_storage_limit?: true
    created_at?: true
    updated_at?: true
    currencyid?: true
    _all?: true
  }

  export type OrganizationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations to aggregate.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations
    **/
    _count?: true | OrganizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationsMaxAggregateInputType
  }

  export type GetOrganizationsAggregateType<T extends OrganizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizations[P]>
      : GetScalarType<T[P], AggregateOrganizations[P]>
  }




  export type organizationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationsWhereInput
    orderBy?: organizationsOrderByWithAggregationInput | organizationsOrderByWithAggregationInput[]
    by: OrganizationsScalarFieldEnum[] | OrganizationsScalarFieldEnum
    having?: organizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationsCountAggregateInputType | true
    _avg?: OrganizationsAvgAggregateInputType
    _sum?: OrganizationsSumAggregateInputType
    _min?: OrganizationsMinAggregateInputType
    _max?: OrganizationsMaxAggregateInputType
  }

  export type OrganizationsGroupByOutputType = {
    id: bigint
    name: string
    email: string
    address: string
    phone: string
    organization_name: string
    industry_name: string
    pincode: string
    website: string
    timezone: string
    plan_type: $Enums.PlanType
    subscription_start_date: string
    subscription_end_date: string
    file_storage_limit: bigint
    data_storage_limit: bigint
    created_at: string
    updated_at: string
    currencyid: bigint
    _count: OrganizationsCountAggregateOutputType | null
    _avg: OrganizationsAvgAggregateOutputType | null
    _sum: OrganizationsSumAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  type GetOrganizationsGroupByPayload<T extends organizationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
        }
      >
    >


  export type organizationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    organization_name?: boolean
    industry_name?: boolean
    pincode?: boolean
    website?: boolean
    timezone?: boolean
    plan_type?: boolean
    subscription_start_date?: boolean
    subscription_end_date?: boolean
    file_storage_limit?: boolean
    data_storage_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    currencyid?: boolean
    users?: boolean | organizations$usersArgs<ExtArgs>
    user_skills?: boolean | organizations$user_skillsArgs<ExtArgs>
    business_hours?: boolean | organizations$business_hoursArgs<ExtArgs>
    holidays?: boolean | organizations$holidaysArgs<ExtArgs>
    crew_members?: boolean | organizations$crew_membersArgs<ExtArgs>
    equipments?: boolean | organizations$equipmentsArgs<ExtArgs>
    companies?: boolean | organizations$companiesArgs<ExtArgs>
    customers?: boolean | organizations$customersArgs<ExtArgs>
    services?: boolean | organizations$servicesArgs<ExtArgs>
    assets?: boolean | organizations$assetsArgs<ExtArgs>
    parts?: boolean | organizations$partsArgs<ExtArgs>
    maintenance_plans?: boolean | organizations$maintenance_plansArgs<ExtArgs>
    work_orders?: boolean | organizations$work_ordersArgs<ExtArgs>
    _count?: boolean | OrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizations"]>

  export type organizationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    organization_name?: boolean
    industry_name?: boolean
    pincode?: boolean
    website?: boolean
    timezone?: boolean
    plan_type?: boolean
    subscription_start_date?: boolean
    subscription_end_date?: boolean
    file_storage_limit?: boolean
    data_storage_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    currencyid?: boolean
  }, ExtArgs["result"]["organizations"]>

  export type organizationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    organization_name?: boolean
    industry_name?: boolean
    pincode?: boolean
    website?: boolean
    timezone?: boolean
    plan_type?: boolean
    subscription_start_date?: boolean
    subscription_end_date?: boolean
    file_storage_limit?: boolean
    data_storage_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    currencyid?: boolean
  }, ExtArgs["result"]["organizations"]>

  export type organizationsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    phone?: boolean
    organization_name?: boolean
    industry_name?: boolean
    pincode?: boolean
    website?: boolean
    timezone?: boolean
    plan_type?: boolean
    subscription_start_date?: boolean
    subscription_end_date?: boolean
    file_storage_limit?: boolean
    data_storage_limit?: boolean
    created_at?: boolean
    updated_at?: boolean
    currencyid?: boolean
  }

  export type organizationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "address" | "phone" | "organization_name" | "industry_name" | "pincode" | "website" | "timezone" | "plan_type" | "subscription_start_date" | "subscription_end_date" | "file_storage_limit" | "data_storage_limit" | "created_at" | "updated_at" | "currencyid", ExtArgs["result"]["organizations"]>
  export type organizationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | organizations$usersArgs<ExtArgs>
    user_skills?: boolean | organizations$user_skillsArgs<ExtArgs>
    business_hours?: boolean | organizations$business_hoursArgs<ExtArgs>
    holidays?: boolean | organizations$holidaysArgs<ExtArgs>
    crew_members?: boolean | organizations$crew_membersArgs<ExtArgs>
    equipments?: boolean | organizations$equipmentsArgs<ExtArgs>
    companies?: boolean | organizations$companiesArgs<ExtArgs>
    customers?: boolean | organizations$customersArgs<ExtArgs>
    services?: boolean | organizations$servicesArgs<ExtArgs>
    assets?: boolean | organizations$assetsArgs<ExtArgs>
    parts?: boolean | organizations$partsArgs<ExtArgs>
    maintenance_plans?: boolean | organizations$maintenance_plansArgs<ExtArgs>
    work_orders?: boolean | organizations$work_ordersArgs<ExtArgs>
    _count?: boolean | OrganizationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type organizationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type organizationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $organizationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organizations"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
      user_skills: Prisma.$user_skillsPayload<ExtArgs>[]
      business_hours: Prisma.$business_hoursPayload<ExtArgs>[]
      holidays: Prisma.$holidaysPayload<ExtArgs>[]
      crew_members: Prisma.$crew_membersPayload<ExtArgs>[]
      equipments: Prisma.$equipmentsPayload<ExtArgs>[]
      companies: Prisma.$companiesPayload<ExtArgs>[]
      customers: Prisma.$customersPayload<ExtArgs>[]
      services: Prisma.$servicesPayload<ExtArgs>[]
      assets: Prisma.$assetsPayload<ExtArgs>[]
      parts: Prisma.$partsPayload<ExtArgs>[]
      maintenance_plans: Prisma.$maintenance_plansPayload<ExtArgs>[]
      work_orders: Prisma.$work_ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      email: string
      address: string
      phone: string
      organization_name: string
      industry_name: string
      pincode: string
      website: string
      timezone: string
      plan_type: $Enums.PlanType
      subscription_start_date: string
      subscription_end_date: string
      file_storage_limit: bigint
      data_storage_limit: bigint
      created_at: string
      updated_at: string
      currencyid: bigint
    }, ExtArgs["result"]["organizations"]>
    composites: {}
  }

  type organizationsGetPayload<S extends boolean | null | undefined | organizationsDefaultArgs> = $Result.GetResult<Prisma.$organizationsPayload, S>

  type organizationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<organizationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationsCountAggregateInputType | true
    }

  export interface organizationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organizations'], meta: { name: 'organizations' } }
    /**
     * Find zero or one Organizations that matches the filter.
     * @param {organizationsFindUniqueArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends organizationsFindUniqueArgs>(args: SelectSubset<T, organizationsFindUniqueArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organizations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {organizationsFindUniqueOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends organizationsFindUniqueOrThrowArgs>(args: SelectSubset<T, organizationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends organizationsFindFirstArgs>(args?: SelectSubset<T, organizationsFindFirstArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organizations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends organizationsFindFirstOrThrowArgs>(args?: SelectSubset<T, organizationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organizations.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organizations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationsWithIdOnly = await prisma.organizations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends organizationsFindManyArgs>(args?: SelectSubset<T, organizationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organizations.
     * @param {organizationsCreateArgs} args - Arguments to create a Organizations.
     * @example
     * // Create one Organizations
     * const Organizations = await prisma.organizations.create({
     *   data: {
     *     // ... data to create a Organizations
     *   }
     * })
     * 
     */
    create<T extends organizationsCreateArgs>(args: SelectSubset<T, organizationsCreateArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {organizationsCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organizations = await prisma.organizations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends organizationsCreateManyArgs>(args?: SelectSubset<T, organizationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {organizationsCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organizations = await prisma.organizations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationsWithIdOnly = await prisma.organizations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends organizationsCreateManyAndReturnArgs>(args?: SelectSubset<T, organizationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organizations.
     * @param {organizationsDeleteArgs} args - Arguments to delete one Organizations.
     * @example
     * // Delete one Organizations
     * const Organizations = await prisma.organizations.delete({
     *   where: {
     *     // ... filter to delete one Organizations
     *   }
     * })
     * 
     */
    delete<T extends organizationsDeleteArgs>(args: SelectSubset<T, organizationsDeleteArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organizations.
     * @param {organizationsUpdateArgs} args - Arguments to update one Organizations.
     * @example
     * // Update one Organizations
     * const organizations = await prisma.organizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends organizationsUpdateArgs>(args: SelectSubset<T, organizationsUpdateArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {organizationsDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends organizationsDeleteManyArgs>(args?: SelectSubset<T, organizationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organizations = await prisma.organizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends organizationsUpdateManyArgs>(args: SelectSubset<T, organizationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {organizationsUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organizations = await prisma.organizations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationsWithIdOnly = await prisma.organizations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends organizationsUpdateManyAndReturnArgs>(args: SelectSubset<T, organizationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organizations.
     * @param {organizationsUpsertArgs} args - Arguments to update or create a Organizations.
     * @example
     * // Update or create a Organizations
     * const organizations = await prisma.organizations.upsert({
     *   create: {
     *     // ... data to create a Organizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organizations we want to update
     *   }
     * })
     */
    upsert<T extends organizationsUpsertArgs>(args: SelectSubset<T, organizationsUpsertArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organizations.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends organizationsCountArgs>(
      args?: Subset<T, organizationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationsAggregateArgs>(args: Subset<T, OrganizationsAggregateArgs>): Prisma.PrismaPromise<GetOrganizationsAggregateType<T>>

    /**
     * Group by Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organizationsGroupByArgs['orderBy'] }
        : { orderBy?: organizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organizations model
   */
  readonly fields: organizationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organizationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends organizations$usersArgs<ExtArgs> = {}>(args?: Subset<T, organizations$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_skills<T extends organizations$user_skillsArgs<ExtArgs> = {}>(args?: Subset<T, organizations$user_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    business_hours<T extends organizations$business_hoursArgs<ExtArgs> = {}>(args?: Subset<T, organizations$business_hoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    holidays<T extends organizations$holidaysArgs<ExtArgs> = {}>(args?: Subset<T, organizations$holidaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crew_members<T extends organizations$crew_membersArgs<ExtArgs> = {}>(args?: Subset<T, organizations$crew_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipments<T extends organizations$equipmentsArgs<ExtArgs> = {}>(args?: Subset<T, organizations$equipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends organizations$companiesArgs<ExtArgs> = {}>(args?: Subset<T, organizations$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends organizations$customersArgs<ExtArgs> = {}>(args?: Subset<T, organizations$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends organizations$servicesArgs<ExtArgs> = {}>(args?: Subset<T, organizations$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assets<T extends organizations$assetsArgs<ExtArgs> = {}>(args?: Subset<T, organizations$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parts<T extends organizations$partsArgs<ExtArgs> = {}>(args?: Subset<T, organizations$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenance_plans<T extends organizations$maintenance_plansArgs<ExtArgs> = {}>(args?: Subset<T, organizations$maintenance_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_orders<T extends organizations$work_ordersArgs<ExtArgs> = {}>(args?: Subset<T, organizations$work_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the organizations model
   */
  interface organizationsFieldRefs {
    readonly id: FieldRef<"organizations", 'BigInt'>
    readonly name: FieldRef<"organizations", 'String'>
    readonly email: FieldRef<"organizations", 'String'>
    readonly address: FieldRef<"organizations", 'String'>
    readonly phone: FieldRef<"organizations", 'String'>
    readonly organization_name: FieldRef<"organizations", 'String'>
    readonly industry_name: FieldRef<"organizations", 'String'>
    readonly pincode: FieldRef<"organizations", 'String'>
    readonly website: FieldRef<"organizations", 'String'>
    readonly timezone: FieldRef<"organizations", 'String'>
    readonly plan_type: FieldRef<"organizations", 'PlanType'>
    readonly subscription_start_date: FieldRef<"organizations", 'String'>
    readonly subscription_end_date: FieldRef<"organizations", 'String'>
    readonly file_storage_limit: FieldRef<"organizations", 'BigInt'>
    readonly data_storage_limit: FieldRef<"organizations", 'BigInt'>
    readonly created_at: FieldRef<"organizations", 'String'>
    readonly updated_at: FieldRef<"organizations", 'String'>
    readonly currencyid: FieldRef<"organizations", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * organizations findUnique
   */
  export type organizationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }

  /**
   * organizations findUniqueOrThrow
   */
  export type organizationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }

  /**
   * organizations findFirst
   */
  export type organizationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationsScalarFieldEnum | OrganizationsScalarFieldEnum[]
  }

  /**
   * organizations findFirstOrThrow
   */
  export type organizationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationsScalarFieldEnum | OrganizationsScalarFieldEnum[]
  }

  /**
   * organizations findMany
   */
  export type organizationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationsOrderByWithRelationInput | organizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    distinct?: OrganizationsScalarFieldEnum | OrganizationsScalarFieldEnum[]
  }

  /**
   * organizations create
   */
  export type organizationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * The data needed to create a organizations.
     */
    data: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
  }

  /**
   * organizations createMany
   */
  export type organizationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organizations.
     */
    data: organizationsCreateManyInput | organizationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * organizations createManyAndReturn
   */
  export type organizationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * The data used to create many organizations.
     */
    data: organizationsCreateManyInput | organizationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * organizations update
   */
  export type organizationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * The data needed to update a organizations.
     */
    data: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
    /**
     * Choose, which organizations to update.
     */
    where: organizationsWhereUniqueInput
  }

  /**
   * organizations updateMany
   */
  export type organizationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationsWhereInput
    /**
     * Limit how many organizations to update.
     */
    limit?: number
  }

  /**
   * organizations updateManyAndReturn
   */
  export type organizationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationsWhereInput
    /**
     * Limit how many organizations to update.
     */
    limit?: number
  }

  /**
   * organizations upsert
   */
  export type organizationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * The filter to search for the organizations to update in case it exists.
     */
    where: organizationsWhereUniqueInput
    /**
     * In case the organizations found by the `where` argument doesn't exist, create a new organizations with this data.
     */
    create: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
    /**
     * In case the organizations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
  }

  /**
   * organizations delete
   */
  export type organizationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
    /**
     * Filter which organizations to delete.
     */
    where: organizationsWhereUniqueInput
  }

  /**
   * organizations deleteMany
   */
  export type organizationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations to delete
     */
    where?: organizationsWhereInput
    /**
     * Limit how many organizations to delete.
     */
    limit?: number
  }

  /**
   * organizations.users
   */
  export type organizations$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * organizations.user_skills
   */
  export type organizations$user_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    where?: user_skillsWhereInput
    orderBy?: user_skillsOrderByWithRelationInput | user_skillsOrderByWithRelationInput[]
    cursor?: user_skillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_skillsScalarFieldEnum | User_skillsScalarFieldEnum[]
  }

  /**
   * organizations.business_hours
   */
  export type organizations$business_hoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    where?: business_hoursWhereInput
    orderBy?: business_hoursOrderByWithRelationInput | business_hoursOrderByWithRelationInput[]
    cursor?: business_hoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Business_hoursScalarFieldEnum | Business_hoursScalarFieldEnum[]
  }

  /**
   * organizations.holidays
   */
  export type organizations$holidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    where?: holidaysWhereInput
    orderBy?: holidaysOrderByWithRelationInput | holidaysOrderByWithRelationInput[]
    cursor?: holidaysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HolidaysScalarFieldEnum | HolidaysScalarFieldEnum[]
  }

  /**
   * organizations.crew_members
   */
  export type organizations$crew_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    where?: crew_membersWhereInput
    orderBy?: crew_membersOrderByWithRelationInput | crew_membersOrderByWithRelationInput[]
    cursor?: crew_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Crew_membersScalarFieldEnum | Crew_membersScalarFieldEnum[]
  }

  /**
   * organizations.equipments
   */
  export type organizations$equipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    where?: equipmentsWhereInput
    orderBy?: equipmentsOrderByWithRelationInput | equipmentsOrderByWithRelationInput[]
    cursor?: equipmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentsScalarFieldEnum | EquipmentsScalarFieldEnum[]
  }

  /**
   * organizations.companies
   */
  export type organizations$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    cursor?: companiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * organizations.customers
   */
  export type organizations$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    cursor?: customersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * organizations.services
   */
  export type organizations$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    where?: servicesWhereInput
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    cursor?: servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * organizations.assets
   */
  export type organizations$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    where?: assetsWhereInput
    orderBy?: assetsOrderByWithRelationInput | assetsOrderByWithRelationInput[]
    cursor?: assetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetsScalarFieldEnum | AssetsScalarFieldEnum[]
  }

  /**
   * organizations.parts
   */
  export type organizations$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    where?: partsWhereInput
    orderBy?: partsOrderByWithRelationInput | partsOrderByWithRelationInput[]
    cursor?: partsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * organizations.maintenance_plans
   */
  export type organizations$maintenance_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    where?: maintenance_plansWhereInput
    orderBy?: maintenance_plansOrderByWithRelationInput | maintenance_plansOrderByWithRelationInput[]
    cursor?: maintenance_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Maintenance_plansScalarFieldEnum | Maintenance_plansScalarFieldEnum[]
  }

  /**
   * organizations.work_orders
   */
  export type organizations$work_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    where?: work_ordersWhereInput
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    cursor?: work_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * organizations without action
   */
  export type organizationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organizations
     */
    omit?: organizationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    is_active: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    is_active: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    email: string | null
    password_hash: string | null
    isVerified_Email: boolean | null
    isVerified_PhoneNumber: boolean | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    job_title: string | null
    user_type: $Enums.UserRole | null
    is_active: number | null
    last_login_at: string | null
    email_verified: boolean | null
    created_at: string | null
    updated_at: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    email: string | null
    password_hash: string | null
    isVerified_Email: boolean | null
    isVerified_PhoneNumber: boolean | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    job_title: string | null
    user_type: $Enums.UserRole | null
    is_active: number | null
    last_login_at: string | null
    email_verified: boolean | null
    created_at: string | null
    updated_at: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    organization_id: number
    email: number
    password_hash: number
    isVerified_Email: number
    isVerified_PhoneNumber: number
    first_name: number
    last_name: number
    phone: number
    job_title: number
    user_type: number
    is_active: number
    last_login_at: number
    email_verified: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    organization_id?: true
    is_active?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    organization_id?: true
    is_active?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    organization_id?: true
    email?: true
    password_hash?: true
    isVerified_Email?: true
    isVerified_PhoneNumber?: true
    first_name?: true
    last_name?: true
    phone?: true
    job_title?: true
    user_type?: true
    is_active?: true
    last_login_at?: true
    email_verified?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    organization_id?: true
    email?: true
    password_hash?: true
    isVerified_Email?: true
    isVerified_PhoneNumber?: true
    first_name?: true
    last_name?: true
    phone?: true
    job_title?: true
    user_type?: true
    is_active?: true
    last_login_at?: true
    email_verified?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    organization_id?: true
    email?: true
    password_hash?: true
    isVerified_Email?: true
    isVerified_PhoneNumber?: true
    first_name?: true
    last_name?: true
    phone?: true
    job_title?: true
    user_type?: true
    is_active?: true
    last_login_at?: true
    email_verified?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: bigint
    organization_id: bigint
    email: string
    password_hash: string
    isVerified_Email: boolean
    isVerified_PhoneNumber: boolean
    first_name: string
    last_name: string
    phone: string
    job_title: string
    user_type: $Enums.UserRole
    is_active: number
    last_login_at: string
    email_verified: boolean
    created_at: string
    updated_at: string
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    email?: boolean
    password_hash?: boolean
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    job_title?: boolean
    user_type?: boolean
    is_active?: boolean
    last_login_at?: boolean
    email_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    user_skills?: boolean | users$user_skillsArgs<ExtArgs>
    time_off_requests?: boolean | users$time_off_requestsArgs<ExtArgs>
    crews?: boolean | users$crewsArgs<ExtArgs>
    crew_members?: boolean | users$crew_membersArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    email?: boolean
    password_hash?: boolean
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    job_title?: boolean
    user_type?: boolean
    is_active?: boolean
    last_login_at?: boolean
    email_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    email?: boolean
    password_hash?: boolean
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    job_title?: boolean
    user_type?: boolean
    is_active?: boolean
    last_login_at?: boolean
    email_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    organization_id?: boolean
    email?: boolean
    password_hash?: boolean
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    job_title?: boolean
    user_type?: boolean
    is_active?: boolean
    last_login_at?: boolean
    email_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "email" | "password_hash" | "isVerified_Email" | "isVerified_PhoneNumber" | "first_name" | "last_name" | "phone" | "job_title" | "user_type" | "is_active" | "last_login_at" | "email_verified" | "created_at" | "updated_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    user_skills?: boolean | users$user_skillsArgs<ExtArgs>
    time_off_requests?: boolean | users$time_off_requestsArgs<ExtArgs>
    crews?: boolean | users$crewsArgs<ExtArgs>
    crew_members?: boolean | users$crew_membersArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      user_skills: Prisma.$user_skillsPayload<ExtArgs>[]
      time_off_requests: Prisma.$time_off_requestsPayload<ExtArgs>[]
      crews: Prisma.$crewsPayload<ExtArgs>[]
      crew_members: Prisma.$crew_membersPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      audit_logs: Prisma.$audit_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      email: string
      password_hash: string
      isVerified_Email: boolean
      isVerified_PhoneNumber: boolean
      first_name: string
      last_name: string
      phone: string
      job_title: string
      user_type: $Enums.UserRole
      is_active: number
      last_login_at: string
      email_verified: boolean
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_skills<T extends users$user_skillsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    time_off_requests<T extends users$time_off_requestsArgs<ExtArgs> = {}>(args?: Subset<T, users$time_off_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crews<T extends users$crewsArgs<ExtArgs> = {}>(args?: Subset<T, users$crewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crew_members<T extends users$crew_membersArgs<ExtArgs> = {}>(args?: Subset<T, users$crew_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audit_logs<T extends users$audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'BigInt'>
    readonly organization_id: FieldRef<"users", 'BigInt'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly isVerified_Email: FieldRef<"users", 'Boolean'>
    readonly isVerified_PhoneNumber: FieldRef<"users", 'Boolean'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly job_title: FieldRef<"users", 'String'>
    readonly user_type: FieldRef<"users", 'UserRole'>
    readonly is_active: FieldRef<"users", 'Int'>
    readonly last_login_at: FieldRef<"users", 'String'>
    readonly email_verified: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'String'>
    readonly updated_at: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.user_skills
   */
  export type users$user_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    where?: user_skillsWhereInput
    orderBy?: user_skillsOrderByWithRelationInput | user_skillsOrderByWithRelationInput[]
    cursor?: user_skillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_skillsScalarFieldEnum | User_skillsScalarFieldEnum[]
  }

  /**
   * users.time_off_requests
   */
  export type users$time_off_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    where?: time_off_requestsWhereInput
    orderBy?: time_off_requestsOrderByWithRelationInput | time_off_requestsOrderByWithRelationInput[]
    cursor?: time_off_requestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Time_off_requestsScalarFieldEnum | Time_off_requestsScalarFieldEnum[]
  }

  /**
   * users.crews
   */
  export type users$crewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    where?: crewsWhereInput
    orderBy?: crewsOrderByWithRelationInput | crewsOrderByWithRelationInput[]
    cursor?: crewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewsScalarFieldEnum | CrewsScalarFieldEnum[]
  }

  /**
   * users.crew_members
   */
  export type users$crew_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    where?: crew_membersWhereInput
    orderBy?: crew_membersOrderByWithRelationInput | crew_membersOrderByWithRelationInput[]
    cursor?: crew_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Crew_membersScalarFieldEnum | Crew_membersScalarFieldEnum[]
  }

  /**
   * users.notifications
   */
  export type users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.audit_logs
   */
  export type users$audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    cursor?: audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model user_role
   */

  export type AggregateUser_role = {
    _count: User_roleCountAggregateOutputType | null
    _avg: User_roleAvgAggregateOutputType | null
    _sum: User_roleSumAggregateOutputType | null
    _min: User_roleMinAggregateOutputType | null
    _max: User_roleMaxAggregateOutputType | null
  }

  export type User_roleAvgAggregateOutputType = {
    id: number | null
  }

  export type User_roleSumAggregateOutputType = {
    id: bigint | null
  }

  export type User_roleMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type User_roleMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type User_roleCountAggregateOutputType = {
    id: number
    name: number
    access_rights: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_roleAvgAggregateInputType = {
    id?: true
  }

  export type User_roleSumAggregateInputType = {
    id?: true
  }

  export type User_roleMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type User_roleMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type User_roleCountAggregateInputType = {
    id?: true
    name?: true
    access_rights?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_role to aggregate.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_roleMaxAggregateInputType
  }

  export type GetUser_roleAggregateType<T extends User_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_role[P]>
      : GetScalarType<T[P], AggregateUser_role[P]>
  }




  export type user_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_roleWhereInput
    orderBy?: user_roleOrderByWithAggregationInput | user_roleOrderByWithAggregationInput[]
    by: User_roleScalarFieldEnum[] | User_roleScalarFieldEnum
    having?: user_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_roleCountAggregateInputType | true
    _avg?: User_roleAvgAggregateInputType
    _sum?: User_roleSumAggregateInputType
    _min?: User_roleMinAggregateInputType
    _max?: User_roleMaxAggregateInputType
  }

  export type User_roleGroupByOutputType = {
    id: bigint
    name: string
    access_rights: JsonValue
    created_at: string
    updated_at: string
    _count: User_roleCountAggregateOutputType | null
    _avg: User_roleAvgAggregateOutputType | null
    _sum: User_roleSumAggregateOutputType | null
    _min: User_roleMinAggregateOutputType | null
    _max: User_roleMaxAggregateOutputType | null
  }

  type GetUser_roleGroupByPayload<T extends user_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_roleGroupByOutputType[P]>
            : GetScalarType<T[P], User_roleGroupByOutputType[P]>
        }
      >
    >


  export type user_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    access_rights?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_role"]>

  export type user_roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    access_rights?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_role"]>

  export type user_roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    access_rights?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_role"]>

  export type user_roleSelectScalar = {
    id?: boolean
    name?: boolean
    access_rights?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type user_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "access_rights" | "created_at" | "updated_at", ExtArgs["result"]["user_role"]>

  export type $user_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_role"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      access_rights: Prisma.JsonValue
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["user_role"]>
    composites: {}
  }

  type user_roleGetPayload<S extends boolean | null | undefined | user_roleDefaultArgs> = $Result.GetResult<Prisma.$user_rolePayload, S>

  type user_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_roleCountAggregateInputType | true
    }

  export interface user_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_role'], meta: { name: 'user_role' } }
    /**
     * Find zero or one User_role that matches the filter.
     * @param {user_roleFindUniqueArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_roleFindUniqueArgs>(args: SelectSubset<T, user_roleFindUniqueArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_roleFindUniqueOrThrowArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, user_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindFirstArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_roleFindFirstArgs>(args?: SelectSubset<T, user_roleFindFirstArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindFirstOrThrowArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, user_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_role.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_roleWithIdOnly = await prisma.user_role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_roleFindManyArgs>(args?: SelectSubset<T, user_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_role.
     * @param {user_roleCreateArgs} args - Arguments to create a User_role.
     * @example
     * // Create one User_role
     * const User_role = await prisma.user_role.create({
     *   data: {
     *     // ... data to create a User_role
     *   }
     * })
     * 
     */
    create<T extends user_roleCreateArgs>(args: SelectSubset<T, user_roleCreateArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_roles.
     * @param {user_roleCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_role = await prisma.user_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_roleCreateManyArgs>(args?: SelectSubset<T, user_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_roles and returns the data saved in the database.
     * @param {user_roleCreateManyAndReturnArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_role = await prisma.user_role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_roles and only return the `id`
     * const user_roleWithIdOnly = await prisma.user_role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_roleCreateManyAndReturnArgs>(args?: SelectSubset<T, user_roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_role.
     * @param {user_roleDeleteArgs} args - Arguments to delete one User_role.
     * @example
     * // Delete one User_role
     * const User_role = await prisma.user_role.delete({
     *   where: {
     *     // ... filter to delete one User_role
     *   }
     * })
     * 
     */
    delete<T extends user_roleDeleteArgs>(args: SelectSubset<T, user_roleDeleteArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_role.
     * @param {user_roleUpdateArgs} args - Arguments to update one User_role.
     * @example
     * // Update one User_role
     * const user_role = await prisma.user_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_roleUpdateArgs>(args: SelectSubset<T, user_roleUpdateArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_roles.
     * @param {user_roleDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_roleDeleteManyArgs>(args?: SelectSubset<T, user_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_role = await prisma.user_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_roleUpdateManyArgs>(args: SelectSubset<T, user_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles and returns the data updated in the database.
     * @param {user_roleUpdateManyAndReturnArgs} args - Arguments to update many User_roles.
     * @example
     * // Update many User_roles
     * const user_role = await prisma.user_role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_roles and only return the `id`
     * const user_roleWithIdOnly = await prisma.user_role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_roleUpdateManyAndReturnArgs>(args: SelectSubset<T, user_roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_role.
     * @param {user_roleUpsertArgs} args - Arguments to update or create a User_role.
     * @example
     * // Update or create a User_role
     * const user_role = await prisma.user_role.upsert({
     *   create: {
     *     // ... data to create a User_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_role we want to update
     *   }
     * })
     */
    upsert<T extends user_roleUpsertArgs>(args: SelectSubset<T, user_roleUpsertArgs<ExtArgs>>): Prisma__user_roleClient<$Result.GetResult<Prisma.$user_rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_role.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_roleCountArgs>(
      args?: Subset<T, user_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_roleAggregateArgs>(args: Subset<T, User_roleAggregateArgs>): Prisma.PrismaPromise<GetUser_roleAggregateType<T>>

    /**
     * Group by User_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_roleGroupByArgs['orderBy'] }
        : { orderBy?: user_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_role model
   */
  readonly fields: user_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_role model
   */
  interface user_roleFieldRefs {
    readonly id: FieldRef<"user_role", 'BigInt'>
    readonly name: FieldRef<"user_role", 'String'>
    readonly access_rights: FieldRef<"user_role", 'Json'>
    readonly created_at: FieldRef<"user_role", 'String'>
    readonly updated_at: FieldRef<"user_role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_role findUnique
   */
  export type user_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role findUniqueOrThrow
   */
  export type user_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role findFirst
   */
  export type user_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_roleScalarFieldEnum | User_roleScalarFieldEnum[]
  }

  /**
   * user_role findFirstOrThrow
   */
  export type user_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Filter, which user_role to fetch.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_roleScalarFieldEnum | User_roleScalarFieldEnum[]
  }

  /**
   * user_role findMany
   */
  export type user_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_roleOrderByWithRelationInput | user_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_roleScalarFieldEnum | User_roleScalarFieldEnum[]
  }

  /**
   * user_role create
   */
  export type user_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * The data needed to create a user_role.
     */
    data: XOR<user_roleCreateInput, user_roleUncheckedCreateInput>
  }

  /**
   * user_role createMany
   */
  export type user_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_roleCreateManyInput | user_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_role createManyAndReturn
   */
  export type user_roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * The data used to create many user_roles.
     */
    data: user_roleCreateManyInput | user_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_role update
   */
  export type user_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * The data needed to update a user_role.
     */
    data: XOR<user_roleUpdateInput, user_roleUncheckedUpdateInput>
    /**
     * Choose, which user_role to update.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role updateMany
   */
  export type user_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_roleUpdateManyMutationInput, user_roleUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_roleWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_role updateManyAndReturn
   */
  export type user_roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_roleUpdateManyMutationInput, user_roleUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_roleWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_role upsert
   */
  export type user_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * The filter to search for the user_role to update in case it exists.
     */
    where: user_roleWhereUniqueInput
    /**
     * In case the user_role found by the `where` argument doesn't exist, create a new user_role with this data.
     */
    create: XOR<user_roleCreateInput, user_roleUncheckedCreateInput>
    /**
     * In case the user_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_roleUpdateInput, user_roleUncheckedUpdateInput>
  }

  /**
   * user_role delete
   */
  export type user_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
    /**
     * Filter which user_role to delete.
     */
    where: user_roleWhereUniqueInput
  }

  /**
   * user_role deleteMany
   */
  export type user_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_roleWhereInput
    /**
     * Limit how many user_roles to delete.
     */
    limit?: number
  }

  /**
   * user_role without action
   */
  export type user_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role
     */
    select?: user_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role
     */
    omit?: user_roleOmit<ExtArgs> | null
  }


  /**
   * Model currencies
   */

  export type AggregateCurrencies = {
    _count: CurrenciesCountAggregateOutputType | null
    _avg: CurrenciesAvgAggregateOutputType | null
    _sum: CurrenciesSumAggregateOutputType | null
    _min: CurrenciesMinAggregateOutputType | null
    _max: CurrenciesMaxAggregateOutputType | null
  }

  export type CurrenciesAvgAggregateOutputType = {
    id: number | null
    exchange_rate: Decimal | null
  }

  export type CurrenciesSumAggregateOutputType = {
    id: bigint | null
    exchange_rate: Decimal | null
  }

  export type CurrenciesMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    name: string | null
    exchange_rate: Decimal | null
    is_default: boolean | null
    created_at: string | null
    updated_at: string | null
  }

  export type CurrenciesMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    name: string | null
    exchange_rate: Decimal | null
    is_default: boolean | null
    created_at: string | null
    updated_at: string | null
  }

  export type CurrenciesCountAggregateOutputType = {
    id: number
    code: number
    name: number
    exchange_rate: number
    is_default: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CurrenciesAvgAggregateInputType = {
    id?: true
    exchange_rate?: true
  }

  export type CurrenciesSumAggregateInputType = {
    id?: true
    exchange_rate?: true
  }

  export type CurrenciesMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    exchange_rate?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type CurrenciesMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    exchange_rate?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type CurrenciesCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    exchange_rate?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CurrenciesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which currencies to aggregate.
     */
    where?: currenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currenciesOrderByWithRelationInput | currenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: currenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned currencies
    **/
    _count?: true | CurrenciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrenciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrenciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrenciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrenciesMaxAggregateInputType
  }

  export type GetCurrenciesAggregateType<T extends CurrenciesAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrencies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrencies[P]>
      : GetScalarType<T[P], AggregateCurrencies[P]>
  }




  export type currenciesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: currenciesWhereInput
    orderBy?: currenciesOrderByWithAggregationInput | currenciesOrderByWithAggregationInput[]
    by: CurrenciesScalarFieldEnum[] | CurrenciesScalarFieldEnum
    having?: currenciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrenciesCountAggregateInputType | true
    _avg?: CurrenciesAvgAggregateInputType
    _sum?: CurrenciesSumAggregateInputType
    _min?: CurrenciesMinAggregateInputType
    _max?: CurrenciesMaxAggregateInputType
  }

  export type CurrenciesGroupByOutputType = {
    id: bigint
    code: string
    name: string
    exchange_rate: Decimal
    is_default: boolean
    created_at: string
    updated_at: string
    _count: CurrenciesCountAggregateOutputType | null
    _avg: CurrenciesAvgAggregateOutputType | null
    _sum: CurrenciesSumAggregateOutputType | null
    _min: CurrenciesMinAggregateOutputType | null
    _max: CurrenciesMaxAggregateOutputType | null
  }

  type GetCurrenciesGroupByPayload<T extends currenciesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrenciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrenciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrenciesGroupByOutputType[P]>
            : GetScalarType<T[P], CurrenciesGroupByOutputType[P]>
        }
      >
    >


  export type currenciesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    exchange_rate?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["currencies"]>

  export type currenciesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    exchange_rate?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["currencies"]>

  export type currenciesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    exchange_rate?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["currencies"]>

  export type currenciesSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    exchange_rate?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type currenciesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "exchange_rate" | "is_default" | "created_at" | "updated_at", ExtArgs["result"]["currencies"]>

  export type $currenciesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "currencies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string
      name: string
      exchange_rate: Prisma.Decimal
      is_default: boolean
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["currencies"]>
    composites: {}
  }

  type currenciesGetPayload<S extends boolean | null | undefined | currenciesDefaultArgs> = $Result.GetResult<Prisma.$currenciesPayload, S>

  type currenciesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<currenciesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrenciesCountAggregateInputType | true
    }

  export interface currenciesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['currencies'], meta: { name: 'currencies' } }
    /**
     * Find zero or one Currencies that matches the filter.
     * @param {currenciesFindUniqueArgs} args - Arguments to find a Currencies
     * @example
     * // Get one Currencies
     * const currencies = await prisma.currencies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends currenciesFindUniqueArgs>(args: SelectSubset<T, currenciesFindUniqueArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currencies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {currenciesFindUniqueOrThrowArgs} args - Arguments to find a Currencies
     * @example
     * // Get one Currencies
     * const currencies = await prisma.currencies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends currenciesFindUniqueOrThrowArgs>(args: SelectSubset<T, currenciesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currenciesFindFirstArgs} args - Arguments to find a Currencies
     * @example
     * // Get one Currencies
     * const currencies = await prisma.currencies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends currenciesFindFirstArgs>(args?: SelectSubset<T, currenciesFindFirstArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currencies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currenciesFindFirstOrThrowArgs} args - Arguments to find a Currencies
     * @example
     * // Get one Currencies
     * const currencies = await prisma.currencies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends currenciesFindFirstOrThrowArgs>(args?: SelectSubset<T, currenciesFindFirstOrThrowArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currenciesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currencies.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currencies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currenciesWithIdOnly = await prisma.currencies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends currenciesFindManyArgs>(args?: SelectSubset<T, currenciesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currencies.
     * @param {currenciesCreateArgs} args - Arguments to create a Currencies.
     * @example
     * // Create one Currencies
     * const Currencies = await prisma.currencies.create({
     *   data: {
     *     // ... data to create a Currencies
     *   }
     * })
     * 
     */
    create<T extends currenciesCreateArgs>(args: SelectSubset<T, currenciesCreateArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {currenciesCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currencies = await prisma.currencies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends currenciesCreateManyArgs>(args?: SelectSubset<T, currenciesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {currenciesCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currencies = await prisma.currencies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currenciesWithIdOnly = await prisma.currencies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends currenciesCreateManyAndReturnArgs>(args?: SelectSubset<T, currenciesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currencies.
     * @param {currenciesDeleteArgs} args - Arguments to delete one Currencies.
     * @example
     * // Delete one Currencies
     * const Currencies = await prisma.currencies.delete({
     *   where: {
     *     // ... filter to delete one Currencies
     *   }
     * })
     * 
     */
    delete<T extends currenciesDeleteArgs>(args: SelectSubset<T, currenciesDeleteArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currencies.
     * @param {currenciesUpdateArgs} args - Arguments to update one Currencies.
     * @example
     * // Update one Currencies
     * const currencies = await prisma.currencies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends currenciesUpdateArgs>(args: SelectSubset<T, currenciesUpdateArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {currenciesDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currencies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends currenciesDeleteManyArgs>(args?: SelectSubset<T, currenciesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currenciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currencies = await prisma.currencies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends currenciesUpdateManyArgs>(args: SelectSubset<T, currenciesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {currenciesUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currencies = await prisma.currencies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currenciesWithIdOnly = await prisma.currencies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends currenciesUpdateManyAndReturnArgs>(args: SelectSubset<T, currenciesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currencies.
     * @param {currenciesUpsertArgs} args - Arguments to update or create a Currencies.
     * @example
     * // Update or create a Currencies
     * const currencies = await prisma.currencies.upsert({
     *   create: {
     *     // ... data to create a Currencies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currencies we want to update
     *   }
     * })
     */
    upsert<T extends currenciesUpsertArgs>(args: SelectSubset<T, currenciesUpsertArgs<ExtArgs>>): Prisma__currenciesClient<$Result.GetResult<Prisma.$currenciesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currenciesCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currencies.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends currenciesCountArgs>(
      args?: Subset<T, currenciesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrenciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrenciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrenciesAggregateArgs>(args: Subset<T, CurrenciesAggregateArgs>): Prisma.PrismaPromise<GetCurrenciesAggregateType<T>>

    /**
     * Group by Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currenciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends currenciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: currenciesGroupByArgs['orderBy'] }
        : { orderBy?: currenciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, currenciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrenciesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the currencies model
   */
  readonly fields: currenciesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for currencies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__currenciesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the currencies model
   */
  interface currenciesFieldRefs {
    readonly id: FieldRef<"currencies", 'BigInt'>
    readonly code: FieldRef<"currencies", 'String'>
    readonly name: FieldRef<"currencies", 'String'>
    readonly exchange_rate: FieldRef<"currencies", 'Decimal'>
    readonly is_default: FieldRef<"currencies", 'Boolean'>
    readonly created_at: FieldRef<"currencies", 'String'>
    readonly updated_at: FieldRef<"currencies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * currencies findUnique
   */
  export type currenciesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * Filter, which currencies to fetch.
     */
    where: currenciesWhereUniqueInput
  }

  /**
   * currencies findUniqueOrThrow
   */
  export type currenciesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * Filter, which currencies to fetch.
     */
    where: currenciesWhereUniqueInput
  }

  /**
   * currencies findFirst
   */
  export type currenciesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * Filter, which currencies to fetch.
     */
    where?: currenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currenciesOrderByWithRelationInput | currenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for currencies.
     */
    cursor?: currenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of currencies.
     */
    distinct?: CurrenciesScalarFieldEnum | CurrenciesScalarFieldEnum[]
  }

  /**
   * currencies findFirstOrThrow
   */
  export type currenciesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * Filter, which currencies to fetch.
     */
    where?: currenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currenciesOrderByWithRelationInput | currenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for currencies.
     */
    cursor?: currenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of currencies.
     */
    distinct?: CurrenciesScalarFieldEnum | CurrenciesScalarFieldEnum[]
  }

  /**
   * currencies findMany
   */
  export type currenciesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * Filter, which currencies to fetch.
     */
    where?: currenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currenciesOrderByWithRelationInput | currenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing currencies.
     */
    cursor?: currenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    distinct?: CurrenciesScalarFieldEnum | CurrenciesScalarFieldEnum[]
  }

  /**
   * currencies create
   */
  export type currenciesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * The data needed to create a currencies.
     */
    data: XOR<currenciesCreateInput, currenciesUncheckedCreateInput>
  }

  /**
   * currencies createMany
   */
  export type currenciesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many currencies.
     */
    data: currenciesCreateManyInput | currenciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * currencies createManyAndReturn
   */
  export type currenciesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * The data used to create many currencies.
     */
    data: currenciesCreateManyInput | currenciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * currencies update
   */
  export type currenciesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * The data needed to update a currencies.
     */
    data: XOR<currenciesUpdateInput, currenciesUncheckedUpdateInput>
    /**
     * Choose, which currencies to update.
     */
    where: currenciesWhereUniqueInput
  }

  /**
   * currencies updateMany
   */
  export type currenciesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update currencies.
     */
    data: XOR<currenciesUpdateManyMutationInput, currenciesUncheckedUpdateManyInput>
    /**
     * Filter which currencies to update
     */
    where?: currenciesWhereInput
    /**
     * Limit how many currencies to update.
     */
    limit?: number
  }

  /**
   * currencies updateManyAndReturn
   */
  export type currenciesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * The data used to update currencies.
     */
    data: XOR<currenciesUpdateManyMutationInput, currenciesUncheckedUpdateManyInput>
    /**
     * Filter which currencies to update
     */
    where?: currenciesWhereInput
    /**
     * Limit how many currencies to update.
     */
    limit?: number
  }

  /**
   * currencies upsert
   */
  export type currenciesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * The filter to search for the currencies to update in case it exists.
     */
    where: currenciesWhereUniqueInput
    /**
     * In case the currencies found by the `where` argument doesn't exist, create a new currencies with this data.
     */
    create: XOR<currenciesCreateInput, currenciesUncheckedCreateInput>
    /**
     * In case the currencies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<currenciesUpdateInput, currenciesUncheckedUpdateInput>
  }

  /**
   * currencies delete
   */
  export type currenciesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
    /**
     * Filter which currencies to delete.
     */
    where: currenciesWhereUniqueInput
  }

  /**
   * currencies deleteMany
   */
  export type currenciesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which currencies to delete
     */
    where?: currenciesWhereInput
    /**
     * Limit how many currencies to delete.
     */
    limit?: number
  }

  /**
   * currencies without action
   */
  export type currenciesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currencies
     */
    select?: currenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the currencies
     */
    omit?: currenciesOmit<ExtArgs> | null
  }


  /**
   * Model user_role_assignments
   */

  export type AggregateUser_role_assignments = {
    _count: User_role_assignmentsCountAggregateOutputType | null
    _avg: User_role_assignmentsAvgAggregateOutputType | null
    _sum: User_role_assignmentsSumAggregateOutputType | null
    _min: User_role_assignmentsMinAggregateOutputType | null
    _max: User_role_assignmentsMaxAggregateOutputType | null
  }

  export type User_role_assignmentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    profile_id: number | null
  }

  export type User_role_assignmentsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    profile_id: bigint | null
  }

  export type User_role_assignmentsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    profile_id: bigint | null
    assigned_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type User_role_assignmentsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    profile_id: bigint | null
    assigned_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type User_role_assignmentsCountAggregateOutputType = {
    id: number
    user_id: number
    profile_id: number
    assigned_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_role_assignmentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
  }

  export type User_role_assignmentsSumAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
  }

  export type User_role_assignmentsMinAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
  }

  export type User_role_assignmentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
  }

  export type User_role_assignmentsCountAggregateInputType = {
    id?: true
    user_id?: true
    profile_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_role_assignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_role_assignments to aggregate.
     */
    where?: user_role_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_role_assignments to fetch.
     */
    orderBy?: user_role_assignmentsOrderByWithRelationInput | user_role_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_role_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_role_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_role_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_role_assignments
    **/
    _count?: true | User_role_assignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_role_assignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_role_assignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_role_assignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_role_assignmentsMaxAggregateInputType
  }

  export type GetUser_role_assignmentsAggregateType<T extends User_role_assignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_role_assignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_role_assignments[P]>
      : GetScalarType<T[P], AggregateUser_role_assignments[P]>
  }




  export type user_role_assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_role_assignmentsWhereInput
    orderBy?: user_role_assignmentsOrderByWithAggregationInput | user_role_assignmentsOrderByWithAggregationInput[]
    by: User_role_assignmentsScalarFieldEnum[] | User_role_assignmentsScalarFieldEnum
    having?: user_role_assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_role_assignmentsCountAggregateInputType | true
    _avg?: User_role_assignmentsAvgAggregateInputType
    _sum?: User_role_assignmentsSumAggregateInputType
    _min?: User_role_assignmentsMinAggregateInputType
    _max?: User_role_assignmentsMaxAggregateInputType
  }

  export type User_role_assignmentsGroupByOutputType = {
    id: bigint
    user_id: bigint
    profile_id: bigint
    assigned_at: string
    created_at: string
    updated_at: string
    _count: User_role_assignmentsCountAggregateOutputType | null
    _avg: User_role_assignmentsAvgAggregateOutputType | null
    _sum: User_role_assignmentsSumAggregateOutputType | null
    _min: User_role_assignmentsMinAggregateOutputType | null
    _max: User_role_assignmentsMaxAggregateOutputType | null
  }

  type GetUser_role_assignmentsGroupByPayload<T extends user_role_assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_role_assignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_role_assignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_role_assignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], User_role_assignmentsGroupByOutputType[P]>
        }
      >
    >


  export type user_role_assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_role_assignments"]>

  export type user_role_assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_role_assignments"]>

  export type user_role_assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user_role_assignments"]>

  export type user_role_assignmentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    profile_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type user_role_assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "profile_id" | "assigned_at" | "created_at" | "updated_at", ExtArgs["result"]["user_role_assignments"]>

  export type $user_role_assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_role_assignments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      profile_id: bigint
      assigned_at: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["user_role_assignments"]>
    composites: {}
  }

  type user_role_assignmentsGetPayload<S extends boolean | null | undefined | user_role_assignmentsDefaultArgs> = $Result.GetResult<Prisma.$user_role_assignmentsPayload, S>

  type user_role_assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_role_assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_role_assignmentsCountAggregateInputType | true
    }

  export interface user_role_assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_role_assignments'], meta: { name: 'user_role_assignments' } }
    /**
     * Find zero or one User_role_assignments that matches the filter.
     * @param {user_role_assignmentsFindUniqueArgs} args - Arguments to find a User_role_assignments
     * @example
     * // Get one User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_role_assignmentsFindUniqueArgs>(args: SelectSubset<T, user_role_assignmentsFindUniqueArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_role_assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_role_assignmentsFindUniqueOrThrowArgs} args - Arguments to find a User_role_assignments
     * @example
     * // Get one User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_role_assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_role_assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_role_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_role_assignmentsFindFirstArgs} args - Arguments to find a User_role_assignments
     * @example
     * // Get one User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_role_assignmentsFindFirstArgs>(args?: SelectSubset<T, user_role_assignmentsFindFirstArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_role_assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_role_assignmentsFindFirstOrThrowArgs} args - Arguments to find a User_role_assignments
     * @example
     * // Get one User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_role_assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_role_assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_role_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_role_assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.findMany()
     * 
     * // Get first 10 User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_role_assignmentsWithIdOnly = await prisma.user_role_assignments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_role_assignmentsFindManyArgs>(args?: SelectSubset<T, user_role_assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_role_assignments.
     * @param {user_role_assignmentsCreateArgs} args - Arguments to create a User_role_assignments.
     * @example
     * // Create one User_role_assignments
     * const User_role_assignments = await prisma.user_role_assignments.create({
     *   data: {
     *     // ... data to create a User_role_assignments
     *   }
     * })
     * 
     */
    create<T extends user_role_assignmentsCreateArgs>(args: SelectSubset<T, user_role_assignmentsCreateArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_role_assignments.
     * @param {user_role_assignmentsCreateManyArgs} args - Arguments to create many User_role_assignments.
     * @example
     * // Create many User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_role_assignmentsCreateManyArgs>(args?: SelectSubset<T, user_role_assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_role_assignments and returns the data saved in the database.
     * @param {user_role_assignmentsCreateManyAndReturnArgs} args - Arguments to create many User_role_assignments.
     * @example
     * // Create many User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_role_assignments and only return the `id`
     * const user_role_assignmentsWithIdOnly = await prisma.user_role_assignments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_role_assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_role_assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_role_assignments.
     * @param {user_role_assignmentsDeleteArgs} args - Arguments to delete one User_role_assignments.
     * @example
     * // Delete one User_role_assignments
     * const User_role_assignments = await prisma.user_role_assignments.delete({
     *   where: {
     *     // ... filter to delete one User_role_assignments
     *   }
     * })
     * 
     */
    delete<T extends user_role_assignmentsDeleteArgs>(args: SelectSubset<T, user_role_assignmentsDeleteArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_role_assignments.
     * @param {user_role_assignmentsUpdateArgs} args - Arguments to update one User_role_assignments.
     * @example
     * // Update one User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_role_assignmentsUpdateArgs>(args: SelectSubset<T, user_role_assignmentsUpdateArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_role_assignments.
     * @param {user_role_assignmentsDeleteManyArgs} args - Arguments to filter User_role_assignments to delete.
     * @example
     * // Delete a few User_role_assignments
     * const { count } = await prisma.user_role_assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_role_assignmentsDeleteManyArgs>(args?: SelectSubset<T, user_role_assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_role_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_role_assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_role_assignmentsUpdateManyArgs>(args: SelectSubset<T, user_role_assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_role_assignments and returns the data updated in the database.
     * @param {user_role_assignmentsUpdateManyAndReturnArgs} args - Arguments to update many User_role_assignments.
     * @example
     * // Update many User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_role_assignments and only return the `id`
     * const user_role_assignmentsWithIdOnly = await prisma.user_role_assignments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_role_assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_role_assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_role_assignments.
     * @param {user_role_assignmentsUpsertArgs} args - Arguments to update or create a User_role_assignments.
     * @example
     * // Update or create a User_role_assignments
     * const user_role_assignments = await prisma.user_role_assignments.upsert({
     *   create: {
     *     // ... data to create a User_role_assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_role_assignments we want to update
     *   }
     * })
     */
    upsert<T extends user_role_assignmentsUpsertArgs>(args: SelectSubset<T, user_role_assignmentsUpsertArgs<ExtArgs>>): Prisma__user_role_assignmentsClient<$Result.GetResult<Prisma.$user_role_assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_role_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_role_assignmentsCountArgs} args - Arguments to filter User_role_assignments to count.
     * @example
     * // Count the number of User_role_assignments
     * const count = await prisma.user_role_assignments.count({
     *   where: {
     *     // ... the filter for the User_role_assignments we want to count
     *   }
     * })
    **/
    count<T extends user_role_assignmentsCountArgs>(
      args?: Subset<T, user_role_assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_role_assignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_role_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_role_assignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_role_assignmentsAggregateArgs>(args: Subset<T, User_role_assignmentsAggregateArgs>): Prisma.PrismaPromise<GetUser_role_assignmentsAggregateType<T>>

    /**
     * Group by User_role_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_role_assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_role_assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_role_assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: user_role_assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_role_assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_role_assignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_role_assignments model
   */
  readonly fields: user_role_assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_role_assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_role_assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_role_assignments model
   */
  interface user_role_assignmentsFieldRefs {
    readonly id: FieldRef<"user_role_assignments", 'BigInt'>
    readonly user_id: FieldRef<"user_role_assignments", 'BigInt'>
    readonly profile_id: FieldRef<"user_role_assignments", 'BigInt'>
    readonly assigned_at: FieldRef<"user_role_assignments", 'String'>
    readonly created_at: FieldRef<"user_role_assignments", 'String'>
    readonly updated_at: FieldRef<"user_role_assignments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_role_assignments findUnique
   */
  export type user_role_assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * Filter, which user_role_assignments to fetch.
     */
    where: user_role_assignmentsWhereUniqueInput
  }

  /**
   * user_role_assignments findUniqueOrThrow
   */
  export type user_role_assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * Filter, which user_role_assignments to fetch.
     */
    where: user_role_assignmentsWhereUniqueInput
  }

  /**
   * user_role_assignments findFirst
   */
  export type user_role_assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * Filter, which user_role_assignments to fetch.
     */
    where?: user_role_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_role_assignments to fetch.
     */
    orderBy?: user_role_assignmentsOrderByWithRelationInput | user_role_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_role_assignments.
     */
    cursor?: user_role_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_role_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_role_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_role_assignments.
     */
    distinct?: User_role_assignmentsScalarFieldEnum | User_role_assignmentsScalarFieldEnum[]
  }

  /**
   * user_role_assignments findFirstOrThrow
   */
  export type user_role_assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * Filter, which user_role_assignments to fetch.
     */
    where?: user_role_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_role_assignments to fetch.
     */
    orderBy?: user_role_assignmentsOrderByWithRelationInput | user_role_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_role_assignments.
     */
    cursor?: user_role_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_role_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_role_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_role_assignments.
     */
    distinct?: User_role_assignmentsScalarFieldEnum | User_role_assignmentsScalarFieldEnum[]
  }

  /**
   * user_role_assignments findMany
   */
  export type user_role_assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * Filter, which user_role_assignments to fetch.
     */
    where?: user_role_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_role_assignments to fetch.
     */
    orderBy?: user_role_assignmentsOrderByWithRelationInput | user_role_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_role_assignments.
     */
    cursor?: user_role_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_role_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_role_assignments.
     */
    skip?: number
    distinct?: User_role_assignmentsScalarFieldEnum | User_role_assignmentsScalarFieldEnum[]
  }

  /**
   * user_role_assignments create
   */
  export type user_role_assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * The data needed to create a user_role_assignments.
     */
    data: XOR<user_role_assignmentsCreateInput, user_role_assignmentsUncheckedCreateInput>
  }

  /**
   * user_role_assignments createMany
   */
  export type user_role_assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_role_assignments.
     */
    data: user_role_assignmentsCreateManyInput | user_role_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_role_assignments createManyAndReturn
   */
  export type user_role_assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many user_role_assignments.
     */
    data: user_role_assignmentsCreateManyInput | user_role_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_role_assignments update
   */
  export type user_role_assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * The data needed to update a user_role_assignments.
     */
    data: XOR<user_role_assignmentsUpdateInput, user_role_assignmentsUncheckedUpdateInput>
    /**
     * Choose, which user_role_assignments to update.
     */
    where: user_role_assignmentsWhereUniqueInput
  }

  /**
   * user_role_assignments updateMany
   */
  export type user_role_assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_role_assignments.
     */
    data: XOR<user_role_assignmentsUpdateManyMutationInput, user_role_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which user_role_assignments to update
     */
    where?: user_role_assignmentsWhereInput
    /**
     * Limit how many user_role_assignments to update.
     */
    limit?: number
  }

  /**
   * user_role_assignments updateManyAndReturn
   */
  export type user_role_assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update user_role_assignments.
     */
    data: XOR<user_role_assignmentsUpdateManyMutationInput, user_role_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which user_role_assignments to update
     */
    where?: user_role_assignmentsWhereInput
    /**
     * Limit how many user_role_assignments to update.
     */
    limit?: number
  }

  /**
   * user_role_assignments upsert
   */
  export type user_role_assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * The filter to search for the user_role_assignments to update in case it exists.
     */
    where: user_role_assignmentsWhereUniqueInput
    /**
     * In case the user_role_assignments found by the `where` argument doesn't exist, create a new user_role_assignments with this data.
     */
    create: XOR<user_role_assignmentsCreateInput, user_role_assignmentsUncheckedCreateInput>
    /**
     * In case the user_role_assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_role_assignmentsUpdateInput, user_role_assignmentsUncheckedUpdateInput>
  }

  /**
   * user_role_assignments delete
   */
  export type user_role_assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
    /**
     * Filter which user_role_assignments to delete.
     */
    where: user_role_assignmentsWhereUniqueInput
  }

  /**
   * user_role_assignments deleteMany
   */
  export type user_role_assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_role_assignments to delete
     */
    where?: user_role_assignmentsWhereInput
    /**
     * Limit how many user_role_assignments to delete.
     */
    limit?: number
  }

  /**
   * user_role_assignments without action
   */
  export type user_role_assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_role_assignments
     */
    select?: user_role_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_role_assignments
     */
    omit?: user_role_assignmentsOmit<ExtArgs> | null
  }


  /**
   * Model skills
   */

  export type AggregateSkills = {
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  export type SkillsAvgAggregateOutputType = {
    id: number | null
  }

  export type SkillsSumAggregateOutputType = {
    id: bigint | null
  }

  export type SkillsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type SkillsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type SkillsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SkillsAvgAggregateInputType = {
    id?: true
  }

  export type SkillsSumAggregateInputType = {
    id?: true
  }

  export type SkillsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type SkillsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type SkillsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to aggregate.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skills
    **/
    _count?: true | SkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillsMaxAggregateInputType
  }

  export type GetSkillsAggregateType<T extends SkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkills[P]>
      : GetScalarType<T[P], AggregateSkills[P]>
  }




  export type skillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillsWhereInput
    orderBy?: skillsOrderByWithAggregationInput | skillsOrderByWithAggregationInput[]
    by: SkillsScalarFieldEnum[] | SkillsScalarFieldEnum
    having?: skillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillsCountAggregateInputType | true
    _avg?: SkillsAvgAggregateInputType
    _sum?: SkillsSumAggregateInputType
    _min?: SkillsMinAggregateInputType
    _max?: SkillsMaxAggregateInputType
  }

  export type SkillsGroupByOutputType = {
    id: bigint
    name: string
    description: string
    created_at: string
    updated_at: string
    _count: SkillsCountAggregateOutputType | null
    _avg: SkillsAvgAggregateOutputType | null
    _sum: SkillsSumAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  type GetSkillsGroupByPayload<T extends skillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillsGroupByOutputType[P]>
            : GetScalarType<T[P], SkillsGroupByOutputType[P]>
        }
      >
    >


  export type skillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_skills?: boolean | skills$user_skillsArgs<ExtArgs>
    _count?: boolean | SkillsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type skillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "created_at" | "updated_at", ExtArgs["result"]["skills"]>
  export type skillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_skills?: boolean | skills$user_skillsArgs<ExtArgs>
    _count?: boolean | SkillsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type skillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type skillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $skillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skills"
    objects: {
      user_skills: Prisma.$user_skillsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      description: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["skills"]>
    composites: {}
  }

  type skillsGetPayload<S extends boolean | null | undefined | skillsDefaultArgs> = $Result.GetResult<Prisma.$skillsPayload, S>

  type skillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<skillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillsCountAggregateInputType | true
    }

  export interface skillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skills'], meta: { name: 'skills' } }
    /**
     * Find zero or one Skills that matches the filter.
     * @param {skillsFindUniqueArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skillsFindUniqueArgs>(args: SelectSubset<T, skillsFindUniqueArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {skillsFindUniqueOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skillsFindUniqueOrThrowArgs>(args: SelectSubset<T, skillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skillsFindFirstArgs>(args?: SelectSubset<T, skillsFindFirstArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skillsFindFirstOrThrowArgs>(args?: SelectSubset<T, skillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skills.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillsWithIdOnly = await prisma.skills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skillsFindManyArgs>(args?: SelectSubset<T, skillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skills.
     * @param {skillsCreateArgs} args - Arguments to create a Skills.
     * @example
     * // Create one Skills
     * const Skills = await prisma.skills.create({
     *   data: {
     *     // ... data to create a Skills
     *   }
     * })
     * 
     */
    create<T extends skillsCreateArgs>(args: SelectSubset<T, skillsCreateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {skillsCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skillsCreateManyArgs>(args?: SelectSubset<T, skillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {skillsCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillsWithIdOnly = await prisma.skills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends skillsCreateManyAndReturnArgs>(args?: SelectSubset<T, skillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skills.
     * @param {skillsDeleteArgs} args - Arguments to delete one Skills.
     * @example
     * // Delete one Skills
     * const Skills = await prisma.skills.delete({
     *   where: {
     *     // ... filter to delete one Skills
     *   }
     * })
     * 
     */
    delete<T extends skillsDeleteArgs>(args: SelectSubset<T, skillsDeleteArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skills.
     * @param {skillsUpdateArgs} args - Arguments to update one Skills.
     * @example
     * // Update one Skills
     * const skills = await prisma.skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skillsUpdateArgs>(args: SelectSubset<T, skillsUpdateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {skillsDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skillsDeleteManyArgs>(args?: SelectSubset<T, skillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skillsUpdateManyArgs>(args: SelectSubset<T, skillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {skillsUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillsWithIdOnly = await prisma.skills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends skillsUpdateManyAndReturnArgs>(args: SelectSubset<T, skillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skills.
     * @param {skillsUpsertArgs} args - Arguments to update or create a Skills.
     * @example
     * // Update or create a Skills
     * const skills = await prisma.skills.upsert({
     *   create: {
     *     // ... data to create a Skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skills we want to update
     *   }
     * })
     */
    upsert<T extends skillsUpsertArgs>(args: SelectSubset<T, skillsUpsertArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skills.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends skillsCountArgs>(
      args?: Subset<T, skillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillsAggregateArgs>(args: Subset<T, SkillsAggregateArgs>): Prisma.PrismaPromise<GetSkillsAggregateType<T>>

    /**
     * Group by Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skillsGroupByArgs['orderBy'] }
        : { orderBy?: skillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skills model
   */
  readonly fields: skillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_skills<T extends skills$user_skillsArgs<ExtArgs> = {}>(args?: Subset<T, skills$user_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skills model
   */
  interface skillsFieldRefs {
    readonly id: FieldRef<"skills", 'BigInt'>
    readonly name: FieldRef<"skills", 'String'>
    readonly description: FieldRef<"skills", 'String'>
    readonly created_at: FieldRef<"skills", 'String'>
    readonly updated_at: FieldRef<"skills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * skills findUnique
   */
  export type skillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findUniqueOrThrow
   */
  export type skillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findFirst
   */
  export type skillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findFirstOrThrow
   */
  export type skillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findMany
   */
  export type skillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills create
   */
  export type skillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The data needed to create a skills.
     */
    data: XOR<skillsCreateInput, skillsUncheckedCreateInput>
  }

  /**
   * skills createMany
   */
  export type skillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skills.
     */
    data: skillsCreateManyInput | skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skills createManyAndReturn
   */
  export type skillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * The data used to create many skills.
     */
    data: skillsCreateManyInput | skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skills update
   */
  export type skillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The data needed to update a skills.
     */
    data: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
    /**
     * Choose, which skills to update.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills updateMany
   */
  export type skillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skills.
     */
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
  }

  /**
   * skills updateManyAndReturn
   */
  export type skillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * The data used to update skills.
     */
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
  }

  /**
   * skills upsert
   */
  export type skillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The filter to search for the skills to update in case it exists.
     */
    where: skillsWhereUniqueInput
    /**
     * In case the skills found by the `where` argument doesn't exist, create a new skills with this data.
     */
    create: XOR<skillsCreateInput, skillsUncheckedCreateInput>
    /**
     * In case the skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
  }

  /**
   * skills delete
   */
  export type skillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter which skills to delete.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills deleteMany
   */
  export type skillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to delete
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to delete.
     */
    limit?: number
  }

  /**
   * skills.user_skills
   */
  export type skills$user_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    where?: user_skillsWhereInput
    orderBy?: user_skillsOrderByWithRelationInput | user_skillsOrderByWithRelationInput[]
    cursor?: user_skillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_skillsScalarFieldEnum | User_skillsScalarFieldEnum[]
  }

  /**
   * skills without action
   */
  export type skillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
  }


  /**
   * Model user_skills
   */

  export type AggregateUser_skills = {
    _count: User_skillsCountAggregateOutputType | null
    _avg: User_skillsAvgAggregateOutputType | null
    _sum: User_skillsSumAggregateOutputType | null
    _min: User_skillsMinAggregateOutputType | null
    _max: User_skillsMaxAggregateOutputType | null
  }

  export type User_skillsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    skill_id: number | null
    organization_id: number | null
  }

  export type User_skillsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    skill_id: bigint | null
    organization_id: bigint | null
  }

  export type User_skillsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    skill_id: bigint | null
    organization_id: bigint | null
    proficiency_level: $Enums.ProficiencyLevel | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_skillsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    skill_id: bigint | null
    organization_id: bigint | null
    proficiency_level: $Enums.ProficiencyLevel | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_skillsCountAggregateOutputType = {
    id: number
    user_id: number
    skill_id: number
    organization_id: number
    proficiency_level: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_skillsAvgAggregateInputType = {
    id?: true
    user_id?: true
    skill_id?: true
    organization_id?: true
  }

  export type User_skillsSumAggregateInputType = {
    id?: true
    user_id?: true
    skill_id?: true
    organization_id?: true
  }

  export type User_skillsMinAggregateInputType = {
    id?: true
    user_id?: true
    skill_id?: true
    organization_id?: true
    proficiency_level?: true
    created_at?: true
    updated_at?: true
  }

  export type User_skillsMaxAggregateInputType = {
    id?: true
    user_id?: true
    skill_id?: true
    organization_id?: true
    proficiency_level?: true
    created_at?: true
    updated_at?: true
  }

  export type User_skillsCountAggregateInputType = {
    id?: true
    user_id?: true
    skill_id?: true
    organization_id?: true
    proficiency_level?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_skillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_skills to aggregate.
     */
    where?: user_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_skills to fetch.
     */
    orderBy?: user_skillsOrderByWithRelationInput | user_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_skills
    **/
    _count?: true | User_skillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_skillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_skillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_skillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_skillsMaxAggregateInputType
  }

  export type GetUser_skillsAggregateType<T extends User_skillsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_skills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_skills[P]>
      : GetScalarType<T[P], AggregateUser_skills[P]>
  }




  export type user_skillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_skillsWhereInput
    orderBy?: user_skillsOrderByWithAggregationInput | user_skillsOrderByWithAggregationInput[]
    by: User_skillsScalarFieldEnum[] | User_skillsScalarFieldEnum
    having?: user_skillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_skillsCountAggregateInputType | true
    _avg?: User_skillsAvgAggregateInputType
    _sum?: User_skillsSumAggregateInputType
    _min?: User_skillsMinAggregateInputType
    _max?: User_skillsMaxAggregateInputType
  }

  export type User_skillsGroupByOutputType = {
    id: bigint
    user_id: bigint
    skill_id: bigint
    organization_id: bigint
    proficiency_level: $Enums.ProficiencyLevel
    created_at: Date
    updated_at: Date
    _count: User_skillsCountAggregateOutputType | null
    _avg: User_skillsAvgAggregateOutputType | null
    _sum: User_skillsSumAggregateOutputType | null
    _min: User_skillsMinAggregateOutputType | null
    _max: User_skillsMaxAggregateOutputType | null
  }

  type GetUser_skillsGroupByPayload<T extends user_skillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_skillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_skillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_skillsGroupByOutputType[P]>
            : GetScalarType<T[P], User_skillsGroupByOutputType[P]>
        }
      >
    >


  export type user_skillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    skill_id?: boolean
    organization_id?: boolean
    proficiency_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_skills"]>

  export type user_skillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    skill_id?: boolean
    organization_id?: boolean
    proficiency_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_skills"]>

  export type user_skillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    skill_id?: boolean
    organization_id?: boolean
    proficiency_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_skills"]>

  export type user_skillsSelectScalar = {
    id?: boolean
    user_id?: boolean
    skill_id?: boolean
    organization_id?: boolean
    proficiency_level?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type user_skillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "skill_id" | "organization_id" | "proficiency_level" | "created_at" | "updated_at", ExtArgs["result"]["user_skills"]>
  export type user_skillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type user_skillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type user_skillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $user_skillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_skills"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      skills: Prisma.$skillsPayload<ExtArgs>
      organizations: Prisma.$organizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      skill_id: bigint
      organization_id: bigint
      proficiency_level: $Enums.ProficiencyLevel
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user_skills"]>
    composites: {}
  }

  type user_skillsGetPayload<S extends boolean | null | undefined | user_skillsDefaultArgs> = $Result.GetResult<Prisma.$user_skillsPayload, S>

  type user_skillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_skillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_skillsCountAggregateInputType | true
    }

  export interface user_skillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_skills'], meta: { name: 'user_skills' } }
    /**
     * Find zero or one User_skills that matches the filter.
     * @param {user_skillsFindUniqueArgs} args - Arguments to find a User_skills
     * @example
     * // Get one User_skills
     * const user_skills = await prisma.user_skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_skillsFindUniqueArgs>(args: SelectSubset<T, user_skillsFindUniqueArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_skills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_skillsFindUniqueOrThrowArgs} args - Arguments to find a User_skills
     * @example
     * // Get one User_skills
     * const user_skills = await prisma.user_skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_skillsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_skillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_skillsFindFirstArgs} args - Arguments to find a User_skills
     * @example
     * // Get one User_skills
     * const user_skills = await prisma.user_skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_skillsFindFirstArgs>(args?: SelectSubset<T, user_skillsFindFirstArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_skillsFindFirstOrThrowArgs} args - Arguments to find a User_skills
     * @example
     * // Get one User_skills
     * const user_skills = await prisma.user_skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_skillsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_skillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_skillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_skills
     * const user_skills = await prisma.user_skills.findMany()
     * 
     * // Get first 10 User_skills
     * const user_skills = await prisma.user_skills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_skillsWithIdOnly = await prisma.user_skills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_skillsFindManyArgs>(args?: SelectSubset<T, user_skillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_skills.
     * @param {user_skillsCreateArgs} args - Arguments to create a User_skills.
     * @example
     * // Create one User_skills
     * const User_skills = await prisma.user_skills.create({
     *   data: {
     *     // ... data to create a User_skills
     *   }
     * })
     * 
     */
    create<T extends user_skillsCreateArgs>(args: SelectSubset<T, user_skillsCreateArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_skills.
     * @param {user_skillsCreateManyArgs} args - Arguments to create many User_skills.
     * @example
     * // Create many User_skills
     * const user_skills = await prisma.user_skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_skillsCreateManyArgs>(args?: SelectSubset<T, user_skillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_skills and returns the data saved in the database.
     * @param {user_skillsCreateManyAndReturnArgs} args - Arguments to create many User_skills.
     * @example
     * // Create many User_skills
     * const user_skills = await prisma.user_skills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_skills and only return the `id`
     * const user_skillsWithIdOnly = await prisma.user_skills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_skillsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_skillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_skills.
     * @param {user_skillsDeleteArgs} args - Arguments to delete one User_skills.
     * @example
     * // Delete one User_skills
     * const User_skills = await prisma.user_skills.delete({
     *   where: {
     *     // ... filter to delete one User_skills
     *   }
     * })
     * 
     */
    delete<T extends user_skillsDeleteArgs>(args: SelectSubset<T, user_skillsDeleteArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_skills.
     * @param {user_skillsUpdateArgs} args - Arguments to update one User_skills.
     * @example
     * // Update one User_skills
     * const user_skills = await prisma.user_skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_skillsUpdateArgs>(args: SelectSubset<T, user_skillsUpdateArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_skills.
     * @param {user_skillsDeleteManyArgs} args - Arguments to filter User_skills to delete.
     * @example
     * // Delete a few User_skills
     * const { count } = await prisma.user_skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_skillsDeleteManyArgs>(args?: SelectSubset<T, user_skillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_skillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_skills
     * const user_skills = await prisma.user_skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_skillsUpdateManyArgs>(args: SelectSubset<T, user_skillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_skills and returns the data updated in the database.
     * @param {user_skillsUpdateManyAndReturnArgs} args - Arguments to update many User_skills.
     * @example
     * // Update many User_skills
     * const user_skills = await prisma.user_skills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_skills and only return the `id`
     * const user_skillsWithIdOnly = await prisma.user_skills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_skillsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_skillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_skills.
     * @param {user_skillsUpsertArgs} args - Arguments to update or create a User_skills.
     * @example
     * // Update or create a User_skills
     * const user_skills = await prisma.user_skills.upsert({
     *   create: {
     *     // ... data to create a User_skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_skills we want to update
     *   }
     * })
     */
    upsert<T extends user_skillsUpsertArgs>(args: SelectSubset<T, user_skillsUpsertArgs<ExtArgs>>): Prisma__user_skillsClient<$Result.GetResult<Prisma.$user_skillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_skillsCountArgs} args - Arguments to filter User_skills to count.
     * @example
     * // Count the number of User_skills
     * const count = await prisma.user_skills.count({
     *   where: {
     *     // ... the filter for the User_skills we want to count
     *   }
     * })
    **/
    count<T extends user_skillsCountArgs>(
      args?: Subset<T, user_skillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_skillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_skillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_skillsAggregateArgs>(args: Subset<T, User_skillsAggregateArgs>): Prisma.PrismaPromise<GetUser_skillsAggregateType<T>>

    /**
     * Group by User_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_skillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_skillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_skillsGroupByArgs['orderBy'] }
        : { orderBy?: user_skillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_skillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_skillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_skills model
   */
  readonly fields: user_skillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_skillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skills<T extends skillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, skillsDefaultArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_skills model
   */
  interface user_skillsFieldRefs {
    readonly id: FieldRef<"user_skills", 'BigInt'>
    readonly user_id: FieldRef<"user_skills", 'BigInt'>
    readonly skill_id: FieldRef<"user_skills", 'BigInt'>
    readonly organization_id: FieldRef<"user_skills", 'BigInt'>
    readonly proficiency_level: FieldRef<"user_skills", 'ProficiencyLevel'>
    readonly created_at: FieldRef<"user_skills", 'DateTime'>
    readonly updated_at: FieldRef<"user_skills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_skills findUnique
   */
  export type user_skillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * Filter, which user_skills to fetch.
     */
    where: user_skillsWhereUniqueInput
  }

  /**
   * user_skills findUniqueOrThrow
   */
  export type user_skillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * Filter, which user_skills to fetch.
     */
    where: user_skillsWhereUniqueInput
  }

  /**
   * user_skills findFirst
   */
  export type user_skillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * Filter, which user_skills to fetch.
     */
    where?: user_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_skills to fetch.
     */
    orderBy?: user_skillsOrderByWithRelationInput | user_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_skills.
     */
    cursor?: user_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_skills.
     */
    distinct?: User_skillsScalarFieldEnum | User_skillsScalarFieldEnum[]
  }

  /**
   * user_skills findFirstOrThrow
   */
  export type user_skillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * Filter, which user_skills to fetch.
     */
    where?: user_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_skills to fetch.
     */
    orderBy?: user_skillsOrderByWithRelationInput | user_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_skills.
     */
    cursor?: user_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_skills.
     */
    distinct?: User_skillsScalarFieldEnum | User_skillsScalarFieldEnum[]
  }

  /**
   * user_skills findMany
   */
  export type user_skillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * Filter, which user_skills to fetch.
     */
    where?: user_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_skills to fetch.
     */
    orderBy?: user_skillsOrderByWithRelationInput | user_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_skills.
     */
    cursor?: user_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_skills.
     */
    skip?: number
    distinct?: User_skillsScalarFieldEnum | User_skillsScalarFieldEnum[]
  }

  /**
   * user_skills create
   */
  export type user_skillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_skills.
     */
    data: XOR<user_skillsCreateInput, user_skillsUncheckedCreateInput>
  }

  /**
   * user_skills createMany
   */
  export type user_skillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_skills.
     */
    data: user_skillsCreateManyInput | user_skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_skills createManyAndReturn
   */
  export type user_skillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * The data used to create many user_skills.
     */
    data: user_skillsCreateManyInput | user_skillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_skills update
   */
  export type user_skillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_skills.
     */
    data: XOR<user_skillsUpdateInput, user_skillsUncheckedUpdateInput>
    /**
     * Choose, which user_skills to update.
     */
    where: user_skillsWhereUniqueInput
  }

  /**
   * user_skills updateMany
   */
  export type user_skillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_skills.
     */
    data: XOR<user_skillsUpdateManyMutationInput, user_skillsUncheckedUpdateManyInput>
    /**
     * Filter which user_skills to update
     */
    where?: user_skillsWhereInput
    /**
     * Limit how many user_skills to update.
     */
    limit?: number
  }

  /**
   * user_skills updateManyAndReturn
   */
  export type user_skillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * The data used to update user_skills.
     */
    data: XOR<user_skillsUpdateManyMutationInput, user_skillsUncheckedUpdateManyInput>
    /**
     * Filter which user_skills to update
     */
    where?: user_skillsWhereInput
    /**
     * Limit how many user_skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_skills upsert
   */
  export type user_skillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_skills to update in case it exists.
     */
    where: user_skillsWhereUniqueInput
    /**
     * In case the user_skills found by the `where` argument doesn't exist, create a new user_skills with this data.
     */
    create: XOR<user_skillsCreateInput, user_skillsUncheckedCreateInput>
    /**
     * In case the user_skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_skillsUpdateInput, user_skillsUncheckedUpdateInput>
  }

  /**
   * user_skills delete
   */
  export type user_skillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
    /**
     * Filter which user_skills to delete.
     */
    where: user_skillsWhereUniqueInput
  }

  /**
   * user_skills deleteMany
   */
  export type user_skillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_skills to delete
     */
    where?: user_skillsWhereInput
    /**
     * Limit how many user_skills to delete.
     */
    limit?: number
  }

  /**
   * user_skills without action
   */
  export type user_skillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_skills
     */
    select?: user_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_skills
     */
    omit?: user_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_skillsInclude<ExtArgs> | null
  }


  /**
   * Model business_hours
   */

  export type AggregateBusiness_hours = {
    _count: Business_hoursCountAggregateOutputType | null
    _avg: Business_hoursAvgAggregateOutputType | null
    _sum: Business_hoursSumAggregateOutputType | null
    _min: Business_hoursMinAggregateOutputType | null
    _max: Business_hoursMaxAggregateOutputType | null
  }

  export type Business_hoursAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type Business_hoursSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
  }

  export type Business_hoursMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    day_of_week: $Enums.DayOfWeek | null
    start_time: string | null
    end_time: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Business_hoursMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    day_of_week: $Enums.DayOfWeek | null
    start_time: string | null
    end_time: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Business_hoursCountAggregateOutputType = {
    id: number
    organization_id: number
    day_of_week: number
    start_time: number
    end_time: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Business_hoursAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type Business_hoursSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type Business_hoursMinAggregateInputType = {
    id?: true
    organization_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
  }

  export type Business_hoursMaxAggregateInputType = {
    id?: true
    organization_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
  }

  export type Business_hoursCountAggregateInputType = {
    id?: true
    organization_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Business_hoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which business_hours to aggregate.
     */
    where?: business_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_hours to fetch.
     */
    orderBy?: business_hoursOrderByWithRelationInput | business_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: business_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned business_hours
    **/
    _count?: true | Business_hoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Business_hoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Business_hoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Business_hoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Business_hoursMaxAggregateInputType
  }

  export type GetBusiness_hoursAggregateType<T extends Business_hoursAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness_hours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness_hours[P]>
      : GetScalarType<T[P], AggregateBusiness_hours[P]>
  }




  export type business_hoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: business_hoursWhereInput
    orderBy?: business_hoursOrderByWithAggregationInput | business_hoursOrderByWithAggregationInput[]
    by: Business_hoursScalarFieldEnum[] | Business_hoursScalarFieldEnum
    having?: business_hoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Business_hoursCountAggregateInputType | true
    _avg?: Business_hoursAvgAggregateInputType
    _sum?: Business_hoursSumAggregateInputType
    _min?: Business_hoursMinAggregateInputType
    _max?: Business_hoursMaxAggregateInputType
  }

  export type Business_hoursGroupByOutputType = {
    id: bigint
    organization_id: bigint
    day_of_week: $Enums.DayOfWeek
    start_time: string
    end_time: string
    created_at: string
    updated_at: string
    _count: Business_hoursCountAggregateOutputType | null
    _avg: Business_hoursAvgAggregateOutputType | null
    _sum: Business_hoursSumAggregateOutputType | null
    _min: Business_hoursMinAggregateOutputType | null
    _max: Business_hoursMaxAggregateOutputType | null
  }

  type GetBusiness_hoursGroupByPayload<T extends business_hoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Business_hoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Business_hoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Business_hoursGroupByOutputType[P]>
            : GetScalarType<T[P], Business_hoursGroupByOutputType[P]>
        }
      >
    >


  export type business_hoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business_hours"]>

  export type business_hoursSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business_hours"]>

  export type business_hoursSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business_hours"]>

  export type business_hoursSelectScalar = {
    id?: boolean
    organization_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type business_hoursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "day_of_week" | "start_time" | "end_time" | "created_at" | "updated_at", ExtArgs["result"]["business_hours"]>
  export type business_hoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type business_hoursIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type business_hoursIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $business_hoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "business_hours"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      day_of_week: $Enums.DayOfWeek
      start_time: string
      end_time: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["business_hours"]>
    composites: {}
  }

  type business_hoursGetPayload<S extends boolean | null | undefined | business_hoursDefaultArgs> = $Result.GetResult<Prisma.$business_hoursPayload, S>

  type business_hoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<business_hoursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Business_hoursCountAggregateInputType | true
    }

  export interface business_hoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['business_hours'], meta: { name: 'business_hours' } }
    /**
     * Find zero or one Business_hours that matches the filter.
     * @param {business_hoursFindUniqueArgs} args - Arguments to find a Business_hours
     * @example
     * // Get one Business_hours
     * const business_hours = await prisma.business_hours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends business_hoursFindUniqueArgs>(args: SelectSubset<T, business_hoursFindUniqueArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Business_hours that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {business_hoursFindUniqueOrThrowArgs} args - Arguments to find a Business_hours
     * @example
     * // Get one Business_hours
     * const business_hours = await prisma.business_hours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends business_hoursFindUniqueOrThrowArgs>(args: SelectSubset<T, business_hoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business_hours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_hoursFindFirstArgs} args - Arguments to find a Business_hours
     * @example
     * // Get one Business_hours
     * const business_hours = await prisma.business_hours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends business_hoursFindFirstArgs>(args?: SelectSubset<T, business_hoursFindFirstArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business_hours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_hoursFindFirstOrThrowArgs} args - Arguments to find a Business_hours
     * @example
     * // Get one Business_hours
     * const business_hours = await prisma.business_hours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends business_hoursFindFirstOrThrowArgs>(args?: SelectSubset<T, business_hoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Business_hours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_hoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Business_hours
     * const business_hours = await prisma.business_hours.findMany()
     * 
     * // Get first 10 Business_hours
     * const business_hours = await prisma.business_hours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const business_hoursWithIdOnly = await prisma.business_hours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends business_hoursFindManyArgs>(args?: SelectSubset<T, business_hoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Business_hours.
     * @param {business_hoursCreateArgs} args - Arguments to create a Business_hours.
     * @example
     * // Create one Business_hours
     * const Business_hours = await prisma.business_hours.create({
     *   data: {
     *     // ... data to create a Business_hours
     *   }
     * })
     * 
     */
    create<T extends business_hoursCreateArgs>(args: SelectSubset<T, business_hoursCreateArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Business_hours.
     * @param {business_hoursCreateManyArgs} args - Arguments to create many Business_hours.
     * @example
     * // Create many Business_hours
     * const business_hours = await prisma.business_hours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends business_hoursCreateManyArgs>(args?: SelectSubset<T, business_hoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Business_hours and returns the data saved in the database.
     * @param {business_hoursCreateManyAndReturnArgs} args - Arguments to create many Business_hours.
     * @example
     * // Create many Business_hours
     * const business_hours = await prisma.business_hours.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Business_hours and only return the `id`
     * const business_hoursWithIdOnly = await prisma.business_hours.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends business_hoursCreateManyAndReturnArgs>(args?: SelectSubset<T, business_hoursCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Business_hours.
     * @param {business_hoursDeleteArgs} args - Arguments to delete one Business_hours.
     * @example
     * // Delete one Business_hours
     * const Business_hours = await prisma.business_hours.delete({
     *   where: {
     *     // ... filter to delete one Business_hours
     *   }
     * })
     * 
     */
    delete<T extends business_hoursDeleteArgs>(args: SelectSubset<T, business_hoursDeleteArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Business_hours.
     * @param {business_hoursUpdateArgs} args - Arguments to update one Business_hours.
     * @example
     * // Update one Business_hours
     * const business_hours = await prisma.business_hours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends business_hoursUpdateArgs>(args: SelectSubset<T, business_hoursUpdateArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Business_hours.
     * @param {business_hoursDeleteManyArgs} args - Arguments to filter Business_hours to delete.
     * @example
     * // Delete a few Business_hours
     * const { count } = await prisma.business_hours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends business_hoursDeleteManyArgs>(args?: SelectSubset<T, business_hoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Business_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_hoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Business_hours
     * const business_hours = await prisma.business_hours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends business_hoursUpdateManyArgs>(args: SelectSubset<T, business_hoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Business_hours and returns the data updated in the database.
     * @param {business_hoursUpdateManyAndReturnArgs} args - Arguments to update many Business_hours.
     * @example
     * // Update many Business_hours
     * const business_hours = await prisma.business_hours.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Business_hours and only return the `id`
     * const business_hoursWithIdOnly = await prisma.business_hours.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends business_hoursUpdateManyAndReturnArgs>(args: SelectSubset<T, business_hoursUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Business_hours.
     * @param {business_hoursUpsertArgs} args - Arguments to update or create a Business_hours.
     * @example
     * // Update or create a Business_hours
     * const business_hours = await prisma.business_hours.upsert({
     *   create: {
     *     // ... data to create a Business_hours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business_hours we want to update
     *   }
     * })
     */
    upsert<T extends business_hoursUpsertArgs>(args: SelectSubset<T, business_hoursUpsertArgs<ExtArgs>>): Prisma__business_hoursClient<$Result.GetResult<Prisma.$business_hoursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Business_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_hoursCountArgs} args - Arguments to filter Business_hours to count.
     * @example
     * // Count the number of Business_hours
     * const count = await prisma.business_hours.count({
     *   where: {
     *     // ... the filter for the Business_hours we want to count
     *   }
     * })
    **/
    count<T extends business_hoursCountArgs>(
      args?: Subset<T, business_hoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Business_hoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Business_hoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Business_hoursAggregateArgs>(args: Subset<T, Business_hoursAggregateArgs>): Prisma.PrismaPromise<GetBusiness_hoursAggregateType<T>>

    /**
     * Group by Business_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {business_hoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends business_hoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: business_hoursGroupByArgs['orderBy'] }
        : { orderBy?: business_hoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, business_hoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusiness_hoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the business_hours model
   */
  readonly fields: business_hoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for business_hours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__business_hoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the business_hours model
   */
  interface business_hoursFieldRefs {
    readonly id: FieldRef<"business_hours", 'BigInt'>
    readonly organization_id: FieldRef<"business_hours", 'BigInt'>
    readonly day_of_week: FieldRef<"business_hours", 'DayOfWeek'>
    readonly start_time: FieldRef<"business_hours", 'String'>
    readonly end_time: FieldRef<"business_hours", 'String'>
    readonly created_at: FieldRef<"business_hours", 'String'>
    readonly updated_at: FieldRef<"business_hours", 'String'>
  }
    

  // Custom InputTypes
  /**
   * business_hours findUnique
   */
  export type business_hoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * Filter, which business_hours to fetch.
     */
    where: business_hoursWhereUniqueInput
  }

  /**
   * business_hours findUniqueOrThrow
   */
  export type business_hoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * Filter, which business_hours to fetch.
     */
    where: business_hoursWhereUniqueInput
  }

  /**
   * business_hours findFirst
   */
  export type business_hoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * Filter, which business_hours to fetch.
     */
    where?: business_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_hours to fetch.
     */
    orderBy?: business_hoursOrderByWithRelationInput | business_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for business_hours.
     */
    cursor?: business_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of business_hours.
     */
    distinct?: Business_hoursScalarFieldEnum | Business_hoursScalarFieldEnum[]
  }

  /**
   * business_hours findFirstOrThrow
   */
  export type business_hoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * Filter, which business_hours to fetch.
     */
    where?: business_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_hours to fetch.
     */
    orderBy?: business_hoursOrderByWithRelationInput | business_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for business_hours.
     */
    cursor?: business_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of business_hours.
     */
    distinct?: Business_hoursScalarFieldEnum | Business_hoursScalarFieldEnum[]
  }

  /**
   * business_hours findMany
   */
  export type business_hoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * Filter, which business_hours to fetch.
     */
    where?: business_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of business_hours to fetch.
     */
    orderBy?: business_hoursOrderByWithRelationInput | business_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing business_hours.
     */
    cursor?: business_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_hours.
     */
    skip?: number
    distinct?: Business_hoursScalarFieldEnum | Business_hoursScalarFieldEnum[]
  }

  /**
   * business_hours create
   */
  export type business_hoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * The data needed to create a business_hours.
     */
    data: XOR<business_hoursCreateInput, business_hoursUncheckedCreateInput>
  }

  /**
   * business_hours createMany
   */
  export type business_hoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many business_hours.
     */
    data: business_hoursCreateManyInput | business_hoursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * business_hours createManyAndReturn
   */
  export type business_hoursCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * The data used to create many business_hours.
     */
    data: business_hoursCreateManyInput | business_hoursCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * business_hours update
   */
  export type business_hoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * The data needed to update a business_hours.
     */
    data: XOR<business_hoursUpdateInput, business_hoursUncheckedUpdateInput>
    /**
     * Choose, which business_hours to update.
     */
    where: business_hoursWhereUniqueInput
  }

  /**
   * business_hours updateMany
   */
  export type business_hoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update business_hours.
     */
    data: XOR<business_hoursUpdateManyMutationInput, business_hoursUncheckedUpdateManyInput>
    /**
     * Filter which business_hours to update
     */
    where?: business_hoursWhereInput
    /**
     * Limit how many business_hours to update.
     */
    limit?: number
  }

  /**
   * business_hours updateManyAndReturn
   */
  export type business_hoursUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * The data used to update business_hours.
     */
    data: XOR<business_hoursUpdateManyMutationInput, business_hoursUncheckedUpdateManyInput>
    /**
     * Filter which business_hours to update
     */
    where?: business_hoursWhereInput
    /**
     * Limit how many business_hours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * business_hours upsert
   */
  export type business_hoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * The filter to search for the business_hours to update in case it exists.
     */
    where: business_hoursWhereUniqueInput
    /**
     * In case the business_hours found by the `where` argument doesn't exist, create a new business_hours with this data.
     */
    create: XOR<business_hoursCreateInput, business_hoursUncheckedCreateInput>
    /**
     * In case the business_hours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<business_hoursUpdateInput, business_hoursUncheckedUpdateInput>
  }

  /**
   * business_hours delete
   */
  export type business_hoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
    /**
     * Filter which business_hours to delete.
     */
    where: business_hoursWhereUniqueInput
  }

  /**
   * business_hours deleteMany
   */
  export type business_hoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which business_hours to delete
     */
    where?: business_hoursWhereInput
    /**
     * Limit how many business_hours to delete.
     */
    limit?: number
  }

  /**
   * business_hours without action
   */
  export type business_hoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the business_hours
     */
    select?: business_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the business_hours
     */
    omit?: business_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: business_hoursInclude<ExtArgs> | null
  }


  /**
   * Model holidays
   */

  export type AggregateHolidays = {
    _count: HolidaysCountAggregateOutputType | null
    _avg: HolidaysAvgAggregateOutputType | null
    _sum: HolidaysSumAggregateOutputType | null
    _min: HolidaysMinAggregateOutputType | null
    _max: HolidaysMaxAggregateOutputType | null
  }

  export type HolidaysAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    is_recurring: number | null
  }

  export type HolidaysSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    is_recurring: number | null
  }

  export type HolidaysMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    holiday_date: string | null
    is_recurring: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type HolidaysMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    holiday_date: string | null
    is_recurring: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type HolidaysCountAggregateOutputType = {
    id: number
    organization_id: number
    name: number
    holiday_date: number
    is_recurring: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type HolidaysAvgAggregateInputType = {
    id?: true
    organization_id?: true
    is_recurring?: true
  }

  export type HolidaysSumAggregateInputType = {
    id?: true
    organization_id?: true
    is_recurring?: true
  }

  export type HolidaysMinAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    holiday_date?: true
    is_recurring?: true
    created_at?: true
    updated_at?: true
  }

  export type HolidaysMaxAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    holiday_date?: true
    is_recurring?: true
    created_at?: true
    updated_at?: true
  }

  export type HolidaysCountAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    holiday_date?: true
    is_recurring?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type HolidaysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which holidays to aggregate.
     */
    where?: holidaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidaysOrderByWithRelationInput | holidaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: holidaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned holidays
    **/
    _count?: true | HolidaysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HolidaysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HolidaysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidaysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidaysMaxAggregateInputType
  }

  export type GetHolidaysAggregateType<T extends HolidaysAggregateArgs> = {
        [P in keyof T & keyof AggregateHolidays]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHolidays[P]>
      : GetScalarType<T[P], AggregateHolidays[P]>
  }




  export type holidaysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: holidaysWhereInput
    orderBy?: holidaysOrderByWithAggregationInput | holidaysOrderByWithAggregationInput[]
    by: HolidaysScalarFieldEnum[] | HolidaysScalarFieldEnum
    having?: holidaysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidaysCountAggregateInputType | true
    _avg?: HolidaysAvgAggregateInputType
    _sum?: HolidaysSumAggregateInputType
    _min?: HolidaysMinAggregateInputType
    _max?: HolidaysMaxAggregateInputType
  }

  export type HolidaysGroupByOutputType = {
    id: bigint
    organization_id: bigint
    name: string
    holiday_date: string
    is_recurring: number
    created_at: string
    updated_at: string
    _count: HolidaysCountAggregateOutputType | null
    _avg: HolidaysAvgAggregateOutputType | null
    _sum: HolidaysSumAggregateOutputType | null
    _min: HolidaysMinAggregateOutputType | null
    _max: HolidaysMaxAggregateOutputType | null
  }

  type GetHolidaysGroupByPayload<T extends holidaysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidaysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidaysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidaysGroupByOutputType[P]>
            : GetScalarType<T[P], HolidaysGroupByOutputType[P]>
        }
      >
    >


  export type holidaysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    holiday_date?: boolean
    is_recurring?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holidays"]>

  export type holidaysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    holiday_date?: boolean
    is_recurring?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holidays"]>

  export type holidaysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    holiday_date?: boolean
    is_recurring?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holidays"]>

  export type holidaysSelectScalar = {
    id?: boolean
    organization_id?: boolean
    name?: boolean
    holiday_date?: boolean
    is_recurring?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type holidaysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "name" | "holiday_date" | "is_recurring" | "created_at" | "updated_at", ExtArgs["result"]["holidays"]>
  export type holidaysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type holidaysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type holidaysIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $holidaysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "holidays"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      name: string
      holiday_date: string
      is_recurring: number
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["holidays"]>
    composites: {}
  }

  type holidaysGetPayload<S extends boolean | null | undefined | holidaysDefaultArgs> = $Result.GetResult<Prisma.$holidaysPayload, S>

  type holidaysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<holidaysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HolidaysCountAggregateInputType | true
    }

  export interface holidaysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['holidays'], meta: { name: 'holidays' } }
    /**
     * Find zero or one Holidays that matches the filter.
     * @param {holidaysFindUniqueArgs} args - Arguments to find a Holidays
     * @example
     * // Get one Holidays
     * const holidays = await prisma.holidays.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends holidaysFindUniqueArgs>(args: SelectSubset<T, holidaysFindUniqueArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Holidays that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {holidaysFindUniqueOrThrowArgs} args - Arguments to find a Holidays
     * @example
     * // Get one Holidays
     * const holidays = await prisma.holidays.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends holidaysFindUniqueOrThrowArgs>(args: SelectSubset<T, holidaysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidaysFindFirstArgs} args - Arguments to find a Holidays
     * @example
     * // Get one Holidays
     * const holidays = await prisma.holidays.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends holidaysFindFirstArgs>(args?: SelectSubset<T, holidaysFindFirstArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holidays that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidaysFindFirstOrThrowArgs} args - Arguments to find a Holidays
     * @example
     * // Get one Holidays
     * const holidays = await prisma.holidays.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends holidaysFindFirstOrThrowArgs>(args?: SelectSubset<T, holidaysFindFirstOrThrowArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidaysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holidays.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holidays.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidaysWithIdOnly = await prisma.holidays.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends holidaysFindManyArgs>(args?: SelectSubset<T, holidaysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Holidays.
     * @param {holidaysCreateArgs} args - Arguments to create a Holidays.
     * @example
     * // Create one Holidays
     * const Holidays = await prisma.holidays.create({
     *   data: {
     *     // ... data to create a Holidays
     *   }
     * })
     * 
     */
    create<T extends holidaysCreateArgs>(args: SelectSubset<T, holidaysCreateArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Holidays.
     * @param {holidaysCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holidays = await prisma.holidays.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends holidaysCreateManyArgs>(args?: SelectSubset<T, holidaysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holidays and returns the data saved in the database.
     * @param {holidaysCreateManyAndReturnArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holidays = await prisma.holidays.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holidays and only return the `id`
     * const holidaysWithIdOnly = await prisma.holidays.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends holidaysCreateManyAndReturnArgs>(args?: SelectSubset<T, holidaysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Holidays.
     * @param {holidaysDeleteArgs} args - Arguments to delete one Holidays.
     * @example
     * // Delete one Holidays
     * const Holidays = await prisma.holidays.delete({
     *   where: {
     *     // ... filter to delete one Holidays
     *   }
     * })
     * 
     */
    delete<T extends holidaysDeleteArgs>(args: SelectSubset<T, holidaysDeleteArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Holidays.
     * @param {holidaysUpdateArgs} args - Arguments to update one Holidays.
     * @example
     * // Update one Holidays
     * const holidays = await prisma.holidays.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends holidaysUpdateArgs>(args: SelectSubset<T, holidaysUpdateArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Holidays.
     * @param {holidaysDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holidays.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends holidaysDeleteManyArgs>(args?: SelectSubset<T, holidaysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidaysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holidays = await prisma.holidays.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends holidaysUpdateManyArgs>(args: SelectSubset<T, holidaysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays and returns the data updated in the database.
     * @param {holidaysUpdateManyAndReturnArgs} args - Arguments to update many Holidays.
     * @example
     * // Update many Holidays
     * const holidays = await prisma.holidays.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Holidays and only return the `id`
     * const holidaysWithIdOnly = await prisma.holidays.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends holidaysUpdateManyAndReturnArgs>(args: SelectSubset<T, holidaysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Holidays.
     * @param {holidaysUpsertArgs} args - Arguments to update or create a Holidays.
     * @example
     * // Update or create a Holidays
     * const holidays = await prisma.holidays.upsert({
     *   create: {
     *     // ... data to create a Holidays
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holidays we want to update
     *   }
     * })
     */
    upsert<T extends holidaysUpsertArgs>(args: SelectSubset<T, holidaysUpsertArgs<ExtArgs>>): Prisma__holidaysClient<$Result.GetResult<Prisma.$holidaysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidaysCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holidays.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends holidaysCountArgs>(
      args?: Subset<T, holidaysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidaysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidaysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidaysAggregateArgs>(args: Subset<T, HolidaysAggregateArgs>): Prisma.PrismaPromise<GetHolidaysAggregateType<T>>

    /**
     * Group by Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidaysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends holidaysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: holidaysGroupByArgs['orderBy'] }
        : { orderBy?: holidaysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, holidaysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidaysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the holidays model
   */
  readonly fields: holidaysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for holidays.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__holidaysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the holidays model
   */
  interface holidaysFieldRefs {
    readonly id: FieldRef<"holidays", 'BigInt'>
    readonly organization_id: FieldRef<"holidays", 'BigInt'>
    readonly name: FieldRef<"holidays", 'String'>
    readonly holiday_date: FieldRef<"holidays", 'String'>
    readonly is_recurring: FieldRef<"holidays", 'Int'>
    readonly created_at: FieldRef<"holidays", 'String'>
    readonly updated_at: FieldRef<"holidays", 'String'>
  }
    

  // Custom InputTypes
  /**
   * holidays findUnique
   */
  export type holidaysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * Filter, which holidays to fetch.
     */
    where: holidaysWhereUniqueInput
  }

  /**
   * holidays findUniqueOrThrow
   */
  export type holidaysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * Filter, which holidays to fetch.
     */
    where: holidaysWhereUniqueInput
  }

  /**
   * holidays findFirst
   */
  export type holidaysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * Filter, which holidays to fetch.
     */
    where?: holidaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidaysOrderByWithRelationInput | holidaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for holidays.
     */
    cursor?: holidaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of holidays.
     */
    distinct?: HolidaysScalarFieldEnum | HolidaysScalarFieldEnum[]
  }

  /**
   * holidays findFirstOrThrow
   */
  export type holidaysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * Filter, which holidays to fetch.
     */
    where?: holidaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidaysOrderByWithRelationInput | holidaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for holidays.
     */
    cursor?: holidaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of holidays.
     */
    distinct?: HolidaysScalarFieldEnum | HolidaysScalarFieldEnum[]
  }

  /**
   * holidays findMany
   */
  export type holidaysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * Filter, which holidays to fetch.
     */
    where?: holidaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidaysOrderByWithRelationInput | holidaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing holidays.
     */
    cursor?: holidaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    distinct?: HolidaysScalarFieldEnum | HolidaysScalarFieldEnum[]
  }

  /**
   * holidays create
   */
  export type holidaysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * The data needed to create a holidays.
     */
    data: XOR<holidaysCreateInput, holidaysUncheckedCreateInput>
  }

  /**
   * holidays createMany
   */
  export type holidaysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many holidays.
     */
    data: holidaysCreateManyInput | holidaysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * holidays createManyAndReturn
   */
  export type holidaysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * The data used to create many holidays.
     */
    data: holidaysCreateManyInput | holidaysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * holidays update
   */
  export type holidaysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * The data needed to update a holidays.
     */
    data: XOR<holidaysUpdateInput, holidaysUncheckedUpdateInput>
    /**
     * Choose, which holidays to update.
     */
    where: holidaysWhereUniqueInput
  }

  /**
   * holidays updateMany
   */
  export type holidaysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update holidays.
     */
    data: XOR<holidaysUpdateManyMutationInput, holidaysUncheckedUpdateManyInput>
    /**
     * Filter which holidays to update
     */
    where?: holidaysWhereInput
    /**
     * Limit how many holidays to update.
     */
    limit?: number
  }

  /**
   * holidays updateManyAndReturn
   */
  export type holidaysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * The data used to update holidays.
     */
    data: XOR<holidaysUpdateManyMutationInput, holidaysUncheckedUpdateManyInput>
    /**
     * Filter which holidays to update
     */
    where?: holidaysWhereInput
    /**
     * Limit how many holidays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * holidays upsert
   */
  export type holidaysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * The filter to search for the holidays to update in case it exists.
     */
    where: holidaysWhereUniqueInput
    /**
     * In case the holidays found by the `where` argument doesn't exist, create a new holidays with this data.
     */
    create: XOR<holidaysCreateInput, holidaysUncheckedCreateInput>
    /**
     * In case the holidays was found with the provided `where` argument, update it with this data.
     */
    update: XOR<holidaysUpdateInput, holidaysUncheckedUpdateInput>
  }

  /**
   * holidays delete
   */
  export type holidaysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
    /**
     * Filter which holidays to delete.
     */
    where: holidaysWhereUniqueInput
  }

  /**
   * holidays deleteMany
   */
  export type holidaysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which holidays to delete
     */
    where?: holidaysWhereInput
    /**
     * Limit how many holidays to delete.
     */
    limit?: number
  }

  /**
   * holidays without action
   */
  export type holidaysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holidays
     */
    select?: holidaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holidays
     */
    omit?: holidaysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holidaysInclude<ExtArgs> | null
  }


  /**
   * Model time_off_requests
   */

  export type AggregateTime_off_requests = {
    _count: Time_off_requestsCountAggregateOutputType | null
    _avg: Time_off_requestsAvgAggregateOutputType | null
    _sum: Time_off_requestsSumAggregateOutputType | null
    _min: Time_off_requestsMinAggregateOutputType | null
    _max: Time_off_requestsMaxAggregateOutputType | null
  }

  export type Time_off_requestsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Time_off_requestsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type Time_off_requestsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    start_date: string | null
    end_date: string | null
    reason: string | null
    status: $Enums.RequestStatus | null
    created_at: string | null
    updated_at: string | null
  }

  export type Time_off_requestsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    start_date: string | null
    end_date: string | null
    reason: string | null
    status: $Enums.RequestStatus | null
    created_at: string | null
    updated_at: string | null
  }

  export type Time_off_requestsCountAggregateOutputType = {
    id: number
    user_id: number
    start_date: number
    end_date: number
    reason: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Time_off_requestsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Time_off_requestsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Time_off_requestsMinAggregateInputType = {
    id?: true
    user_id?: true
    start_date?: true
    end_date?: true
    reason?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Time_off_requestsMaxAggregateInputType = {
    id?: true
    user_id?: true
    start_date?: true
    end_date?: true
    reason?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Time_off_requestsCountAggregateInputType = {
    id?: true
    user_id?: true
    start_date?: true
    end_date?: true
    reason?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Time_off_requestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which time_off_requests to aggregate.
     */
    where?: time_off_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of time_off_requests to fetch.
     */
    orderBy?: time_off_requestsOrderByWithRelationInput | time_off_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: time_off_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` time_off_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` time_off_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned time_off_requests
    **/
    _count?: true | Time_off_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Time_off_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Time_off_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Time_off_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Time_off_requestsMaxAggregateInputType
  }

  export type GetTime_off_requestsAggregateType<T extends Time_off_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateTime_off_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTime_off_requests[P]>
      : GetScalarType<T[P], AggregateTime_off_requests[P]>
  }




  export type time_off_requestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: time_off_requestsWhereInput
    orderBy?: time_off_requestsOrderByWithAggregationInput | time_off_requestsOrderByWithAggregationInput[]
    by: Time_off_requestsScalarFieldEnum[] | Time_off_requestsScalarFieldEnum
    having?: time_off_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Time_off_requestsCountAggregateInputType | true
    _avg?: Time_off_requestsAvgAggregateInputType
    _sum?: Time_off_requestsSumAggregateInputType
    _min?: Time_off_requestsMinAggregateInputType
    _max?: Time_off_requestsMaxAggregateInputType
  }

  export type Time_off_requestsGroupByOutputType = {
    id: bigint
    user_id: bigint
    start_date: string
    end_date: string
    reason: string
    status: $Enums.RequestStatus
    created_at: string
    updated_at: string
    _count: Time_off_requestsCountAggregateOutputType | null
    _avg: Time_off_requestsAvgAggregateOutputType | null
    _sum: Time_off_requestsSumAggregateOutputType | null
    _min: Time_off_requestsMinAggregateOutputType | null
    _max: Time_off_requestsMaxAggregateOutputType | null
  }

  type GetTime_off_requestsGroupByPayload<T extends time_off_requestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Time_off_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Time_off_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Time_off_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Time_off_requestsGroupByOutputType[P]>
        }
      >
    >


  export type time_off_requestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    start_date?: boolean
    end_date?: boolean
    reason?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["time_off_requests"]>

  export type time_off_requestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    start_date?: boolean
    end_date?: boolean
    reason?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["time_off_requests"]>

  export type time_off_requestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    start_date?: boolean
    end_date?: boolean
    reason?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["time_off_requests"]>

  export type time_off_requestsSelectScalar = {
    id?: boolean
    user_id?: boolean
    start_date?: boolean
    end_date?: boolean
    reason?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type time_off_requestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "start_date" | "end_date" | "reason" | "status" | "created_at" | "updated_at", ExtArgs["result"]["time_off_requests"]>
  export type time_off_requestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type time_off_requestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type time_off_requestsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $time_off_requestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "time_off_requests"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      start_date: string
      end_date: string
      reason: string
      status: $Enums.RequestStatus
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["time_off_requests"]>
    composites: {}
  }

  type time_off_requestsGetPayload<S extends boolean | null | undefined | time_off_requestsDefaultArgs> = $Result.GetResult<Prisma.$time_off_requestsPayload, S>

  type time_off_requestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<time_off_requestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Time_off_requestsCountAggregateInputType | true
    }

  export interface time_off_requestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['time_off_requests'], meta: { name: 'time_off_requests' } }
    /**
     * Find zero or one Time_off_requests that matches the filter.
     * @param {time_off_requestsFindUniqueArgs} args - Arguments to find a Time_off_requests
     * @example
     * // Get one Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends time_off_requestsFindUniqueArgs>(args: SelectSubset<T, time_off_requestsFindUniqueArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Time_off_requests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {time_off_requestsFindUniqueOrThrowArgs} args - Arguments to find a Time_off_requests
     * @example
     * // Get one Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends time_off_requestsFindUniqueOrThrowArgs>(args: SelectSubset<T, time_off_requestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Time_off_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {time_off_requestsFindFirstArgs} args - Arguments to find a Time_off_requests
     * @example
     * // Get one Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends time_off_requestsFindFirstArgs>(args?: SelectSubset<T, time_off_requestsFindFirstArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Time_off_requests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {time_off_requestsFindFirstOrThrowArgs} args - Arguments to find a Time_off_requests
     * @example
     * // Get one Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends time_off_requestsFindFirstOrThrowArgs>(args?: SelectSubset<T, time_off_requestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Time_off_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {time_off_requestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.findMany()
     * 
     * // Get first 10 Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const time_off_requestsWithIdOnly = await prisma.time_off_requests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends time_off_requestsFindManyArgs>(args?: SelectSubset<T, time_off_requestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Time_off_requests.
     * @param {time_off_requestsCreateArgs} args - Arguments to create a Time_off_requests.
     * @example
     * // Create one Time_off_requests
     * const Time_off_requests = await prisma.time_off_requests.create({
     *   data: {
     *     // ... data to create a Time_off_requests
     *   }
     * })
     * 
     */
    create<T extends time_off_requestsCreateArgs>(args: SelectSubset<T, time_off_requestsCreateArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Time_off_requests.
     * @param {time_off_requestsCreateManyArgs} args - Arguments to create many Time_off_requests.
     * @example
     * // Create many Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends time_off_requestsCreateManyArgs>(args?: SelectSubset<T, time_off_requestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Time_off_requests and returns the data saved in the database.
     * @param {time_off_requestsCreateManyAndReturnArgs} args - Arguments to create many Time_off_requests.
     * @example
     * // Create many Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Time_off_requests and only return the `id`
     * const time_off_requestsWithIdOnly = await prisma.time_off_requests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends time_off_requestsCreateManyAndReturnArgs>(args?: SelectSubset<T, time_off_requestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Time_off_requests.
     * @param {time_off_requestsDeleteArgs} args - Arguments to delete one Time_off_requests.
     * @example
     * // Delete one Time_off_requests
     * const Time_off_requests = await prisma.time_off_requests.delete({
     *   where: {
     *     // ... filter to delete one Time_off_requests
     *   }
     * })
     * 
     */
    delete<T extends time_off_requestsDeleteArgs>(args: SelectSubset<T, time_off_requestsDeleteArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Time_off_requests.
     * @param {time_off_requestsUpdateArgs} args - Arguments to update one Time_off_requests.
     * @example
     * // Update one Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends time_off_requestsUpdateArgs>(args: SelectSubset<T, time_off_requestsUpdateArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Time_off_requests.
     * @param {time_off_requestsDeleteManyArgs} args - Arguments to filter Time_off_requests to delete.
     * @example
     * // Delete a few Time_off_requests
     * const { count } = await prisma.time_off_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends time_off_requestsDeleteManyArgs>(args?: SelectSubset<T, time_off_requestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Time_off_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {time_off_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends time_off_requestsUpdateManyArgs>(args: SelectSubset<T, time_off_requestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Time_off_requests and returns the data updated in the database.
     * @param {time_off_requestsUpdateManyAndReturnArgs} args - Arguments to update many Time_off_requests.
     * @example
     * // Update many Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Time_off_requests and only return the `id`
     * const time_off_requestsWithIdOnly = await prisma.time_off_requests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends time_off_requestsUpdateManyAndReturnArgs>(args: SelectSubset<T, time_off_requestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Time_off_requests.
     * @param {time_off_requestsUpsertArgs} args - Arguments to update or create a Time_off_requests.
     * @example
     * // Update or create a Time_off_requests
     * const time_off_requests = await prisma.time_off_requests.upsert({
     *   create: {
     *     // ... data to create a Time_off_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Time_off_requests we want to update
     *   }
     * })
     */
    upsert<T extends time_off_requestsUpsertArgs>(args: SelectSubset<T, time_off_requestsUpsertArgs<ExtArgs>>): Prisma__time_off_requestsClient<$Result.GetResult<Prisma.$time_off_requestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Time_off_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {time_off_requestsCountArgs} args - Arguments to filter Time_off_requests to count.
     * @example
     * // Count the number of Time_off_requests
     * const count = await prisma.time_off_requests.count({
     *   where: {
     *     // ... the filter for the Time_off_requests we want to count
     *   }
     * })
    **/
    count<T extends time_off_requestsCountArgs>(
      args?: Subset<T, time_off_requestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Time_off_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Time_off_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Time_off_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Time_off_requestsAggregateArgs>(args: Subset<T, Time_off_requestsAggregateArgs>): Prisma.PrismaPromise<GetTime_off_requestsAggregateType<T>>

    /**
     * Group by Time_off_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {time_off_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends time_off_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: time_off_requestsGroupByArgs['orderBy'] }
        : { orderBy?: time_off_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, time_off_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTime_off_requestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the time_off_requests model
   */
  readonly fields: time_off_requestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for time_off_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__time_off_requestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the time_off_requests model
   */
  interface time_off_requestsFieldRefs {
    readonly id: FieldRef<"time_off_requests", 'BigInt'>
    readonly user_id: FieldRef<"time_off_requests", 'BigInt'>
    readonly start_date: FieldRef<"time_off_requests", 'String'>
    readonly end_date: FieldRef<"time_off_requests", 'String'>
    readonly reason: FieldRef<"time_off_requests", 'String'>
    readonly status: FieldRef<"time_off_requests", 'RequestStatus'>
    readonly created_at: FieldRef<"time_off_requests", 'String'>
    readonly updated_at: FieldRef<"time_off_requests", 'String'>
  }
    

  // Custom InputTypes
  /**
   * time_off_requests findUnique
   */
  export type time_off_requestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * Filter, which time_off_requests to fetch.
     */
    where: time_off_requestsWhereUniqueInput
  }

  /**
   * time_off_requests findUniqueOrThrow
   */
  export type time_off_requestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * Filter, which time_off_requests to fetch.
     */
    where: time_off_requestsWhereUniqueInput
  }

  /**
   * time_off_requests findFirst
   */
  export type time_off_requestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * Filter, which time_off_requests to fetch.
     */
    where?: time_off_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of time_off_requests to fetch.
     */
    orderBy?: time_off_requestsOrderByWithRelationInput | time_off_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for time_off_requests.
     */
    cursor?: time_off_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` time_off_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` time_off_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of time_off_requests.
     */
    distinct?: Time_off_requestsScalarFieldEnum | Time_off_requestsScalarFieldEnum[]
  }

  /**
   * time_off_requests findFirstOrThrow
   */
  export type time_off_requestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * Filter, which time_off_requests to fetch.
     */
    where?: time_off_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of time_off_requests to fetch.
     */
    orderBy?: time_off_requestsOrderByWithRelationInput | time_off_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for time_off_requests.
     */
    cursor?: time_off_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` time_off_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` time_off_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of time_off_requests.
     */
    distinct?: Time_off_requestsScalarFieldEnum | Time_off_requestsScalarFieldEnum[]
  }

  /**
   * time_off_requests findMany
   */
  export type time_off_requestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * Filter, which time_off_requests to fetch.
     */
    where?: time_off_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of time_off_requests to fetch.
     */
    orderBy?: time_off_requestsOrderByWithRelationInput | time_off_requestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing time_off_requests.
     */
    cursor?: time_off_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` time_off_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` time_off_requests.
     */
    skip?: number
    distinct?: Time_off_requestsScalarFieldEnum | Time_off_requestsScalarFieldEnum[]
  }

  /**
   * time_off_requests create
   */
  export type time_off_requestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * The data needed to create a time_off_requests.
     */
    data: XOR<time_off_requestsCreateInput, time_off_requestsUncheckedCreateInput>
  }

  /**
   * time_off_requests createMany
   */
  export type time_off_requestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many time_off_requests.
     */
    data: time_off_requestsCreateManyInput | time_off_requestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * time_off_requests createManyAndReturn
   */
  export type time_off_requestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * The data used to create many time_off_requests.
     */
    data: time_off_requestsCreateManyInput | time_off_requestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * time_off_requests update
   */
  export type time_off_requestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * The data needed to update a time_off_requests.
     */
    data: XOR<time_off_requestsUpdateInput, time_off_requestsUncheckedUpdateInput>
    /**
     * Choose, which time_off_requests to update.
     */
    where: time_off_requestsWhereUniqueInput
  }

  /**
   * time_off_requests updateMany
   */
  export type time_off_requestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update time_off_requests.
     */
    data: XOR<time_off_requestsUpdateManyMutationInput, time_off_requestsUncheckedUpdateManyInput>
    /**
     * Filter which time_off_requests to update
     */
    where?: time_off_requestsWhereInput
    /**
     * Limit how many time_off_requests to update.
     */
    limit?: number
  }

  /**
   * time_off_requests updateManyAndReturn
   */
  export type time_off_requestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * The data used to update time_off_requests.
     */
    data: XOR<time_off_requestsUpdateManyMutationInput, time_off_requestsUncheckedUpdateManyInput>
    /**
     * Filter which time_off_requests to update
     */
    where?: time_off_requestsWhereInput
    /**
     * Limit how many time_off_requests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * time_off_requests upsert
   */
  export type time_off_requestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * The filter to search for the time_off_requests to update in case it exists.
     */
    where: time_off_requestsWhereUniqueInput
    /**
     * In case the time_off_requests found by the `where` argument doesn't exist, create a new time_off_requests with this data.
     */
    create: XOR<time_off_requestsCreateInput, time_off_requestsUncheckedCreateInput>
    /**
     * In case the time_off_requests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<time_off_requestsUpdateInput, time_off_requestsUncheckedUpdateInput>
  }

  /**
   * time_off_requests delete
   */
  export type time_off_requestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
    /**
     * Filter which time_off_requests to delete.
     */
    where: time_off_requestsWhereUniqueInput
  }

  /**
   * time_off_requests deleteMany
   */
  export type time_off_requestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which time_off_requests to delete
     */
    where?: time_off_requestsWhereInput
    /**
     * Limit how many time_off_requests to delete.
     */
    limit?: number
  }

  /**
   * time_off_requests without action
   */
  export type time_off_requestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the time_off_requests
     */
    select?: time_off_requestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the time_off_requests
     */
    omit?: time_off_requestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: time_off_requestsInclude<ExtArgs> | null
  }


  /**
   * Model crews
   */

  export type AggregateCrews = {
    _count: CrewsCountAggregateOutputType | null
    _avg: CrewsAvgAggregateOutputType | null
    _sum: CrewsSumAggregateOutputType | null
    _min: CrewsMinAggregateOutputType | null
    _max: CrewsMaxAggregateOutputType | null
  }

  export type CrewsAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    leader_id: number | null
  }

  export type CrewsSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    leader_id: bigint | null
  }

  export type CrewsMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    leader_id: bigint | null
    created_at: string | null
    updated_at: string | null
  }

  export type CrewsMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    leader_id: bigint | null
    created_at: string | null
    updated_at: string | null
  }

  export type CrewsCountAggregateOutputType = {
    id: number
    organization_id: number
    name: number
    leader_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CrewsAvgAggregateInputType = {
    id?: true
    organization_id?: true
    leader_id?: true
  }

  export type CrewsSumAggregateInputType = {
    id?: true
    organization_id?: true
    leader_id?: true
  }

  export type CrewsMinAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    leader_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CrewsMaxAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    leader_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CrewsCountAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    leader_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CrewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crews to aggregate.
     */
    where?: crewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crews to fetch.
     */
    orderBy?: crewsOrderByWithRelationInput | crewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crews
    **/
    _count?: true | CrewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewsMaxAggregateInputType
  }

  export type GetCrewsAggregateType<T extends CrewsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrews[P]>
      : GetScalarType<T[P], AggregateCrews[P]>
  }




  export type crewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crewsWhereInput
    orderBy?: crewsOrderByWithAggregationInput | crewsOrderByWithAggregationInput[]
    by: CrewsScalarFieldEnum[] | CrewsScalarFieldEnum
    having?: crewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewsCountAggregateInputType | true
    _avg?: CrewsAvgAggregateInputType
    _sum?: CrewsSumAggregateInputType
    _min?: CrewsMinAggregateInputType
    _max?: CrewsMaxAggregateInputType
  }

  export type CrewsGroupByOutputType = {
    id: bigint
    organization_id: bigint
    name: string
    leader_id: bigint
    created_at: string
    updated_at: string
    _count: CrewsCountAggregateOutputType | null
    _avg: CrewsAvgAggregateOutputType | null
    _sum: CrewsSumAggregateOutputType | null
    _min: CrewsMinAggregateOutputType | null
    _max: CrewsMaxAggregateOutputType | null
  }

  type GetCrewsGroupByPayload<T extends crewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewsGroupByOutputType[P]>
            : GetScalarType<T[P], CrewsGroupByOutputType[P]>
        }
      >
    >


  export type crewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    leader_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    crew_members?: boolean | crews$crew_membersArgs<ExtArgs>
    work_order_crew?: boolean | crews$work_order_crewArgs<ExtArgs>
    _count?: boolean | CrewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crews"]>

  export type crewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    leader_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crews"]>

  export type crewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    leader_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crews"]>

  export type crewsSelectScalar = {
    id?: boolean
    organization_id?: boolean
    name?: boolean
    leader_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type crewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "name" | "leader_id" | "created_at" | "updated_at", ExtArgs["result"]["crews"]>
  export type crewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    crew_members?: boolean | crews$crew_membersArgs<ExtArgs>
    work_order_crew?: boolean | crews$work_order_crewArgs<ExtArgs>
    _count?: boolean | CrewsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type crewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type crewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $crewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "crews"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      crew_members: Prisma.$crew_membersPayload<ExtArgs>[]
      work_order_crew: Prisma.$work_order_crewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      name: string
      leader_id: bigint
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["crews"]>
    composites: {}
  }

  type crewsGetPayload<S extends boolean | null | undefined | crewsDefaultArgs> = $Result.GetResult<Prisma.$crewsPayload, S>

  type crewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<crewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrewsCountAggregateInputType | true
    }

  export interface crewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crews'], meta: { name: 'crews' } }
    /**
     * Find zero or one Crews that matches the filter.
     * @param {crewsFindUniqueArgs} args - Arguments to find a Crews
     * @example
     * // Get one Crews
     * const crews = await prisma.crews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends crewsFindUniqueArgs>(args: SelectSubset<T, crewsFindUniqueArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {crewsFindUniqueOrThrowArgs} args - Arguments to find a Crews
     * @example
     * // Get one Crews
     * const crews = await prisma.crews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends crewsFindUniqueOrThrowArgs>(args: SelectSubset<T, crewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crewsFindFirstArgs} args - Arguments to find a Crews
     * @example
     * // Get one Crews
     * const crews = await prisma.crews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends crewsFindFirstArgs>(args?: SelectSubset<T, crewsFindFirstArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crewsFindFirstOrThrowArgs} args - Arguments to find a Crews
     * @example
     * // Get one Crews
     * const crews = await prisma.crews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends crewsFindFirstOrThrowArgs>(args?: SelectSubset<T, crewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crews.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewsWithIdOnly = await prisma.crews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends crewsFindManyArgs>(args?: SelectSubset<T, crewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crews.
     * @param {crewsCreateArgs} args - Arguments to create a Crews.
     * @example
     * // Create one Crews
     * const Crews = await prisma.crews.create({
     *   data: {
     *     // ... data to create a Crews
     *   }
     * })
     * 
     */
    create<T extends crewsCreateArgs>(args: SelectSubset<T, crewsCreateArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crews.
     * @param {crewsCreateManyArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crews = await prisma.crews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends crewsCreateManyArgs>(args?: SelectSubset<T, crewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crews and returns the data saved in the database.
     * @param {crewsCreateManyAndReturnArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crews = await prisma.crews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crews and only return the `id`
     * const crewsWithIdOnly = await prisma.crews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends crewsCreateManyAndReturnArgs>(args?: SelectSubset<T, crewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crews.
     * @param {crewsDeleteArgs} args - Arguments to delete one Crews.
     * @example
     * // Delete one Crews
     * const Crews = await prisma.crews.delete({
     *   where: {
     *     // ... filter to delete one Crews
     *   }
     * })
     * 
     */
    delete<T extends crewsDeleteArgs>(args: SelectSubset<T, crewsDeleteArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crews.
     * @param {crewsUpdateArgs} args - Arguments to update one Crews.
     * @example
     * // Update one Crews
     * const crews = await prisma.crews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends crewsUpdateArgs>(args: SelectSubset<T, crewsUpdateArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crews.
     * @param {crewsDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends crewsDeleteManyArgs>(args?: SelectSubset<T, crewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crews = await prisma.crews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends crewsUpdateManyArgs>(args: SelectSubset<T, crewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews and returns the data updated in the database.
     * @param {crewsUpdateManyAndReturnArgs} args - Arguments to update many Crews.
     * @example
     * // Update many Crews
     * const crews = await prisma.crews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crews and only return the `id`
     * const crewsWithIdOnly = await prisma.crews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends crewsUpdateManyAndReturnArgs>(args: SelectSubset<T, crewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crews.
     * @param {crewsUpsertArgs} args - Arguments to update or create a Crews.
     * @example
     * // Update or create a Crews
     * const crews = await prisma.crews.upsert({
     *   create: {
     *     // ... data to create a Crews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crews we want to update
     *   }
     * })
     */
    upsert<T extends crewsUpsertArgs>(args: SelectSubset<T, crewsUpsertArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crewsCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crews.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends crewsCountArgs>(
      args?: Subset<T, crewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewsAggregateArgs>(args: Subset<T, CrewsAggregateArgs>): Prisma.PrismaPromise<GetCrewsAggregateType<T>>

    /**
     * Group by Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crewsGroupByArgs['orderBy'] }
        : { orderBy?: crewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crews model
   */
  readonly fields: crewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    crew_members<T extends crews$crew_membersArgs<ExtArgs> = {}>(args?: Subset<T, crews$crew_membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_order_crew<T extends crews$work_order_crewArgs<ExtArgs> = {}>(args?: Subset<T, crews$work_order_crewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the crews model
   */
  interface crewsFieldRefs {
    readonly id: FieldRef<"crews", 'BigInt'>
    readonly organization_id: FieldRef<"crews", 'BigInt'>
    readonly name: FieldRef<"crews", 'String'>
    readonly leader_id: FieldRef<"crews", 'BigInt'>
    readonly created_at: FieldRef<"crews", 'String'>
    readonly updated_at: FieldRef<"crews", 'String'>
  }
    

  // Custom InputTypes
  /**
   * crews findUnique
   */
  export type crewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * Filter, which crews to fetch.
     */
    where: crewsWhereUniqueInput
  }

  /**
   * crews findUniqueOrThrow
   */
  export type crewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * Filter, which crews to fetch.
     */
    where: crewsWhereUniqueInput
  }

  /**
   * crews findFirst
   */
  export type crewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * Filter, which crews to fetch.
     */
    where?: crewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crews to fetch.
     */
    orderBy?: crewsOrderByWithRelationInput | crewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crews.
     */
    cursor?: crewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crews.
     */
    distinct?: CrewsScalarFieldEnum | CrewsScalarFieldEnum[]
  }

  /**
   * crews findFirstOrThrow
   */
  export type crewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * Filter, which crews to fetch.
     */
    where?: crewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crews to fetch.
     */
    orderBy?: crewsOrderByWithRelationInput | crewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crews.
     */
    cursor?: crewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crews.
     */
    distinct?: CrewsScalarFieldEnum | CrewsScalarFieldEnum[]
  }

  /**
   * crews findMany
   */
  export type crewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * Filter, which crews to fetch.
     */
    where?: crewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crews to fetch.
     */
    orderBy?: crewsOrderByWithRelationInput | crewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crews.
     */
    cursor?: crewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crews.
     */
    skip?: number
    distinct?: CrewsScalarFieldEnum | CrewsScalarFieldEnum[]
  }

  /**
   * crews create
   */
  export type crewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * The data needed to create a crews.
     */
    data: XOR<crewsCreateInput, crewsUncheckedCreateInput>
  }

  /**
   * crews createMany
   */
  export type crewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crews.
     */
    data: crewsCreateManyInput | crewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * crews createManyAndReturn
   */
  export type crewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * The data used to create many crews.
     */
    data: crewsCreateManyInput | crewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * crews update
   */
  export type crewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * The data needed to update a crews.
     */
    data: XOR<crewsUpdateInput, crewsUncheckedUpdateInput>
    /**
     * Choose, which crews to update.
     */
    where: crewsWhereUniqueInput
  }

  /**
   * crews updateMany
   */
  export type crewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crews.
     */
    data: XOR<crewsUpdateManyMutationInput, crewsUncheckedUpdateManyInput>
    /**
     * Filter which crews to update
     */
    where?: crewsWhereInput
    /**
     * Limit how many crews to update.
     */
    limit?: number
  }

  /**
   * crews updateManyAndReturn
   */
  export type crewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * The data used to update crews.
     */
    data: XOR<crewsUpdateManyMutationInput, crewsUncheckedUpdateManyInput>
    /**
     * Filter which crews to update
     */
    where?: crewsWhereInput
    /**
     * Limit how many crews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * crews upsert
   */
  export type crewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * The filter to search for the crews to update in case it exists.
     */
    where: crewsWhereUniqueInput
    /**
     * In case the crews found by the `where` argument doesn't exist, create a new crews with this data.
     */
    create: XOR<crewsCreateInput, crewsUncheckedCreateInput>
    /**
     * In case the crews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crewsUpdateInput, crewsUncheckedUpdateInput>
  }

  /**
   * crews delete
   */
  export type crewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
    /**
     * Filter which crews to delete.
     */
    where: crewsWhereUniqueInput
  }

  /**
   * crews deleteMany
   */
  export type crewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crews to delete
     */
    where?: crewsWhereInput
    /**
     * Limit how many crews to delete.
     */
    limit?: number
  }

  /**
   * crews.crew_members
   */
  export type crews$crew_membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    where?: crew_membersWhereInput
    orderBy?: crew_membersOrderByWithRelationInput | crew_membersOrderByWithRelationInput[]
    cursor?: crew_membersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Crew_membersScalarFieldEnum | Crew_membersScalarFieldEnum[]
  }

  /**
   * crews.work_order_crew
   */
  export type crews$work_order_crewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    where?: work_order_crewWhereInput
    orderBy?: work_order_crewOrderByWithRelationInput | work_order_crewOrderByWithRelationInput[]
    cursor?: work_order_crewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_order_crewScalarFieldEnum | Work_order_crewScalarFieldEnum[]
  }

  /**
   * crews without action
   */
  export type crewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crews
     */
    select?: crewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crews
     */
    omit?: crewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crewsInclude<ExtArgs> | null
  }


  /**
   * Model crew_members
   */

  export type AggregateCrew_members = {
    _count: Crew_membersCountAggregateOutputType | null
    _avg: Crew_membersAvgAggregateOutputType | null
    _sum: Crew_membersSumAggregateOutputType | null
    _min: Crew_membersMinAggregateOutputType | null
    _max: Crew_membersMaxAggregateOutputType | null
  }

  export type Crew_membersAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    crew_id: number | null
    user_id: number | null
  }

  export type Crew_membersSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    crew_id: bigint | null
    user_id: bigint | null
  }

  export type Crew_membersMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    crew_id: bigint | null
    user_id: bigint | null
    role: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Crew_membersMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    crew_id: bigint | null
    user_id: bigint | null
    role: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Crew_membersCountAggregateOutputType = {
    id: number
    organization_id: number
    crew_id: number
    user_id: number
    role: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Crew_membersAvgAggregateInputType = {
    id?: true
    organization_id?: true
    crew_id?: true
    user_id?: true
  }

  export type Crew_membersSumAggregateInputType = {
    id?: true
    organization_id?: true
    crew_id?: true
    user_id?: true
  }

  export type Crew_membersMinAggregateInputType = {
    id?: true
    organization_id?: true
    crew_id?: true
    user_id?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type Crew_membersMaxAggregateInputType = {
    id?: true
    organization_id?: true
    crew_id?: true
    user_id?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type Crew_membersCountAggregateInputType = {
    id?: true
    organization_id?: true
    crew_id?: true
    user_id?: true
    role?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Crew_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crew_members to aggregate.
     */
    where?: crew_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crew_members to fetch.
     */
    orderBy?: crew_membersOrderByWithRelationInput | crew_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: crew_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crew_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crew_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned crew_members
    **/
    _count?: true | Crew_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Crew_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Crew_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Crew_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Crew_membersMaxAggregateInputType
  }

  export type GetCrew_membersAggregateType<T extends Crew_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew_members[P]>
      : GetScalarType<T[P], AggregateCrew_members[P]>
  }




  export type crew_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: crew_membersWhereInput
    orderBy?: crew_membersOrderByWithAggregationInput | crew_membersOrderByWithAggregationInput[]
    by: Crew_membersScalarFieldEnum[] | Crew_membersScalarFieldEnum
    having?: crew_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Crew_membersCountAggregateInputType | true
    _avg?: Crew_membersAvgAggregateInputType
    _sum?: Crew_membersSumAggregateInputType
    _min?: Crew_membersMinAggregateInputType
    _max?: Crew_membersMaxAggregateInputType
  }

  export type Crew_membersGroupByOutputType = {
    id: bigint
    organization_id: bigint
    crew_id: bigint
    user_id: bigint
    role: string
    created_at: string
    updated_at: string
    _count: Crew_membersCountAggregateOutputType | null
    _avg: Crew_membersAvgAggregateOutputType | null
    _sum: Crew_membersSumAggregateOutputType | null
    _min: Crew_membersMinAggregateOutputType | null
    _max: Crew_membersMaxAggregateOutputType | null
  }

  type GetCrew_membersGroupByPayload<T extends crew_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Crew_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Crew_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Crew_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Crew_membersGroupByOutputType[P]>
        }
      >
    >


  export type crew_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    crew_id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew_members"]>

  export type crew_membersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    crew_id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew_members"]>

  export type crew_membersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    crew_id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew_members"]>

  export type crew_membersSelectScalar = {
    id?: boolean
    organization_id?: boolean
    crew_id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type crew_membersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "crew_id" | "user_id" | "role" | "created_at" | "updated_at", ExtArgs["result"]["crew_members"]>
  export type crew_membersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type crew_membersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type crew_membersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $crew_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "crew_members"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      crews: Prisma.$crewsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      crew_id: bigint
      user_id: bigint
      role: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["crew_members"]>
    composites: {}
  }

  type crew_membersGetPayload<S extends boolean | null | undefined | crew_membersDefaultArgs> = $Result.GetResult<Prisma.$crew_membersPayload, S>

  type crew_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<crew_membersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Crew_membersCountAggregateInputType | true
    }

  export interface crew_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['crew_members'], meta: { name: 'crew_members' } }
    /**
     * Find zero or one Crew_members that matches the filter.
     * @param {crew_membersFindUniqueArgs} args - Arguments to find a Crew_members
     * @example
     * // Get one Crew_members
     * const crew_members = await prisma.crew_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends crew_membersFindUniqueArgs>(args: SelectSubset<T, crew_membersFindUniqueArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crew_members that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {crew_membersFindUniqueOrThrowArgs} args - Arguments to find a Crew_members
     * @example
     * // Get one Crew_members
     * const crew_members = await prisma.crew_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends crew_membersFindUniqueOrThrowArgs>(args: SelectSubset<T, crew_membersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crew_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crew_membersFindFirstArgs} args - Arguments to find a Crew_members
     * @example
     * // Get one Crew_members
     * const crew_members = await prisma.crew_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends crew_membersFindFirstArgs>(args?: SelectSubset<T, crew_membersFindFirstArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crew_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crew_membersFindFirstOrThrowArgs} args - Arguments to find a Crew_members
     * @example
     * // Get one Crew_members
     * const crew_members = await prisma.crew_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends crew_membersFindFirstOrThrowArgs>(args?: SelectSubset<T, crew_membersFindFirstOrThrowArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crew_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crew_membersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crew_members
     * const crew_members = await prisma.crew_members.findMany()
     * 
     * // Get first 10 Crew_members
     * const crew_members = await prisma.crew_members.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crew_membersWithIdOnly = await prisma.crew_members.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends crew_membersFindManyArgs>(args?: SelectSubset<T, crew_membersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crew_members.
     * @param {crew_membersCreateArgs} args - Arguments to create a Crew_members.
     * @example
     * // Create one Crew_members
     * const Crew_members = await prisma.crew_members.create({
     *   data: {
     *     // ... data to create a Crew_members
     *   }
     * })
     * 
     */
    create<T extends crew_membersCreateArgs>(args: SelectSubset<T, crew_membersCreateArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crew_members.
     * @param {crew_membersCreateManyArgs} args - Arguments to create many Crew_members.
     * @example
     * // Create many Crew_members
     * const crew_members = await prisma.crew_members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends crew_membersCreateManyArgs>(args?: SelectSubset<T, crew_membersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crew_members and returns the data saved in the database.
     * @param {crew_membersCreateManyAndReturnArgs} args - Arguments to create many Crew_members.
     * @example
     * // Create many Crew_members
     * const crew_members = await prisma.crew_members.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crew_members and only return the `id`
     * const crew_membersWithIdOnly = await prisma.crew_members.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends crew_membersCreateManyAndReturnArgs>(args?: SelectSubset<T, crew_membersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crew_members.
     * @param {crew_membersDeleteArgs} args - Arguments to delete one Crew_members.
     * @example
     * // Delete one Crew_members
     * const Crew_members = await prisma.crew_members.delete({
     *   where: {
     *     // ... filter to delete one Crew_members
     *   }
     * })
     * 
     */
    delete<T extends crew_membersDeleteArgs>(args: SelectSubset<T, crew_membersDeleteArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crew_members.
     * @param {crew_membersUpdateArgs} args - Arguments to update one Crew_members.
     * @example
     * // Update one Crew_members
     * const crew_members = await prisma.crew_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends crew_membersUpdateArgs>(args: SelectSubset<T, crew_membersUpdateArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crew_members.
     * @param {crew_membersDeleteManyArgs} args - Arguments to filter Crew_members to delete.
     * @example
     * // Delete a few Crew_members
     * const { count } = await prisma.crew_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends crew_membersDeleteManyArgs>(args?: SelectSubset<T, crew_membersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crew_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crew_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crew_members
     * const crew_members = await prisma.crew_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends crew_membersUpdateManyArgs>(args: SelectSubset<T, crew_membersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crew_members and returns the data updated in the database.
     * @param {crew_membersUpdateManyAndReturnArgs} args - Arguments to update many Crew_members.
     * @example
     * // Update many Crew_members
     * const crew_members = await prisma.crew_members.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crew_members and only return the `id`
     * const crew_membersWithIdOnly = await prisma.crew_members.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends crew_membersUpdateManyAndReturnArgs>(args: SelectSubset<T, crew_membersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crew_members.
     * @param {crew_membersUpsertArgs} args - Arguments to update or create a Crew_members.
     * @example
     * // Update or create a Crew_members
     * const crew_members = await prisma.crew_members.upsert({
     *   create: {
     *     // ... data to create a Crew_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew_members we want to update
     *   }
     * })
     */
    upsert<T extends crew_membersUpsertArgs>(args: SelectSubset<T, crew_membersUpsertArgs<ExtArgs>>): Prisma__crew_membersClient<$Result.GetResult<Prisma.$crew_membersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crew_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crew_membersCountArgs} args - Arguments to filter Crew_members to count.
     * @example
     * // Count the number of Crew_members
     * const count = await prisma.crew_members.count({
     *   where: {
     *     // ... the filter for the Crew_members we want to count
     *   }
     * })
    **/
    count<T extends crew_membersCountArgs>(
      args?: Subset<T, crew_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Crew_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Crew_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Crew_membersAggregateArgs>(args: Subset<T, Crew_membersAggregateArgs>): Prisma.PrismaPromise<GetCrew_membersAggregateType<T>>

    /**
     * Group by Crew_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {crew_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends crew_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: crew_membersGroupByArgs['orderBy'] }
        : { orderBy?: crew_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, crew_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrew_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the crew_members model
   */
  readonly fields: crew_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for crew_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__crew_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    crews<T extends crewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, crewsDefaultArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the crew_members model
   */
  interface crew_membersFieldRefs {
    readonly id: FieldRef<"crew_members", 'BigInt'>
    readonly organization_id: FieldRef<"crew_members", 'BigInt'>
    readonly crew_id: FieldRef<"crew_members", 'BigInt'>
    readonly user_id: FieldRef<"crew_members", 'BigInt'>
    readonly role: FieldRef<"crew_members", 'String'>
    readonly created_at: FieldRef<"crew_members", 'String'>
    readonly updated_at: FieldRef<"crew_members", 'String'>
  }
    

  // Custom InputTypes
  /**
   * crew_members findUnique
   */
  export type crew_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * Filter, which crew_members to fetch.
     */
    where: crew_membersWhereUniqueInput
  }

  /**
   * crew_members findUniqueOrThrow
   */
  export type crew_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * Filter, which crew_members to fetch.
     */
    where: crew_membersWhereUniqueInput
  }

  /**
   * crew_members findFirst
   */
  export type crew_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * Filter, which crew_members to fetch.
     */
    where?: crew_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crew_members to fetch.
     */
    orderBy?: crew_membersOrderByWithRelationInput | crew_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crew_members.
     */
    cursor?: crew_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crew_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crew_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crew_members.
     */
    distinct?: Crew_membersScalarFieldEnum | Crew_membersScalarFieldEnum[]
  }

  /**
   * crew_members findFirstOrThrow
   */
  export type crew_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * Filter, which crew_members to fetch.
     */
    where?: crew_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crew_members to fetch.
     */
    orderBy?: crew_membersOrderByWithRelationInput | crew_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for crew_members.
     */
    cursor?: crew_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crew_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crew_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of crew_members.
     */
    distinct?: Crew_membersScalarFieldEnum | Crew_membersScalarFieldEnum[]
  }

  /**
   * crew_members findMany
   */
  export type crew_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * Filter, which crew_members to fetch.
     */
    where?: crew_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of crew_members to fetch.
     */
    orderBy?: crew_membersOrderByWithRelationInput | crew_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing crew_members.
     */
    cursor?: crew_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` crew_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` crew_members.
     */
    skip?: number
    distinct?: Crew_membersScalarFieldEnum | Crew_membersScalarFieldEnum[]
  }

  /**
   * crew_members create
   */
  export type crew_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * The data needed to create a crew_members.
     */
    data: XOR<crew_membersCreateInput, crew_membersUncheckedCreateInput>
  }

  /**
   * crew_members createMany
   */
  export type crew_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many crew_members.
     */
    data: crew_membersCreateManyInput | crew_membersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * crew_members createManyAndReturn
   */
  export type crew_membersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * The data used to create many crew_members.
     */
    data: crew_membersCreateManyInput | crew_membersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * crew_members update
   */
  export type crew_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * The data needed to update a crew_members.
     */
    data: XOR<crew_membersUpdateInput, crew_membersUncheckedUpdateInput>
    /**
     * Choose, which crew_members to update.
     */
    where: crew_membersWhereUniqueInput
  }

  /**
   * crew_members updateMany
   */
  export type crew_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update crew_members.
     */
    data: XOR<crew_membersUpdateManyMutationInput, crew_membersUncheckedUpdateManyInput>
    /**
     * Filter which crew_members to update
     */
    where?: crew_membersWhereInput
    /**
     * Limit how many crew_members to update.
     */
    limit?: number
  }

  /**
   * crew_members updateManyAndReturn
   */
  export type crew_membersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * The data used to update crew_members.
     */
    data: XOR<crew_membersUpdateManyMutationInput, crew_membersUncheckedUpdateManyInput>
    /**
     * Filter which crew_members to update
     */
    where?: crew_membersWhereInput
    /**
     * Limit how many crew_members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * crew_members upsert
   */
  export type crew_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * The filter to search for the crew_members to update in case it exists.
     */
    where: crew_membersWhereUniqueInput
    /**
     * In case the crew_members found by the `where` argument doesn't exist, create a new crew_members with this data.
     */
    create: XOR<crew_membersCreateInput, crew_membersUncheckedCreateInput>
    /**
     * In case the crew_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<crew_membersUpdateInput, crew_membersUncheckedUpdateInput>
  }

  /**
   * crew_members delete
   */
  export type crew_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
    /**
     * Filter which crew_members to delete.
     */
    where: crew_membersWhereUniqueInput
  }

  /**
   * crew_members deleteMany
   */
  export type crew_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which crew_members to delete
     */
    where?: crew_membersWhereInput
    /**
     * Limit how many crew_members to delete.
     */
    limit?: number
  }

  /**
   * crew_members without action
   */
  export type crew_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the crew_members
     */
    select?: crew_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the crew_members
     */
    omit?: crew_membersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: crew_membersInclude<ExtArgs> | null
  }


  /**
   * Model equipments
   */

  export type AggregateEquipments = {
    _count: EquipmentsCountAggregateOutputType | null
    _avg: EquipmentsAvgAggregateOutputType | null
    _sum: EquipmentsSumAggregateOutputType | null
    _min: EquipmentsMinAggregateOutputType | null
    _max: EquipmentsMaxAggregateOutputType | null
  }

  export type EquipmentsAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type EquipmentsSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
  }

  export type EquipmentsMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    equipment_type: string | null
    status: $Enums.EqupmentStatus | null
    location: string | null
    availability_date: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type EquipmentsMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    equipment_type: string | null
    status: $Enums.EqupmentStatus | null
    location: string | null
    availability_date: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type EquipmentsCountAggregateOutputType = {
    id: number
    organization_id: number
    name: number
    equipment_type: number
    status: number
    location: number
    availability_date: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EquipmentsAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type EquipmentsSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type EquipmentsMinAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    equipment_type?: true
    status?: true
    location?: true
    availability_date?: true
    created_at?: true
    updated_at?: true
  }

  export type EquipmentsMaxAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    equipment_type?: true
    status?: true
    location?: true
    availability_date?: true
    created_at?: true
    updated_at?: true
  }

  export type EquipmentsCountAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    equipment_type?: true
    status?: true
    location?: true
    availability_date?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EquipmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipments to aggregate.
     */
    where?: equipmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipments to fetch.
     */
    orderBy?: equipmentsOrderByWithRelationInput | equipmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipments
    **/
    _count?: true | EquipmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentsMaxAggregateInputType
  }

  export type GetEquipmentsAggregateType<T extends EquipmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipments[P]>
      : GetScalarType<T[P], AggregateEquipments[P]>
  }




  export type equipmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipmentsWhereInput
    orderBy?: equipmentsOrderByWithAggregationInput | equipmentsOrderByWithAggregationInput[]
    by: EquipmentsScalarFieldEnum[] | EquipmentsScalarFieldEnum
    having?: equipmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentsCountAggregateInputType | true
    _avg?: EquipmentsAvgAggregateInputType
    _sum?: EquipmentsSumAggregateInputType
    _min?: EquipmentsMinAggregateInputType
    _max?: EquipmentsMaxAggregateInputType
  }

  export type EquipmentsGroupByOutputType = {
    id: bigint
    organization_id: bigint
    name: string
    equipment_type: string
    status: $Enums.EqupmentStatus
    location: string
    availability_date: string
    created_at: string
    updated_at: string
    _count: EquipmentsCountAggregateOutputType | null
    _avg: EquipmentsAvgAggregateOutputType | null
    _sum: EquipmentsSumAggregateOutputType | null
    _min: EquipmentsMinAggregateOutputType | null
    _max: EquipmentsMaxAggregateOutputType | null
  }

  type GetEquipmentsGroupByPayload<T extends equipmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentsGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentsGroupByOutputType[P]>
        }
      >
    >


  export type equipmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    equipment_type?: boolean
    status?: boolean
    location?: boolean
    availability_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipments"]>

  export type equipmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    equipment_type?: boolean
    status?: boolean
    location?: boolean
    availability_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipments"]>

  export type equipmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    equipment_type?: boolean
    status?: boolean
    location?: boolean
    availability_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipments"]>

  export type equipmentsSelectScalar = {
    id?: boolean
    organization_id?: boolean
    name?: boolean
    equipment_type?: boolean
    status?: boolean
    location?: boolean
    availability_date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type equipmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "name" | "equipment_type" | "status" | "location" | "availability_date" | "created_at" | "updated_at", ExtArgs["result"]["equipments"]>
  export type equipmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type equipmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type equipmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $equipmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "equipments"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      name: string
      equipment_type: string
      status: $Enums.EqupmentStatus
      location: string
      availability_date: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["equipments"]>
    composites: {}
  }

  type equipmentsGetPayload<S extends boolean | null | undefined | equipmentsDefaultArgs> = $Result.GetResult<Prisma.$equipmentsPayload, S>

  type equipmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<equipmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentsCountAggregateInputType | true
    }

  export interface equipmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipments'], meta: { name: 'equipments' } }
    /**
     * Find zero or one Equipments that matches the filter.
     * @param {equipmentsFindUniqueArgs} args - Arguments to find a Equipments
     * @example
     * // Get one Equipments
     * const equipments = await prisma.equipments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends equipmentsFindUniqueArgs>(args: SelectSubset<T, equipmentsFindUniqueArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {equipmentsFindUniqueOrThrowArgs} args - Arguments to find a Equipments
     * @example
     * // Get one Equipments
     * const equipments = await prisma.equipments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends equipmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, equipmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentsFindFirstArgs} args - Arguments to find a Equipments
     * @example
     * // Get one Equipments
     * const equipments = await prisma.equipments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends equipmentsFindFirstArgs>(args?: SelectSubset<T, equipmentsFindFirstArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentsFindFirstOrThrowArgs} args - Arguments to find a Equipments
     * @example
     * // Get one Equipments
     * const equipments = await prisma.equipments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends equipmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, equipmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipments
     * const equipments = await prisma.equipments.findMany()
     * 
     * // Get first 10 Equipments
     * const equipments = await prisma.equipments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentsWithIdOnly = await prisma.equipments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends equipmentsFindManyArgs>(args?: SelectSubset<T, equipmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipments.
     * @param {equipmentsCreateArgs} args - Arguments to create a Equipments.
     * @example
     * // Create one Equipments
     * const Equipments = await prisma.equipments.create({
     *   data: {
     *     // ... data to create a Equipments
     *   }
     * })
     * 
     */
    create<T extends equipmentsCreateArgs>(args: SelectSubset<T, equipmentsCreateArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipments.
     * @param {equipmentsCreateManyArgs} args - Arguments to create many Equipments.
     * @example
     * // Create many Equipments
     * const equipments = await prisma.equipments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends equipmentsCreateManyArgs>(args?: SelectSubset<T, equipmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipments and returns the data saved in the database.
     * @param {equipmentsCreateManyAndReturnArgs} args - Arguments to create many Equipments.
     * @example
     * // Create many Equipments
     * const equipments = await prisma.equipments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipments and only return the `id`
     * const equipmentsWithIdOnly = await prisma.equipments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends equipmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, equipmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipments.
     * @param {equipmentsDeleteArgs} args - Arguments to delete one Equipments.
     * @example
     * // Delete one Equipments
     * const Equipments = await prisma.equipments.delete({
     *   where: {
     *     // ... filter to delete one Equipments
     *   }
     * })
     * 
     */
    delete<T extends equipmentsDeleteArgs>(args: SelectSubset<T, equipmentsDeleteArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipments.
     * @param {equipmentsUpdateArgs} args - Arguments to update one Equipments.
     * @example
     * // Update one Equipments
     * const equipments = await prisma.equipments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends equipmentsUpdateArgs>(args: SelectSubset<T, equipmentsUpdateArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipments.
     * @param {equipmentsDeleteManyArgs} args - Arguments to filter Equipments to delete.
     * @example
     * // Delete a few Equipments
     * const { count } = await prisma.equipments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends equipmentsDeleteManyArgs>(args?: SelectSubset<T, equipmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipments
     * const equipments = await prisma.equipments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends equipmentsUpdateManyArgs>(args: SelectSubset<T, equipmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipments and returns the data updated in the database.
     * @param {equipmentsUpdateManyAndReturnArgs} args - Arguments to update many Equipments.
     * @example
     * // Update many Equipments
     * const equipments = await prisma.equipments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipments and only return the `id`
     * const equipmentsWithIdOnly = await prisma.equipments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends equipmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, equipmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipments.
     * @param {equipmentsUpsertArgs} args - Arguments to update or create a Equipments.
     * @example
     * // Update or create a Equipments
     * const equipments = await prisma.equipments.upsert({
     *   create: {
     *     // ... data to create a Equipments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipments we want to update
     *   }
     * })
     */
    upsert<T extends equipmentsUpsertArgs>(args: SelectSubset<T, equipmentsUpsertArgs<ExtArgs>>): Prisma__equipmentsClient<$Result.GetResult<Prisma.$equipmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentsCountArgs} args - Arguments to filter Equipments to count.
     * @example
     * // Count the number of Equipments
     * const count = await prisma.equipments.count({
     *   where: {
     *     // ... the filter for the Equipments we want to count
     *   }
     * })
    **/
    count<T extends equipmentsCountArgs>(
      args?: Subset<T, equipmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentsAggregateArgs>(args: Subset<T, EquipmentsAggregateArgs>): Prisma.PrismaPromise<GetEquipmentsAggregateType<T>>

    /**
     * Group by Equipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipmentsGroupByArgs['orderBy'] }
        : { orderBy?: equipmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipments model
   */
  readonly fields: equipmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__equipmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the equipments model
   */
  interface equipmentsFieldRefs {
    readonly id: FieldRef<"equipments", 'BigInt'>
    readonly organization_id: FieldRef<"equipments", 'BigInt'>
    readonly name: FieldRef<"equipments", 'String'>
    readonly equipment_type: FieldRef<"equipments", 'String'>
    readonly status: FieldRef<"equipments", 'EqupmentStatus'>
    readonly location: FieldRef<"equipments", 'String'>
    readonly availability_date: FieldRef<"equipments", 'String'>
    readonly created_at: FieldRef<"equipments", 'String'>
    readonly updated_at: FieldRef<"equipments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * equipments findUnique
   */
  export type equipmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * Filter, which equipments to fetch.
     */
    where: equipmentsWhereUniqueInput
  }

  /**
   * equipments findUniqueOrThrow
   */
  export type equipmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * Filter, which equipments to fetch.
     */
    where: equipmentsWhereUniqueInput
  }

  /**
   * equipments findFirst
   */
  export type equipmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * Filter, which equipments to fetch.
     */
    where?: equipmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipments to fetch.
     */
    orderBy?: equipmentsOrderByWithRelationInput | equipmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipments.
     */
    cursor?: equipmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipments.
     */
    distinct?: EquipmentsScalarFieldEnum | EquipmentsScalarFieldEnum[]
  }

  /**
   * equipments findFirstOrThrow
   */
  export type equipmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * Filter, which equipments to fetch.
     */
    where?: equipmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipments to fetch.
     */
    orderBy?: equipmentsOrderByWithRelationInput | equipmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipments.
     */
    cursor?: equipmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipments.
     */
    distinct?: EquipmentsScalarFieldEnum | EquipmentsScalarFieldEnum[]
  }

  /**
   * equipments findMany
   */
  export type equipmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * Filter, which equipments to fetch.
     */
    where?: equipmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipments to fetch.
     */
    orderBy?: equipmentsOrderByWithRelationInput | equipmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipments.
     */
    cursor?: equipmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipments.
     */
    skip?: number
    distinct?: EquipmentsScalarFieldEnum | EquipmentsScalarFieldEnum[]
  }

  /**
   * equipments create
   */
  export type equipmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a equipments.
     */
    data: XOR<equipmentsCreateInput, equipmentsUncheckedCreateInput>
  }

  /**
   * equipments createMany
   */
  export type equipmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipments.
     */
    data: equipmentsCreateManyInput | equipmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * equipments createManyAndReturn
   */
  export type equipmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * The data used to create many equipments.
     */
    data: equipmentsCreateManyInput | equipmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipments update
   */
  export type equipmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a equipments.
     */
    data: XOR<equipmentsUpdateInput, equipmentsUncheckedUpdateInput>
    /**
     * Choose, which equipments to update.
     */
    where: equipmentsWhereUniqueInput
  }

  /**
   * equipments updateMany
   */
  export type equipmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipments.
     */
    data: XOR<equipmentsUpdateManyMutationInput, equipmentsUncheckedUpdateManyInput>
    /**
     * Filter which equipments to update
     */
    where?: equipmentsWhereInput
    /**
     * Limit how many equipments to update.
     */
    limit?: number
  }

  /**
   * equipments updateManyAndReturn
   */
  export type equipmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * The data used to update equipments.
     */
    data: XOR<equipmentsUpdateManyMutationInput, equipmentsUncheckedUpdateManyInput>
    /**
     * Filter which equipments to update
     */
    where?: equipmentsWhereInput
    /**
     * Limit how many equipments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipments upsert
   */
  export type equipmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the equipments to update in case it exists.
     */
    where: equipmentsWhereUniqueInput
    /**
     * In case the equipments found by the `where` argument doesn't exist, create a new equipments with this data.
     */
    create: XOR<equipmentsCreateInput, equipmentsUncheckedCreateInput>
    /**
     * In case the equipments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipmentsUpdateInput, equipmentsUncheckedUpdateInput>
  }

  /**
   * equipments delete
   */
  export type equipmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
    /**
     * Filter which equipments to delete.
     */
    where: equipmentsWhereUniqueInput
  }

  /**
   * equipments deleteMany
   */
  export type equipmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipments to delete
     */
    where?: equipmentsWhereInput
    /**
     * Limit how many equipments to delete.
     */
    limit?: number
  }

  /**
   * equipments without action
   */
  export type equipmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipments
     */
    select?: equipmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipments
     */
    omit?: equipmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipmentsInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    industry: string | null
    tax_id: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    industry: string | null
    tax_id: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    organization_id: number
    name: number
    industry: number
    tax_id: number
    address: number
    phone: number
    email: number
    website: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
    organization_id?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    industry?: true
    tax_id?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    industry?: true
    tax_id?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    industry?: true
    tax_id?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: bigint
    organization_id: bigint
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    industry?: boolean
    tax_id?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | companies$customersArgs<ExtArgs>
    work_orders?: boolean | companies$work_ordersArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    industry?: boolean
    tax_id?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    industry?: boolean
    tax_id?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    organization_id?: boolean
    name?: boolean
    industry?: boolean
    tax_id?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "name" | "industry" | "tax_id" | "address" | "phone" | "email" | "website" | "created_at" | "updated_at", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | companies$customersArgs<ExtArgs>
    work_orders?: boolean | companies$work_ordersArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      customers: Prisma.$customersPayload<ExtArgs>[]
      work_orders: Prisma.$work_ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      name: string
      industry: string
      tax_id: string
      address: string
      phone: string
      email: string
      website: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends companies$customersArgs<ExtArgs> = {}>(args?: Subset<T, companies$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_orders<T extends companies$work_ordersArgs<ExtArgs> = {}>(args?: Subset<T, companies$work_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'BigInt'>
    readonly organization_id: FieldRef<"companies", 'BigInt'>
    readonly name: FieldRef<"companies", 'String'>
    readonly industry: FieldRef<"companies", 'String'>
    readonly tax_id: FieldRef<"companies", 'String'>
    readonly address: FieldRef<"companies", 'String'>
    readonly phone: FieldRef<"companies", 'String'>
    readonly email: FieldRef<"companies", 'String'>
    readonly website: FieldRef<"companies", 'String'>
    readonly created_at: FieldRef<"companies", 'String'>
    readonly updated_at: FieldRef<"companies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.customers
   */
  export type companies$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    cursor?: customersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * companies.work_orders
   */
  export type companies$work_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    where?: work_ordersWhereInput
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    cursor?: work_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    company_id: number | null
    is_active: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    company_id: bigint | null
    is_active: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    company_id: bigint | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone: string | null
    address: string | null
    is_active: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    company_id: bigint | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone: string | null
    address: string | null
    is_active: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    organization_id: number
    company_id: number
    first_name: number
    last_name: number
    email: number
    phone: number
    address: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    organization_id?: true
    company_id?: true
    is_active?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    organization_id?: true
    company_id?: true
    is_active?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    organization_id?: true
    company_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    address?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    organization_id?: true
    company_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    address?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    organization_id?: true
    company_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    address?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to aggregate.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
    orderBy?: customersOrderByWithAggregationInput | customersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: customersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: bigint
    organization_id: bigint
    company_id: bigint
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active: number
    created_at: string
    updated_at: string
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends customersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    company_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | customers$assetsArgs<ExtArgs>
    work_orders?: boolean | customers$work_ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    company_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    company_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectScalar = {
    id?: boolean
    organization_id?: boolean
    company_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type customersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "company_id" | "first_name" | "last_name" | "email" | "phone" | "address" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["customers"]>
  export type customersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | customers$assetsArgs<ExtArgs>
    work_orders?: boolean | customers$work_ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type customersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customers"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      companies: Prisma.$companiesPayload<ExtArgs>
      assets: Prisma.$assetsPayload<ExtArgs>[]
      work_orders: Prisma.$work_ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      company_id: bigint
      first_name: string
      last_name: string
      email: string
      phone: string
      address: string
      is_active: number
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type customersGetPayload<S extends boolean | null | undefined | customersDefaultArgs> = $Result.GetResult<Prisma.$customersPayload, S>

  type customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface customersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customers'], meta: { name: 'customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {customersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customersFindUniqueArgs>(args: SelectSubset<T, customersFindUniqueArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customersFindUniqueOrThrowArgs>(args: SelectSubset<T, customersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customersFindFirstArgs>(args?: SelectSubset<T, customersFindFirstArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customersFindFirstOrThrowArgs>(args?: SelectSubset<T, customersFindFirstOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customersFindManyArgs>(args?: SelectSubset<T, customersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customers.
     * @param {customersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends customersCreateArgs>(args: SelectSubset<T, customersCreateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customersCreateManyArgs>(args?: SelectSubset<T, customersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customersCreateManyAndReturnArgs>(args?: SelectSubset<T, customersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customers.
     * @param {customersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends customersDeleteArgs>(args: SelectSubset<T, customersDeleteArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customers.
     * @param {customersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customersUpdateArgs>(args: SelectSubset<T, customersUpdateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customersDeleteManyArgs>(args?: SelectSubset<T, customersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customersUpdateManyArgs>(args: SelectSubset<T, customersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customersUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customersUpdateManyAndReturnArgs>(args: SelectSubset<T, customersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customers.
     * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends customersUpsertArgs>(args: SelectSubset<T, customersUpsertArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customersCountArgs>(
      args?: Subset<T, customersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customersGroupByArgs['orderBy'] }
        : { orderBy?: customersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customers model
   */
  readonly fields: customersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends customers$assetsArgs<ExtArgs> = {}>(args?: Subset<T, customers$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_orders<T extends customers$work_ordersArgs<ExtArgs> = {}>(args?: Subset<T, customers$work_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customers model
   */
  interface customersFieldRefs {
    readonly id: FieldRef<"customers", 'BigInt'>
    readonly organization_id: FieldRef<"customers", 'BigInt'>
    readonly company_id: FieldRef<"customers", 'BigInt'>
    readonly first_name: FieldRef<"customers", 'String'>
    readonly last_name: FieldRef<"customers", 'String'>
    readonly email: FieldRef<"customers", 'String'>
    readonly phone: FieldRef<"customers", 'String'>
    readonly address: FieldRef<"customers", 'String'>
    readonly is_active: FieldRef<"customers", 'Int'>
    readonly created_at: FieldRef<"customers", 'String'>
    readonly updated_at: FieldRef<"customers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * customers findUnique
   */
  export type customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findUniqueOrThrow
   */
  export type customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findFirst
   */
  export type customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findFirstOrThrow
   */
  export type customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findMany
   */
  export type customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers create
   */
  export type customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to create a customers.
     */
    data: XOR<customersCreateInput, customersUncheckedCreateInput>
  }

  /**
   * customers createMany
   */
  export type customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers createManyAndReturn
   */
  export type customersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * customers update
   */
  export type customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to update a customers.
     */
    data: XOR<customersUpdateInput, customersUncheckedUpdateInput>
    /**
     * Choose, which customers to update.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers updateMany
   */
  export type customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customers updateManyAndReturn
   */
  export type customersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * customers upsert
   */
  export type customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The filter to search for the customers to update in case it exists.
     */
    where: customersWhereUniqueInput
    /**
     * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
     */
    create: XOR<customersCreateInput, customersUncheckedCreateInput>
    /**
     * In case the customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customersUpdateInput, customersUncheckedUpdateInput>
  }

  /**
   * customers delete
   */
  export type customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter which customers to delete.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers deleteMany
   */
  export type customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customers.assets
   */
  export type customers$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    where?: assetsWhereInput
    orderBy?: assetsOrderByWithRelationInput | assetsOrderByWithRelationInput[]
    cursor?: assetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetsScalarFieldEnum | AssetsScalarFieldEnum[]
  }

  /**
   * customers.work_orders
   */
  export type customers$work_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    where?: work_ordersWhereInput
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    cursor?: work_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * customers without action
   */
  export type customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
  }


  /**
   * Model services
   */

  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    duration: number | null
    price: Decimal | null
  }

  export type ServicesSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    duration: number | null
    price: Decimal | null
  }

  export type ServicesMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    description: string | null
    duration: number | null
    price: Decimal | null
    created_at: string | null
    updated_at: string | null
  }

  export type ServicesMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    description: string | null
    duration: number | null
    price: Decimal | null
    created_at: string | null
    updated_at: string | null
  }

  export type ServicesCountAggregateOutputType = {
    id: number
    organization_id: number
    description: number
    duration: number
    price: number
    required_skills: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    id?: true
    organization_id?: true
    duration?: true
    price?: true
  }

  export type ServicesSumAggregateInputType = {
    id?: true
    organization_id?: true
    duration?: true
    price?: true
  }

  export type ServicesMinAggregateInputType = {
    id?: true
    organization_id?: true
    description?: true
    duration?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ServicesMaxAggregateInputType = {
    id?: true
    organization_id?: true
    description?: true
    duration?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ServicesCountAggregateInputType = {
    id?: true
    organization_id?: true
    description?: true
    duration?: true
    price?: true
    required_skills?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to aggregate.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type servicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicesWhereInput
    orderBy?: servicesOrderByWithAggregationInput | servicesOrderByWithAggregationInput[]
    by: ServicesScalarFieldEnum[] | ServicesScalarFieldEnum
    having?: servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }

  export type ServicesGroupByOutputType = {
    id: bigint
    organization_id: bigint
    description: string
    duration: number
    price: Decimal
    required_skills: JsonValue
    created_at: string
    updated_at: string
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type servicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    required_skills?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    work_order_services?: boolean | services$work_order_servicesArgs<ExtArgs>
    invoice_items?: boolean | services$invoice_itemsArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    required_skills?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    required_skills?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["services"]>

  export type servicesSelectScalar = {
    id?: boolean
    organization_id?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    required_skills?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type servicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "description" | "duration" | "price" | "required_skills" | "created_at" | "updated_at", ExtArgs["result"]["services"]>
  export type servicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    work_order_services?: boolean | services$work_order_servicesArgs<ExtArgs>
    invoice_items?: boolean | services$invoice_itemsArgs<ExtArgs>
    _count?: boolean | ServicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type servicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type servicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $servicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "services"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      work_order_services: Prisma.$work_order_servicesPayload<ExtArgs>[]
      invoice_items: Prisma.$invoice_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      description: string
      duration: number
      price: Prisma.Decimal
      required_skills: Prisma.JsonValue
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["services"]>
    composites: {}
  }

  type servicesGetPayload<S extends boolean | null | undefined | servicesDefaultArgs> = $Result.GetResult<Prisma.$servicesPayload, S>

  type servicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<servicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesCountAggregateInputType | true
    }

  export interface servicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['services'], meta: { name: 'services' } }
    /**
     * Find zero or one Services that matches the filter.
     * @param {servicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicesFindUniqueArgs>(args: SelectSubset<T, servicesFindUniqueArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Services that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {servicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicesFindUniqueOrThrowArgs>(args: SelectSubset<T, servicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicesFindFirstArgs>(args?: SelectSubset<T, servicesFindFirstArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Services that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicesFindFirstOrThrowArgs>(args?: SelectSubset<T, servicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWithIdOnly = await prisma.services.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends servicesFindManyArgs>(args?: SelectSubset<T, servicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Services.
     * @param {servicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
     */
    create<T extends servicesCreateArgs>(args: SelectSubset<T, servicesCreateArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {servicesCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicesCreateManyArgs>(args?: SelectSubset<T, servicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {servicesCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const services = await prisma.services.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends servicesCreateManyAndReturnArgs>(args?: SelectSubset<T, servicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Services.
     * @param {servicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
     */
    delete<T extends servicesDeleteArgs>(args: SelectSubset<T, servicesDeleteArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Services.
     * @param {servicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicesUpdateArgs>(args: SelectSubset<T, servicesUpdateArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {servicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicesDeleteManyArgs>(args?: SelectSubset<T, servicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicesUpdateManyArgs>(args: SelectSubset<T, servicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {servicesUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const servicesWithIdOnly = await prisma.services.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends servicesUpdateManyAndReturnArgs>(args: SelectSubset<T, servicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Services.
     * @param {servicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
     */
    upsert<T extends servicesUpsertArgs>(args: SelectSubset<T, servicesUpsertArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends servicesCountArgs>(
      args?: Subset<T, servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): Prisma.PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicesGroupByArgs['orderBy'] }
        : { orderBy?: servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the services model
   */
  readonly fields: servicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    work_order_services<T extends services$work_order_servicesArgs<ExtArgs> = {}>(args?: Subset<T, services$work_order_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice_items<T extends services$invoice_itemsArgs<ExtArgs> = {}>(args?: Subset<T, services$invoice_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the services model
   */
  interface servicesFieldRefs {
    readonly id: FieldRef<"services", 'BigInt'>
    readonly organization_id: FieldRef<"services", 'BigInt'>
    readonly description: FieldRef<"services", 'String'>
    readonly duration: FieldRef<"services", 'Int'>
    readonly price: FieldRef<"services", 'Decimal'>
    readonly required_skills: FieldRef<"services", 'Json'>
    readonly created_at: FieldRef<"services", 'String'>
    readonly updated_at: FieldRef<"services", 'String'>
  }
    

  // Custom InputTypes
  /**
   * services findUnique
   */
  export type servicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services findUniqueOrThrow
   */
  export type servicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services findFirst
   */
  export type servicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * services findFirstOrThrow
   */
  export type servicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * services findMany
   */
  export type servicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: servicesOrderByWithRelationInput | servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: ServicesScalarFieldEnum | ServicesScalarFieldEnum[]
  }

  /**
   * services create
   */
  export type servicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to create a services.
     */
    data: XOR<servicesCreateInput, servicesUncheckedCreateInput>
  }

  /**
   * services createMany
   */
  export type servicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many services.
     */
    data: servicesCreateManyInput | servicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * services createManyAndReturn
   */
  export type servicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * The data used to create many services.
     */
    data: servicesCreateManyInput | servicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * services update
   */
  export type servicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The data needed to update a services.
     */
    data: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
    /**
     * Choose, which services to update.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services updateMany
   */
  export type servicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update services.
     */
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: servicesWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
  }

  /**
   * services updateManyAndReturn
   */
  export type servicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * The data used to update services.
     */
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: servicesWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * services upsert
   */
  export type servicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * The filter to search for the services to update in case it exists.
     */
    where: servicesWhereUniqueInput
    /**
     * In case the services found by the `where` argument doesn't exist, create a new services with this data.
     */
    create: XOR<servicesCreateInput, servicesUncheckedCreateInput>
    /**
     * In case the services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
  }

  /**
   * services delete
   */
  export type servicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
    /**
     * Filter which services to delete.
     */
    where: servicesWhereUniqueInput
  }

  /**
   * services deleteMany
   */
  export type servicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to delete
     */
    where?: servicesWhereInput
    /**
     * Limit how many services to delete.
     */
    limit?: number
  }

  /**
   * services.work_order_services
   */
  export type services$work_order_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    where?: work_order_servicesWhereInput
    orderBy?: work_order_servicesOrderByWithRelationInput | work_order_servicesOrderByWithRelationInput[]
    cursor?: work_order_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_order_servicesScalarFieldEnum | Work_order_servicesScalarFieldEnum[]
  }

  /**
   * services.invoice_items
   */
  export type services$invoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    cursor?: invoice_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * services without action
   */
  export type servicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the services
     */
    select?: servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the services
     */
    omit?: servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicesInclude<ExtArgs> | null
  }


  /**
   * Model assets
   */

  export type AggregateAssets = {
    _count: AssetsCountAggregateOutputType | null
    _avg: AssetsAvgAggregateOutputType | null
    _sum: AssetsSumAggregateOutputType | null
    _min: AssetsMinAggregateOutputType | null
    _max: AssetsMaxAggregateOutputType | null
  }

  export type AssetsAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    customer_id: number | null
  }

  export type AssetsSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    customer_id: bigint | null
  }

  export type AssetsMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    customer_id: bigint | null
    asset_name: string | null
    serial_number: string | null
    model: string | null
    manufacturer: string | null
    status: $Enums.AssetStatus | null
    location: string | null
    notes: string | null
    purchase_date: string | null
    warranty_expiry: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type AssetsMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    customer_id: bigint | null
    asset_name: string | null
    serial_number: string | null
    model: string | null
    manufacturer: string | null
    status: $Enums.AssetStatus | null
    location: string | null
    notes: string | null
    purchase_date: string | null
    warranty_expiry: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type AssetsCountAggregateOutputType = {
    id: number
    organization_id: number
    customer_id: number
    asset_name: number
    serial_number: number
    model: number
    manufacturer: number
    status: number
    location: number
    notes: number
    purchase_date: number
    warranty_expiry: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AssetsAvgAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
  }

  export type AssetsSumAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
  }

  export type AssetsMinAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    asset_name?: true
    serial_number?: true
    model?: true
    manufacturer?: true
    status?: true
    location?: true
    notes?: true
    purchase_date?: true
    warranty_expiry?: true
    created_at?: true
    updated_at?: true
  }

  export type AssetsMaxAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    asset_name?: true
    serial_number?: true
    model?: true
    manufacturer?: true
    status?: true
    location?: true
    notes?: true
    purchase_date?: true
    warranty_expiry?: true
    created_at?: true
    updated_at?: true
  }

  export type AssetsCountAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    asset_name?: true
    serial_number?: true
    model?: true
    manufacturer?: true
    status?: true
    location?: true
    notes?: true
    purchase_date?: true
    warranty_expiry?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AssetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assets to aggregate.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: assetsOrderByWithRelationInput | assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assets
    **/
    _count?: true | AssetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetsMaxAggregateInputType
  }

  export type GetAssetsAggregateType<T extends AssetsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssets[P]>
      : GetScalarType<T[P], AggregateAssets[P]>
  }




  export type assetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assetsWhereInput
    orderBy?: assetsOrderByWithAggregationInput | assetsOrderByWithAggregationInput[]
    by: AssetsScalarFieldEnum[] | AssetsScalarFieldEnum
    having?: assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetsCountAggregateInputType | true
    _avg?: AssetsAvgAggregateInputType
    _sum?: AssetsSumAggregateInputType
    _min?: AssetsMinAggregateInputType
    _max?: AssetsMaxAggregateInputType
  }

  export type AssetsGroupByOutputType = {
    id: bigint
    organization_id: bigint
    customer_id: bigint
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    _count: AssetsCountAggregateOutputType | null
    _avg: AssetsAvgAggregateOutputType | null
    _sum: AssetsSumAggregateOutputType | null
    _min: AssetsMinAggregateOutputType | null
    _max: AssetsMaxAggregateOutputType | null
  }

  type GetAssetsGroupByPayload<T extends assetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetsGroupByOutputType[P]>
            : GetScalarType<T[P], AssetsGroupByOutputType[P]>
        }
      >
    >


  export type assetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    asset_name?: boolean
    serial_number?: boolean
    model?: boolean
    manufacturer?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    purchase_date?: boolean
    warranty_expiry?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    work_orders?: boolean | assets$work_ordersArgs<ExtArgs>
    _count?: boolean | AssetsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assets"]>

  export type assetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    asset_name?: boolean
    serial_number?: boolean
    model?: boolean
    manufacturer?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    purchase_date?: boolean
    warranty_expiry?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assets"]>

  export type assetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    asset_name?: boolean
    serial_number?: boolean
    model?: boolean
    manufacturer?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    purchase_date?: boolean
    warranty_expiry?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assets"]>

  export type assetsSelectScalar = {
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    asset_name?: boolean
    serial_number?: boolean
    model?: boolean
    manufacturer?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    purchase_date?: boolean
    warranty_expiry?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type assetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "customer_id" | "asset_name" | "serial_number" | "model" | "manufacturer" | "status" | "location" | "notes" | "purchase_date" | "warranty_expiry" | "created_at" | "updated_at", ExtArgs["result"]["assets"]>
  export type assetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    work_orders?: boolean | assets$work_ordersArgs<ExtArgs>
    _count?: boolean | AssetsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type assetsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
  }
  export type assetsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
  }

  export type $assetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assets"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      customers: Prisma.$customersPayload<ExtArgs>
      work_orders: Prisma.$work_ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      customer_id: bigint
      asset_name: string
      serial_number: string
      model: string
      manufacturer: string
      status: $Enums.AssetStatus
      location: string
      notes: string
      purchase_date: string
      warranty_expiry: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["assets"]>
    composites: {}
  }

  type assetsGetPayload<S extends boolean | null | undefined | assetsDefaultArgs> = $Result.GetResult<Prisma.$assetsPayload, S>

  type assetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<assetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetsCountAggregateInputType | true
    }

  export interface assetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assets'], meta: { name: 'assets' } }
    /**
     * Find zero or one Assets that matches the filter.
     * @param {assetsFindUniqueArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assetsFindUniqueArgs>(args: SelectSubset<T, assetsFindUniqueArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {assetsFindUniqueOrThrowArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assetsFindUniqueOrThrowArgs>(args: SelectSubset<T, assetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsFindFirstArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assetsFindFirstArgs>(args?: SelectSubset<T, assetsFindFirstArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsFindFirstOrThrowArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assetsFindFirstOrThrowArgs>(args?: SelectSubset<T, assetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.assets.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.assets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetsWithIdOnly = await prisma.assets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends assetsFindManyArgs>(args?: SelectSubset<T, assetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assets.
     * @param {assetsCreateArgs} args - Arguments to create a Assets.
     * @example
     * // Create one Assets
     * const Assets = await prisma.assets.create({
     *   data: {
     *     // ... data to create a Assets
     *   }
     * })
     * 
     */
    create<T extends assetsCreateArgs>(args: SelectSubset<T, assetsCreateArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {assetsCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const assets = await prisma.assets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assetsCreateManyArgs>(args?: SelectSubset<T, assetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {assetsCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const assets = await prisma.assets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetsWithIdOnly = await prisma.assets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends assetsCreateManyAndReturnArgs>(args?: SelectSubset<T, assetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assets.
     * @param {assetsDeleteArgs} args - Arguments to delete one Assets.
     * @example
     * // Delete one Assets
     * const Assets = await prisma.assets.delete({
     *   where: {
     *     // ... filter to delete one Assets
     *   }
     * })
     * 
     */
    delete<T extends assetsDeleteArgs>(args: SelectSubset<T, assetsDeleteArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assets.
     * @param {assetsUpdateArgs} args - Arguments to update one Assets.
     * @example
     * // Update one Assets
     * const assets = await prisma.assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assetsUpdateArgs>(args: SelectSubset<T, assetsUpdateArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {assetsDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assetsDeleteManyArgs>(args?: SelectSubset<T, assetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const assets = await prisma.assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assetsUpdateManyArgs>(args: SelectSubset<T, assetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {assetsUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const assets = await prisma.assets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assets and only return the `id`
     * const assetsWithIdOnly = await prisma.assets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends assetsUpdateManyAndReturnArgs>(args: SelectSubset<T, assetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assets.
     * @param {assetsUpsertArgs} args - Arguments to update or create a Assets.
     * @example
     * // Update or create a Assets
     * const assets = await prisma.assets.upsert({
     *   create: {
     *     // ... data to create a Assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assets we want to update
     *   }
     * })
     */
    upsert<T extends assetsUpsertArgs>(args: SelectSubset<T, assetsUpsertArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.assets.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends assetsCountArgs>(
      args?: Subset<T, assetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetsAggregateArgs>(args: Subset<T, AssetsAggregateArgs>): Prisma.PrismaPromise<GetAssetsAggregateType<T>>

    /**
     * Group by Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assetsGroupByArgs['orderBy'] }
        : { orderBy?: assetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assets model
   */
  readonly fields: assetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends customersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customersDefaultArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    work_orders<T extends assets$work_ordersArgs<ExtArgs> = {}>(args?: Subset<T, assets$work_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assets model
   */
  interface assetsFieldRefs {
    readonly id: FieldRef<"assets", 'BigInt'>
    readonly organization_id: FieldRef<"assets", 'BigInt'>
    readonly customer_id: FieldRef<"assets", 'BigInt'>
    readonly asset_name: FieldRef<"assets", 'String'>
    readonly serial_number: FieldRef<"assets", 'String'>
    readonly model: FieldRef<"assets", 'String'>
    readonly manufacturer: FieldRef<"assets", 'String'>
    readonly status: FieldRef<"assets", 'AssetStatus'>
    readonly location: FieldRef<"assets", 'String'>
    readonly notes: FieldRef<"assets", 'String'>
    readonly purchase_date: FieldRef<"assets", 'String'>
    readonly warranty_expiry: FieldRef<"assets", 'String'>
    readonly created_at: FieldRef<"assets", 'String'>
    readonly updated_at: FieldRef<"assets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * assets findUnique
   */
  export type assetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * Filter, which assets to fetch.
     */
    where: assetsWhereUniqueInput
  }

  /**
   * assets findUniqueOrThrow
   */
  export type assetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * Filter, which assets to fetch.
     */
    where: assetsWhereUniqueInput
  }

  /**
   * assets findFirst
   */
  export type assetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * Filter, which assets to fetch.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: assetsOrderByWithRelationInput | assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assets.
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assets.
     */
    distinct?: AssetsScalarFieldEnum | AssetsScalarFieldEnum[]
  }

  /**
   * assets findFirstOrThrow
   */
  export type assetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * Filter, which assets to fetch.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: assetsOrderByWithRelationInput | assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assets.
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assets.
     */
    distinct?: AssetsScalarFieldEnum | AssetsScalarFieldEnum[]
  }

  /**
   * assets findMany
   */
  export type assetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * Filter, which assets to fetch.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: assetsOrderByWithRelationInput | assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assets.
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    distinct?: AssetsScalarFieldEnum | AssetsScalarFieldEnum[]
  }

  /**
   * assets create
   */
  export type assetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * The data needed to create a assets.
     */
    data: XOR<assetsCreateInput, assetsUncheckedCreateInput>
  }

  /**
   * assets createMany
   */
  export type assetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assets.
     */
    data: assetsCreateManyInput | assetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assets createManyAndReturn
   */
  export type assetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * The data used to create many assets.
     */
    data: assetsCreateManyInput | assetsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * assets update
   */
  export type assetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * The data needed to update a assets.
     */
    data: XOR<assetsUpdateInput, assetsUncheckedUpdateInput>
    /**
     * Choose, which assets to update.
     */
    where: assetsWhereUniqueInput
  }

  /**
   * assets updateMany
   */
  export type assetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assets.
     */
    data: XOR<assetsUpdateManyMutationInput, assetsUncheckedUpdateManyInput>
    /**
     * Filter which assets to update
     */
    where?: assetsWhereInput
    /**
     * Limit how many assets to update.
     */
    limit?: number
  }

  /**
   * assets updateManyAndReturn
   */
  export type assetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * The data used to update assets.
     */
    data: XOR<assetsUpdateManyMutationInput, assetsUncheckedUpdateManyInput>
    /**
     * Filter which assets to update
     */
    where?: assetsWhereInput
    /**
     * Limit how many assets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * assets upsert
   */
  export type assetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * The filter to search for the assets to update in case it exists.
     */
    where: assetsWhereUniqueInput
    /**
     * In case the assets found by the `where` argument doesn't exist, create a new assets with this data.
     */
    create: XOR<assetsCreateInput, assetsUncheckedCreateInput>
    /**
     * In case the assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assetsUpdateInput, assetsUncheckedUpdateInput>
  }

  /**
   * assets delete
   */
  export type assetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
    /**
     * Filter which assets to delete.
     */
    where: assetsWhereUniqueInput
  }

  /**
   * assets deleteMany
   */
  export type assetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assets to delete
     */
    where?: assetsWhereInput
    /**
     * Limit how many assets to delete.
     */
    limit?: number
  }

  /**
   * assets.work_orders
   */
  export type assets$work_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    where?: work_ordersWhereInput
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    cursor?: work_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * assets without action
   */
  export type assetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assets
     */
    omit?: assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assetsInclude<ExtArgs> | null
  }


  /**
   * Model parts
   */

  export type AggregateParts = {
    _count: PartsCountAggregateOutputType | null
    _avg: PartsAvgAggregateOutputType | null
    _sum: PartsSumAggregateOutputType | null
    _min: PartsMinAggregateOutputType | null
    _max: PartsMaxAggregateOutputType | null
  }

  export type PartsAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    price: Decimal | null
    inventory_count: number | null
    reorder_level: number | null
  }

  export type PartsSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    price: Decimal | null
    inventory_count: number | null
    reorder_level: number | null
  }

  export type PartsMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    description: string | null
    price: Decimal | null
    inventory_count: number | null
    reorder_level: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type PartsMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    description: string | null
    price: Decimal | null
    inventory_count: number | null
    reorder_level: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type PartsCountAggregateOutputType = {
    id: number
    organization_id: number
    name: number
    description: number
    price: number
    inventory_count: number
    reorder_level: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PartsAvgAggregateInputType = {
    id?: true
    organization_id?: true
    price?: true
    inventory_count?: true
    reorder_level?: true
  }

  export type PartsSumAggregateInputType = {
    id?: true
    organization_id?: true
    price?: true
    inventory_count?: true
    reorder_level?: true
  }

  export type PartsMinAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    description?: true
    price?: true
    inventory_count?: true
    reorder_level?: true
    created_at?: true
    updated_at?: true
  }

  export type PartsMaxAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    description?: true
    price?: true
    inventory_count?: true
    reorder_level?: true
    created_at?: true
    updated_at?: true
  }

  export type PartsCountAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    description?: true
    price?: true
    inventory_count?: true
    reorder_level?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PartsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parts to aggregate.
     */
    where?: partsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parts to fetch.
     */
    orderBy?: partsOrderByWithRelationInput | partsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: partsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parts
    **/
    _count?: true | PartsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartsMaxAggregateInputType
  }

  export type GetPartsAggregateType<T extends PartsAggregateArgs> = {
        [P in keyof T & keyof AggregateParts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParts[P]>
      : GetScalarType<T[P], AggregateParts[P]>
  }




  export type partsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: partsWhereInput
    orderBy?: partsOrderByWithAggregationInput | partsOrderByWithAggregationInput[]
    by: PartsScalarFieldEnum[] | PartsScalarFieldEnum
    having?: partsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartsCountAggregateInputType | true
    _avg?: PartsAvgAggregateInputType
    _sum?: PartsSumAggregateInputType
    _min?: PartsMinAggregateInputType
    _max?: PartsMaxAggregateInputType
  }

  export type PartsGroupByOutputType = {
    id: bigint
    organization_id: bigint
    name: string
    description: string
    price: Decimal
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
    _count: PartsCountAggregateOutputType | null
    _avg: PartsAvgAggregateOutputType | null
    _sum: PartsSumAggregateOutputType | null
    _min: PartsMinAggregateOutputType | null
    _max: PartsMaxAggregateOutputType | null
  }

  type GetPartsGroupByPayload<T extends partsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartsGroupByOutputType[P]>
            : GetScalarType<T[P], PartsGroupByOutputType[P]>
        }
      >
    >


  export type partsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    inventory_count?: boolean
    reorder_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    invoice_items?: boolean | parts$invoice_itemsArgs<ExtArgs>
    _count?: boolean | PartsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parts"]>

  export type partsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    inventory_count?: boolean
    reorder_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parts"]>

  export type partsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    inventory_count?: boolean
    reorder_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parts"]>

  export type partsSelectScalar = {
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    inventory_count?: boolean
    reorder_level?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type partsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "name" | "description" | "price" | "inventory_count" | "reorder_level" | "created_at" | "updated_at", ExtArgs["result"]["parts"]>
  export type partsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    invoice_items?: boolean | parts$invoice_itemsArgs<ExtArgs>
    _count?: boolean | PartsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type partsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type partsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $partsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parts"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      invoice_items: Prisma.$invoice_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      name: string
      description: string
      price: Prisma.Decimal
      inventory_count: number
      reorder_level: number
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["parts"]>
    composites: {}
  }

  type partsGetPayload<S extends boolean | null | undefined | partsDefaultArgs> = $Result.GetResult<Prisma.$partsPayload, S>

  type partsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<partsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartsCountAggregateInputType | true
    }

  export interface partsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parts'], meta: { name: 'parts' } }
    /**
     * Find zero or one Parts that matches the filter.
     * @param {partsFindUniqueArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends partsFindUniqueArgs>(args: SelectSubset<T, partsFindUniqueArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {partsFindUniqueOrThrowArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends partsFindUniqueOrThrowArgs>(args: SelectSubset<T, partsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partsFindFirstArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends partsFindFirstArgs>(args?: SelectSubset<T, partsFindFirstArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partsFindFirstOrThrowArgs} args - Arguments to find a Parts
     * @example
     * // Get one Parts
     * const parts = await prisma.parts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends partsFindFirstOrThrowArgs>(args?: SelectSubset<T, partsFindFirstOrThrowArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parts
     * const parts = await prisma.parts.findMany()
     * 
     * // Get first 10 Parts
     * const parts = await prisma.parts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partsWithIdOnly = await prisma.parts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends partsFindManyArgs>(args?: SelectSubset<T, partsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parts.
     * @param {partsCreateArgs} args - Arguments to create a Parts.
     * @example
     * // Create one Parts
     * const Parts = await prisma.parts.create({
     *   data: {
     *     // ... data to create a Parts
     *   }
     * })
     * 
     */
    create<T extends partsCreateArgs>(args: SelectSubset<T, partsCreateArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parts.
     * @param {partsCreateManyArgs} args - Arguments to create many Parts.
     * @example
     * // Create many Parts
     * const parts = await prisma.parts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends partsCreateManyArgs>(args?: SelectSubset<T, partsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parts and returns the data saved in the database.
     * @param {partsCreateManyAndReturnArgs} args - Arguments to create many Parts.
     * @example
     * // Create many Parts
     * const parts = await prisma.parts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parts and only return the `id`
     * const partsWithIdOnly = await prisma.parts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends partsCreateManyAndReturnArgs>(args?: SelectSubset<T, partsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parts.
     * @param {partsDeleteArgs} args - Arguments to delete one Parts.
     * @example
     * // Delete one Parts
     * const Parts = await prisma.parts.delete({
     *   where: {
     *     // ... filter to delete one Parts
     *   }
     * })
     * 
     */
    delete<T extends partsDeleteArgs>(args: SelectSubset<T, partsDeleteArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parts.
     * @param {partsUpdateArgs} args - Arguments to update one Parts.
     * @example
     * // Update one Parts
     * const parts = await prisma.parts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends partsUpdateArgs>(args: SelectSubset<T, partsUpdateArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parts.
     * @param {partsDeleteManyArgs} args - Arguments to filter Parts to delete.
     * @example
     * // Delete a few Parts
     * const { count } = await prisma.parts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends partsDeleteManyArgs>(args?: SelectSubset<T, partsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parts
     * const parts = await prisma.parts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends partsUpdateManyArgs>(args: SelectSubset<T, partsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts and returns the data updated in the database.
     * @param {partsUpdateManyAndReturnArgs} args - Arguments to update many Parts.
     * @example
     * // Update many Parts
     * const parts = await prisma.parts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parts and only return the `id`
     * const partsWithIdOnly = await prisma.parts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends partsUpdateManyAndReturnArgs>(args: SelectSubset<T, partsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parts.
     * @param {partsUpsertArgs} args - Arguments to update or create a Parts.
     * @example
     * // Update or create a Parts
     * const parts = await prisma.parts.upsert({
     *   create: {
     *     // ... data to create a Parts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parts we want to update
     *   }
     * })
     */
    upsert<T extends partsUpsertArgs>(args: SelectSubset<T, partsUpsertArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partsCountArgs} args - Arguments to filter Parts to count.
     * @example
     * // Count the number of Parts
     * const count = await prisma.parts.count({
     *   where: {
     *     // ... the filter for the Parts we want to count
     *   }
     * })
    **/
    count<T extends partsCountArgs>(
      args?: Subset<T, partsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartsAggregateArgs>(args: Subset<T, PartsAggregateArgs>): Prisma.PrismaPromise<GetPartsAggregateType<T>>

    /**
     * Group by Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {partsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends partsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: partsGroupByArgs['orderBy'] }
        : { orderBy?: partsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, partsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parts model
   */
  readonly fields: partsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__partsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice_items<T extends parts$invoice_itemsArgs<ExtArgs> = {}>(args?: Subset<T, parts$invoice_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parts model
   */
  interface partsFieldRefs {
    readonly id: FieldRef<"parts", 'BigInt'>
    readonly organization_id: FieldRef<"parts", 'BigInt'>
    readonly name: FieldRef<"parts", 'String'>
    readonly description: FieldRef<"parts", 'String'>
    readonly price: FieldRef<"parts", 'Decimal'>
    readonly inventory_count: FieldRef<"parts", 'Int'>
    readonly reorder_level: FieldRef<"parts", 'Int'>
    readonly created_at: FieldRef<"parts", 'String'>
    readonly updated_at: FieldRef<"parts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * parts findUnique
   */
  export type partsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * Filter, which parts to fetch.
     */
    where: partsWhereUniqueInput
  }

  /**
   * parts findUniqueOrThrow
   */
  export type partsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * Filter, which parts to fetch.
     */
    where: partsWhereUniqueInput
  }

  /**
   * parts findFirst
   */
  export type partsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * Filter, which parts to fetch.
     */
    where?: partsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parts to fetch.
     */
    orderBy?: partsOrderByWithRelationInput | partsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parts.
     */
    cursor?: partsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parts.
     */
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * parts findFirstOrThrow
   */
  export type partsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * Filter, which parts to fetch.
     */
    where?: partsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parts to fetch.
     */
    orderBy?: partsOrderByWithRelationInput | partsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parts.
     */
    cursor?: partsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parts.
     */
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * parts findMany
   */
  export type partsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * Filter, which parts to fetch.
     */
    where?: partsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parts to fetch.
     */
    orderBy?: partsOrderByWithRelationInput | partsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parts.
     */
    cursor?: partsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parts.
     */
    skip?: number
    distinct?: PartsScalarFieldEnum | PartsScalarFieldEnum[]
  }

  /**
   * parts create
   */
  export type partsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * The data needed to create a parts.
     */
    data: XOR<partsCreateInput, partsUncheckedCreateInput>
  }

  /**
   * parts createMany
   */
  export type partsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parts.
     */
    data: partsCreateManyInput | partsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parts createManyAndReturn
   */
  export type partsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * The data used to create many parts.
     */
    data: partsCreateManyInput | partsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * parts update
   */
  export type partsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * The data needed to update a parts.
     */
    data: XOR<partsUpdateInput, partsUncheckedUpdateInput>
    /**
     * Choose, which parts to update.
     */
    where: partsWhereUniqueInput
  }

  /**
   * parts updateMany
   */
  export type partsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parts.
     */
    data: XOR<partsUpdateManyMutationInput, partsUncheckedUpdateManyInput>
    /**
     * Filter which parts to update
     */
    where?: partsWhereInput
    /**
     * Limit how many parts to update.
     */
    limit?: number
  }

  /**
   * parts updateManyAndReturn
   */
  export type partsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * The data used to update parts.
     */
    data: XOR<partsUpdateManyMutationInput, partsUncheckedUpdateManyInput>
    /**
     * Filter which parts to update
     */
    where?: partsWhereInput
    /**
     * Limit how many parts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * parts upsert
   */
  export type partsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * The filter to search for the parts to update in case it exists.
     */
    where: partsWhereUniqueInput
    /**
     * In case the parts found by the `where` argument doesn't exist, create a new parts with this data.
     */
    create: XOR<partsCreateInput, partsUncheckedCreateInput>
    /**
     * In case the parts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<partsUpdateInput, partsUncheckedUpdateInput>
  }

  /**
   * parts delete
   */
  export type partsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
    /**
     * Filter which parts to delete.
     */
    where: partsWhereUniqueInput
  }

  /**
   * parts deleteMany
   */
  export type partsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parts to delete
     */
    where?: partsWhereInput
    /**
     * Limit how many parts to delete.
     */
    limit?: number
  }

  /**
   * parts.invoice_items
   */
  export type parts$invoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    cursor?: invoice_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * parts without action
   */
  export type partsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parts
     */
    select?: partsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parts
     */
    omit?: partsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: partsInclude<ExtArgs> | null
  }


  /**
   * Model maintenance_plans
   */

  export type AggregateMaintenance_plans = {
    _count: Maintenance_plansCountAggregateOutputType | null
    _avg: Maintenance_plansAvgAggregateOutputType | null
    _sum: Maintenance_plansSumAggregateOutputType | null
    _min: Maintenance_plansMinAggregateOutputType | null
    _max: Maintenance_plansMaxAggregateOutputType | null
  }

  export type Maintenance_plansAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    frequency_unit: number | null
    is_active: number | null
  }

  export type Maintenance_plansSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    frequency_unit: number | null
    is_active: number | null
  }

  export type Maintenance_plansMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    description: string | null
    start_date: string | null
    end_date: string | null
    frequency: $Enums.Frequency | null
    frequency_unit: number | null
    frequency_unit_type: $Enums.FrequencyUnitType | null
    is_active: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type Maintenance_plansMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    name: string | null
    description: string | null
    start_date: string | null
    end_date: string | null
    frequency: $Enums.Frequency | null
    frequency_unit: number | null
    frequency_unit_type: $Enums.FrequencyUnitType | null
    is_active: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type Maintenance_plansCountAggregateOutputType = {
    id: number
    organization_id: number
    name: number
    description: number
    start_date: number
    end_date: number
    frequency: number
    frequency_unit: number
    frequency_unit_type: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Maintenance_plansAvgAggregateInputType = {
    id?: true
    organization_id?: true
    frequency_unit?: true
    is_active?: true
  }

  export type Maintenance_plansSumAggregateInputType = {
    id?: true
    organization_id?: true
    frequency_unit?: true
    is_active?: true
  }

  export type Maintenance_plansMinAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    description?: true
    start_date?: true
    end_date?: true
    frequency?: true
    frequency_unit?: true
    frequency_unit_type?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Maintenance_plansMaxAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    description?: true
    start_date?: true
    end_date?: true
    frequency?: true
    frequency_unit?: true
    frequency_unit_type?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Maintenance_plansCountAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    description?: true
    start_date?: true
    end_date?: true
    frequency?: true
    frequency_unit?: true
    frequency_unit_type?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Maintenance_plansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maintenance_plans to aggregate.
     */
    where?: maintenance_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plans to fetch.
     */
    orderBy?: maintenance_plansOrderByWithRelationInput | maintenance_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: maintenance_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned maintenance_plans
    **/
    _count?: true | Maintenance_plansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Maintenance_plansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Maintenance_plansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Maintenance_plansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Maintenance_plansMaxAggregateInputType
  }

  export type GetMaintenance_plansAggregateType<T extends Maintenance_plansAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance_plans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance_plans[P]>
      : GetScalarType<T[P], AggregateMaintenance_plans[P]>
  }




  export type maintenance_plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maintenance_plansWhereInput
    orderBy?: maintenance_plansOrderByWithAggregationInput | maintenance_plansOrderByWithAggregationInput[]
    by: Maintenance_plansScalarFieldEnum[] | Maintenance_plansScalarFieldEnum
    having?: maintenance_plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Maintenance_plansCountAggregateInputType | true
    _avg?: Maintenance_plansAvgAggregateInputType
    _sum?: Maintenance_plansSumAggregateInputType
    _min?: Maintenance_plansMinAggregateInputType
    _max?: Maintenance_plansMaxAggregateInputType
  }

  export type Maintenance_plansGroupByOutputType = {
    id: bigint
    organization_id: bigint
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    _count: Maintenance_plansCountAggregateOutputType | null
    _avg: Maintenance_plansAvgAggregateOutputType | null
    _sum: Maintenance_plansSumAggregateOutputType | null
    _min: Maintenance_plansMinAggregateOutputType | null
    _max: Maintenance_plansMaxAggregateOutputType | null
  }

  type GetMaintenance_plansGroupByPayload<T extends maintenance_plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Maintenance_plansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Maintenance_plansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Maintenance_plansGroupByOutputType[P]>
            : GetScalarType<T[P], Maintenance_plansGroupByOutputType[P]>
        }
      >
    >


  export type maintenance_plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    frequency?: boolean
    frequency_unit?: boolean
    frequency_unit_type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    maintenance_plan_assets?: boolean | maintenance_plans$maintenance_plan_assetsArgs<ExtArgs>
    work_orders?: boolean | maintenance_plans$work_ordersArgs<ExtArgs>
    _count?: boolean | Maintenance_plansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance_plans"]>

  export type maintenance_plansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    frequency?: boolean
    frequency_unit?: boolean
    frequency_unit_type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance_plans"]>

  export type maintenance_plansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    frequency?: boolean
    frequency_unit?: boolean
    frequency_unit_type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance_plans"]>

  export type maintenance_plansSelectScalar = {
    id?: boolean
    organization_id?: boolean
    name?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    frequency?: boolean
    frequency_unit?: boolean
    frequency_unit_type?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type maintenance_plansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "name" | "description" | "start_date" | "end_date" | "frequency" | "frequency_unit" | "frequency_unit_type" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["maintenance_plans"]>
  export type maintenance_plansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    maintenance_plan_assets?: boolean | maintenance_plans$maintenance_plan_assetsArgs<ExtArgs>
    work_orders?: boolean | maintenance_plans$work_ordersArgs<ExtArgs>
    _count?: boolean | Maintenance_plansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type maintenance_plansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }
  export type maintenance_plansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
  }

  export type $maintenance_plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "maintenance_plans"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      maintenance_plan_assets: Prisma.$maintenance_plan_assetsPayload<ExtArgs>[]
      work_orders: Prisma.$work_ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      name: string
      description: string
      start_date: string
      end_date: string
      frequency: $Enums.Frequency
      frequency_unit: number
      frequency_unit_type: $Enums.FrequencyUnitType
      is_active: number
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["maintenance_plans"]>
    composites: {}
  }

  type maintenance_plansGetPayload<S extends boolean | null | undefined | maintenance_plansDefaultArgs> = $Result.GetResult<Prisma.$maintenance_plansPayload, S>

  type maintenance_plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<maintenance_plansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Maintenance_plansCountAggregateInputType | true
    }

  export interface maintenance_plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['maintenance_plans'], meta: { name: 'maintenance_plans' } }
    /**
     * Find zero or one Maintenance_plans that matches the filter.
     * @param {maintenance_plansFindUniqueArgs} args - Arguments to find a Maintenance_plans
     * @example
     * // Get one Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends maintenance_plansFindUniqueArgs>(args: SelectSubset<T, maintenance_plansFindUniqueArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance_plans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {maintenance_plansFindUniqueOrThrowArgs} args - Arguments to find a Maintenance_plans
     * @example
     * // Get one Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends maintenance_plansFindUniqueOrThrowArgs>(args: SelectSubset<T, maintenance_plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plansFindFirstArgs} args - Arguments to find a Maintenance_plans
     * @example
     * // Get one Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends maintenance_plansFindFirstArgs>(args?: SelectSubset<T, maintenance_plansFindFirstArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance_plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plansFindFirstOrThrowArgs} args - Arguments to find a Maintenance_plans
     * @example
     * // Get one Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends maintenance_plansFindFirstOrThrowArgs>(args?: SelectSubset<T, maintenance_plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenance_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.findMany()
     * 
     * // Get first 10 Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenance_plansWithIdOnly = await prisma.maintenance_plans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends maintenance_plansFindManyArgs>(args?: SelectSubset<T, maintenance_plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance_plans.
     * @param {maintenance_plansCreateArgs} args - Arguments to create a Maintenance_plans.
     * @example
     * // Create one Maintenance_plans
     * const Maintenance_plans = await prisma.maintenance_plans.create({
     *   data: {
     *     // ... data to create a Maintenance_plans
     *   }
     * })
     * 
     */
    create<T extends maintenance_plansCreateArgs>(args: SelectSubset<T, maintenance_plansCreateArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenance_plans.
     * @param {maintenance_plansCreateManyArgs} args - Arguments to create many Maintenance_plans.
     * @example
     * // Create many Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends maintenance_plansCreateManyArgs>(args?: SelectSubset<T, maintenance_plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintenance_plans and returns the data saved in the database.
     * @param {maintenance_plansCreateManyAndReturnArgs} args - Arguments to create many Maintenance_plans.
     * @example
     * // Create many Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintenance_plans and only return the `id`
     * const maintenance_plansWithIdOnly = await prisma.maintenance_plans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends maintenance_plansCreateManyAndReturnArgs>(args?: SelectSubset<T, maintenance_plansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maintenance_plans.
     * @param {maintenance_plansDeleteArgs} args - Arguments to delete one Maintenance_plans.
     * @example
     * // Delete one Maintenance_plans
     * const Maintenance_plans = await prisma.maintenance_plans.delete({
     *   where: {
     *     // ... filter to delete one Maintenance_plans
     *   }
     * })
     * 
     */
    delete<T extends maintenance_plansDeleteArgs>(args: SelectSubset<T, maintenance_plansDeleteArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance_plans.
     * @param {maintenance_plansUpdateArgs} args - Arguments to update one Maintenance_plans.
     * @example
     * // Update one Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends maintenance_plansUpdateArgs>(args: SelectSubset<T, maintenance_plansUpdateArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenance_plans.
     * @param {maintenance_plansDeleteManyArgs} args - Arguments to filter Maintenance_plans to delete.
     * @example
     * // Delete a few Maintenance_plans
     * const { count } = await prisma.maintenance_plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends maintenance_plansDeleteManyArgs>(args?: SelectSubset<T, maintenance_plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenance_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends maintenance_plansUpdateManyArgs>(args: SelectSubset<T, maintenance_plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenance_plans and returns the data updated in the database.
     * @param {maintenance_plansUpdateManyAndReturnArgs} args - Arguments to update many Maintenance_plans.
     * @example
     * // Update many Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintenance_plans and only return the `id`
     * const maintenance_plansWithIdOnly = await prisma.maintenance_plans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends maintenance_plansUpdateManyAndReturnArgs>(args: SelectSubset<T, maintenance_plansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maintenance_plans.
     * @param {maintenance_plansUpsertArgs} args - Arguments to update or create a Maintenance_plans.
     * @example
     * // Update or create a Maintenance_plans
     * const maintenance_plans = await prisma.maintenance_plans.upsert({
     *   create: {
     *     // ... data to create a Maintenance_plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance_plans we want to update
     *   }
     * })
     */
    upsert<T extends maintenance_plansUpsertArgs>(args: SelectSubset<T, maintenance_plansUpsertArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenance_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plansCountArgs} args - Arguments to filter Maintenance_plans to count.
     * @example
     * // Count the number of Maintenance_plans
     * const count = await prisma.maintenance_plans.count({
     *   where: {
     *     // ... the filter for the Maintenance_plans we want to count
     *   }
     * })
    **/
    count<T extends maintenance_plansCountArgs>(
      args?: Subset<T, maintenance_plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Maintenance_plansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Maintenance_plansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Maintenance_plansAggregateArgs>(args: Subset<T, Maintenance_plansAggregateArgs>): Prisma.PrismaPromise<GetMaintenance_plansAggregateType<T>>

    /**
     * Group by Maintenance_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends maintenance_plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: maintenance_plansGroupByArgs['orderBy'] }
        : { orderBy?: maintenance_plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, maintenance_plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenance_plansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the maintenance_plans model
   */
  readonly fields: maintenance_plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for maintenance_plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__maintenance_plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maintenance_plan_assets<T extends maintenance_plans$maintenance_plan_assetsArgs<ExtArgs> = {}>(args?: Subset<T, maintenance_plans$maintenance_plan_assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_orders<T extends maintenance_plans$work_ordersArgs<ExtArgs> = {}>(args?: Subset<T, maintenance_plans$work_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the maintenance_plans model
   */
  interface maintenance_plansFieldRefs {
    readonly id: FieldRef<"maintenance_plans", 'BigInt'>
    readonly organization_id: FieldRef<"maintenance_plans", 'BigInt'>
    readonly name: FieldRef<"maintenance_plans", 'String'>
    readonly description: FieldRef<"maintenance_plans", 'String'>
    readonly start_date: FieldRef<"maintenance_plans", 'String'>
    readonly end_date: FieldRef<"maintenance_plans", 'String'>
    readonly frequency: FieldRef<"maintenance_plans", 'Frequency'>
    readonly frequency_unit: FieldRef<"maintenance_plans", 'Int'>
    readonly frequency_unit_type: FieldRef<"maintenance_plans", 'FrequencyUnitType'>
    readonly is_active: FieldRef<"maintenance_plans", 'Int'>
    readonly created_at: FieldRef<"maintenance_plans", 'String'>
    readonly updated_at: FieldRef<"maintenance_plans", 'String'>
  }
    

  // Custom InputTypes
  /**
   * maintenance_plans findUnique
   */
  export type maintenance_plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plans to fetch.
     */
    where: maintenance_plansWhereUniqueInput
  }

  /**
   * maintenance_plans findUniqueOrThrow
   */
  export type maintenance_plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plans to fetch.
     */
    where: maintenance_plansWhereUniqueInput
  }

  /**
   * maintenance_plans findFirst
   */
  export type maintenance_plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plans to fetch.
     */
    where?: maintenance_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plans to fetch.
     */
    orderBy?: maintenance_plansOrderByWithRelationInput | maintenance_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maintenance_plans.
     */
    cursor?: maintenance_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maintenance_plans.
     */
    distinct?: Maintenance_plansScalarFieldEnum | Maintenance_plansScalarFieldEnum[]
  }

  /**
   * maintenance_plans findFirstOrThrow
   */
  export type maintenance_plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plans to fetch.
     */
    where?: maintenance_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plans to fetch.
     */
    orderBy?: maintenance_plansOrderByWithRelationInput | maintenance_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maintenance_plans.
     */
    cursor?: maintenance_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maintenance_plans.
     */
    distinct?: Maintenance_plansScalarFieldEnum | Maintenance_plansScalarFieldEnum[]
  }

  /**
   * maintenance_plans findMany
   */
  export type maintenance_plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plans to fetch.
     */
    where?: maintenance_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plans to fetch.
     */
    orderBy?: maintenance_plansOrderByWithRelationInput | maintenance_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing maintenance_plans.
     */
    cursor?: maintenance_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plans.
     */
    skip?: number
    distinct?: Maintenance_plansScalarFieldEnum | Maintenance_plansScalarFieldEnum[]
  }

  /**
   * maintenance_plans create
   */
  export type maintenance_plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * The data needed to create a maintenance_plans.
     */
    data: XOR<maintenance_plansCreateInput, maintenance_plansUncheckedCreateInput>
  }

  /**
   * maintenance_plans createMany
   */
  export type maintenance_plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many maintenance_plans.
     */
    data: maintenance_plansCreateManyInput | maintenance_plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * maintenance_plans createManyAndReturn
   */
  export type maintenance_plansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * The data used to create many maintenance_plans.
     */
    data: maintenance_plansCreateManyInput | maintenance_plansCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * maintenance_plans update
   */
  export type maintenance_plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * The data needed to update a maintenance_plans.
     */
    data: XOR<maintenance_plansUpdateInput, maintenance_plansUncheckedUpdateInput>
    /**
     * Choose, which maintenance_plans to update.
     */
    where: maintenance_plansWhereUniqueInput
  }

  /**
   * maintenance_plans updateMany
   */
  export type maintenance_plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update maintenance_plans.
     */
    data: XOR<maintenance_plansUpdateManyMutationInput, maintenance_plansUncheckedUpdateManyInput>
    /**
     * Filter which maintenance_plans to update
     */
    where?: maintenance_plansWhereInput
    /**
     * Limit how many maintenance_plans to update.
     */
    limit?: number
  }

  /**
   * maintenance_plans updateManyAndReturn
   */
  export type maintenance_plansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * The data used to update maintenance_plans.
     */
    data: XOR<maintenance_plansUpdateManyMutationInput, maintenance_plansUncheckedUpdateManyInput>
    /**
     * Filter which maintenance_plans to update
     */
    where?: maintenance_plansWhereInput
    /**
     * Limit how many maintenance_plans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * maintenance_plans upsert
   */
  export type maintenance_plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * The filter to search for the maintenance_plans to update in case it exists.
     */
    where: maintenance_plansWhereUniqueInput
    /**
     * In case the maintenance_plans found by the `where` argument doesn't exist, create a new maintenance_plans with this data.
     */
    create: XOR<maintenance_plansCreateInput, maintenance_plansUncheckedCreateInput>
    /**
     * In case the maintenance_plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<maintenance_plansUpdateInput, maintenance_plansUncheckedUpdateInput>
  }

  /**
   * maintenance_plans delete
   */
  export type maintenance_plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
    /**
     * Filter which maintenance_plans to delete.
     */
    where: maintenance_plansWhereUniqueInput
  }

  /**
   * maintenance_plans deleteMany
   */
  export type maintenance_plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maintenance_plans to delete
     */
    where?: maintenance_plansWhereInput
    /**
     * Limit how many maintenance_plans to delete.
     */
    limit?: number
  }

  /**
   * maintenance_plans.maintenance_plan_assets
   */
  export type maintenance_plans$maintenance_plan_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    where?: maintenance_plan_assetsWhereInput
    orderBy?: maintenance_plan_assetsOrderByWithRelationInput | maintenance_plan_assetsOrderByWithRelationInput[]
    cursor?: maintenance_plan_assetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Maintenance_plan_assetsScalarFieldEnum | Maintenance_plan_assetsScalarFieldEnum[]
  }

  /**
   * maintenance_plans.work_orders
   */
  export type maintenance_plans$work_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    where?: work_ordersWhereInput
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    cursor?: work_ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * maintenance_plans without action
   */
  export type maintenance_plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plans
     */
    select?: maintenance_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plans
     */
    omit?: maintenance_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plansInclude<ExtArgs> | null
  }


  /**
   * Model maintenance_plan_assets
   */

  export type AggregateMaintenance_plan_assets = {
    _count: Maintenance_plan_assetsCountAggregateOutputType | null
    _avg: Maintenance_plan_assetsAvgAggregateOutputType | null
    _sum: Maintenance_plan_assetsSumAggregateOutputType | null
    _min: Maintenance_plan_assetsMinAggregateOutputType | null
    _max: Maintenance_plan_assetsMaxAggregateOutputType | null
  }

  export type Maintenance_plan_assetsAvgAggregateOutputType = {
    id: number | null
    maintenance_plan_id: number | null
    asset_id: number | null
  }

  export type Maintenance_plan_assetsSumAggregateOutputType = {
    id: bigint | null
    maintenance_plan_id: bigint | null
    asset_id: bigint | null
  }

  export type Maintenance_plan_assetsMinAggregateOutputType = {
    id: bigint | null
    maintenance_plan_id: bigint | null
    asset_id: bigint | null
    assigned_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Maintenance_plan_assetsMaxAggregateOutputType = {
    id: bigint | null
    maintenance_plan_id: bigint | null
    asset_id: bigint | null
    assigned_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Maintenance_plan_assetsCountAggregateOutputType = {
    id: number
    maintenance_plan_id: number
    asset_id: number
    assigned_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Maintenance_plan_assetsAvgAggregateInputType = {
    id?: true
    maintenance_plan_id?: true
    asset_id?: true
  }

  export type Maintenance_plan_assetsSumAggregateInputType = {
    id?: true
    maintenance_plan_id?: true
    asset_id?: true
  }

  export type Maintenance_plan_assetsMinAggregateInputType = {
    id?: true
    maintenance_plan_id?: true
    asset_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Maintenance_plan_assetsMaxAggregateInputType = {
    id?: true
    maintenance_plan_id?: true
    asset_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Maintenance_plan_assetsCountAggregateInputType = {
    id?: true
    maintenance_plan_id?: true
    asset_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Maintenance_plan_assetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maintenance_plan_assets to aggregate.
     */
    where?: maintenance_plan_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plan_assets to fetch.
     */
    orderBy?: maintenance_plan_assetsOrderByWithRelationInput | maintenance_plan_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: maintenance_plan_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plan_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plan_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned maintenance_plan_assets
    **/
    _count?: true | Maintenance_plan_assetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Maintenance_plan_assetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Maintenance_plan_assetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Maintenance_plan_assetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Maintenance_plan_assetsMaxAggregateInputType
  }

  export type GetMaintenance_plan_assetsAggregateType<T extends Maintenance_plan_assetsAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance_plan_assets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance_plan_assets[P]>
      : GetScalarType<T[P], AggregateMaintenance_plan_assets[P]>
  }




  export type maintenance_plan_assetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maintenance_plan_assetsWhereInput
    orderBy?: maintenance_plan_assetsOrderByWithAggregationInput | maintenance_plan_assetsOrderByWithAggregationInput[]
    by: Maintenance_plan_assetsScalarFieldEnum[] | Maintenance_plan_assetsScalarFieldEnum
    having?: maintenance_plan_assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Maintenance_plan_assetsCountAggregateInputType | true
    _avg?: Maintenance_plan_assetsAvgAggregateInputType
    _sum?: Maintenance_plan_assetsSumAggregateInputType
    _min?: Maintenance_plan_assetsMinAggregateInputType
    _max?: Maintenance_plan_assetsMaxAggregateInputType
  }

  export type Maintenance_plan_assetsGroupByOutputType = {
    id: bigint
    maintenance_plan_id: bigint
    asset_id: bigint
    assigned_at: string
    created_at: string
    updated_at: string
    _count: Maintenance_plan_assetsCountAggregateOutputType | null
    _avg: Maintenance_plan_assetsAvgAggregateOutputType | null
    _sum: Maintenance_plan_assetsSumAggregateOutputType | null
    _min: Maintenance_plan_assetsMinAggregateOutputType | null
    _max: Maintenance_plan_assetsMaxAggregateOutputType | null
  }

  type GetMaintenance_plan_assetsGroupByPayload<T extends maintenance_plan_assetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Maintenance_plan_assetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Maintenance_plan_assetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Maintenance_plan_assetsGroupByOutputType[P]>
            : GetScalarType<T[P], Maintenance_plan_assetsGroupByOutputType[P]>
        }
      >
    >


  export type maintenance_plan_assetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maintenance_plan_id?: boolean
    asset_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance_plan_assets"]>

  export type maintenance_plan_assetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maintenance_plan_id?: boolean
    asset_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance_plan_assets"]>

  export type maintenance_plan_assetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maintenance_plan_id?: boolean
    asset_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance_plan_assets"]>

  export type maintenance_plan_assetsSelectScalar = {
    id?: boolean
    maintenance_plan_id?: boolean
    asset_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type maintenance_plan_assetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "maintenance_plan_id" | "asset_id" | "assigned_at" | "created_at" | "updated_at", ExtArgs["result"]["maintenance_plan_assets"]>
  export type maintenance_plan_assetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }
  export type maintenance_plan_assetsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }
  export type maintenance_plan_assetsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }

  export type $maintenance_plan_assetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "maintenance_plan_assets"
    objects: {
      maintenance_plans: Prisma.$maintenance_plansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      maintenance_plan_id: bigint
      asset_id: bigint
      assigned_at: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["maintenance_plan_assets"]>
    composites: {}
  }

  type maintenance_plan_assetsGetPayload<S extends boolean | null | undefined | maintenance_plan_assetsDefaultArgs> = $Result.GetResult<Prisma.$maintenance_plan_assetsPayload, S>

  type maintenance_plan_assetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<maintenance_plan_assetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Maintenance_plan_assetsCountAggregateInputType | true
    }

  export interface maintenance_plan_assetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['maintenance_plan_assets'], meta: { name: 'maintenance_plan_assets' } }
    /**
     * Find zero or one Maintenance_plan_assets that matches the filter.
     * @param {maintenance_plan_assetsFindUniqueArgs} args - Arguments to find a Maintenance_plan_assets
     * @example
     * // Get one Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends maintenance_plan_assetsFindUniqueArgs>(args: SelectSubset<T, maintenance_plan_assetsFindUniqueArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance_plan_assets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {maintenance_plan_assetsFindUniqueOrThrowArgs} args - Arguments to find a Maintenance_plan_assets
     * @example
     * // Get one Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends maintenance_plan_assetsFindUniqueOrThrowArgs>(args: SelectSubset<T, maintenance_plan_assetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance_plan_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plan_assetsFindFirstArgs} args - Arguments to find a Maintenance_plan_assets
     * @example
     * // Get one Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends maintenance_plan_assetsFindFirstArgs>(args?: SelectSubset<T, maintenance_plan_assetsFindFirstArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance_plan_assets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plan_assetsFindFirstOrThrowArgs} args - Arguments to find a Maintenance_plan_assets
     * @example
     * // Get one Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends maintenance_plan_assetsFindFirstOrThrowArgs>(args?: SelectSubset<T, maintenance_plan_assetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenance_plan_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plan_assetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.findMany()
     * 
     * // Get first 10 Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenance_plan_assetsWithIdOnly = await prisma.maintenance_plan_assets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends maintenance_plan_assetsFindManyArgs>(args?: SelectSubset<T, maintenance_plan_assetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance_plan_assets.
     * @param {maintenance_plan_assetsCreateArgs} args - Arguments to create a Maintenance_plan_assets.
     * @example
     * // Create one Maintenance_plan_assets
     * const Maintenance_plan_assets = await prisma.maintenance_plan_assets.create({
     *   data: {
     *     // ... data to create a Maintenance_plan_assets
     *   }
     * })
     * 
     */
    create<T extends maintenance_plan_assetsCreateArgs>(args: SelectSubset<T, maintenance_plan_assetsCreateArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenance_plan_assets.
     * @param {maintenance_plan_assetsCreateManyArgs} args - Arguments to create many Maintenance_plan_assets.
     * @example
     * // Create many Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends maintenance_plan_assetsCreateManyArgs>(args?: SelectSubset<T, maintenance_plan_assetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintenance_plan_assets and returns the data saved in the database.
     * @param {maintenance_plan_assetsCreateManyAndReturnArgs} args - Arguments to create many Maintenance_plan_assets.
     * @example
     * // Create many Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintenance_plan_assets and only return the `id`
     * const maintenance_plan_assetsWithIdOnly = await prisma.maintenance_plan_assets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends maintenance_plan_assetsCreateManyAndReturnArgs>(args?: SelectSubset<T, maintenance_plan_assetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maintenance_plan_assets.
     * @param {maintenance_plan_assetsDeleteArgs} args - Arguments to delete one Maintenance_plan_assets.
     * @example
     * // Delete one Maintenance_plan_assets
     * const Maintenance_plan_assets = await prisma.maintenance_plan_assets.delete({
     *   where: {
     *     // ... filter to delete one Maintenance_plan_assets
     *   }
     * })
     * 
     */
    delete<T extends maintenance_plan_assetsDeleteArgs>(args: SelectSubset<T, maintenance_plan_assetsDeleteArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance_plan_assets.
     * @param {maintenance_plan_assetsUpdateArgs} args - Arguments to update one Maintenance_plan_assets.
     * @example
     * // Update one Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends maintenance_plan_assetsUpdateArgs>(args: SelectSubset<T, maintenance_plan_assetsUpdateArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenance_plan_assets.
     * @param {maintenance_plan_assetsDeleteManyArgs} args - Arguments to filter Maintenance_plan_assets to delete.
     * @example
     * // Delete a few Maintenance_plan_assets
     * const { count } = await prisma.maintenance_plan_assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends maintenance_plan_assetsDeleteManyArgs>(args?: SelectSubset<T, maintenance_plan_assetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenance_plan_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plan_assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends maintenance_plan_assetsUpdateManyArgs>(args: SelectSubset<T, maintenance_plan_assetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenance_plan_assets and returns the data updated in the database.
     * @param {maintenance_plan_assetsUpdateManyAndReturnArgs} args - Arguments to update many Maintenance_plan_assets.
     * @example
     * // Update many Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintenance_plan_assets and only return the `id`
     * const maintenance_plan_assetsWithIdOnly = await prisma.maintenance_plan_assets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends maintenance_plan_assetsUpdateManyAndReturnArgs>(args: SelectSubset<T, maintenance_plan_assetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maintenance_plan_assets.
     * @param {maintenance_plan_assetsUpsertArgs} args - Arguments to update or create a Maintenance_plan_assets.
     * @example
     * // Update or create a Maintenance_plan_assets
     * const maintenance_plan_assets = await prisma.maintenance_plan_assets.upsert({
     *   create: {
     *     // ... data to create a Maintenance_plan_assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance_plan_assets we want to update
     *   }
     * })
     */
    upsert<T extends maintenance_plan_assetsUpsertArgs>(args: SelectSubset<T, maintenance_plan_assetsUpsertArgs<ExtArgs>>): Prisma__maintenance_plan_assetsClient<$Result.GetResult<Prisma.$maintenance_plan_assetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenance_plan_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plan_assetsCountArgs} args - Arguments to filter Maintenance_plan_assets to count.
     * @example
     * // Count the number of Maintenance_plan_assets
     * const count = await prisma.maintenance_plan_assets.count({
     *   where: {
     *     // ... the filter for the Maintenance_plan_assets we want to count
     *   }
     * })
    **/
    count<T extends maintenance_plan_assetsCountArgs>(
      args?: Subset<T, maintenance_plan_assetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Maintenance_plan_assetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance_plan_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Maintenance_plan_assetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Maintenance_plan_assetsAggregateArgs>(args: Subset<T, Maintenance_plan_assetsAggregateArgs>): Prisma.PrismaPromise<GetMaintenance_plan_assetsAggregateType<T>>

    /**
     * Group by Maintenance_plan_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maintenance_plan_assetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends maintenance_plan_assetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: maintenance_plan_assetsGroupByArgs['orderBy'] }
        : { orderBy?: maintenance_plan_assetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, maintenance_plan_assetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenance_plan_assetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the maintenance_plan_assets model
   */
  readonly fields: maintenance_plan_assetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for maintenance_plan_assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__maintenance_plan_assetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenance_plans<T extends maintenance_plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, maintenance_plansDefaultArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the maintenance_plan_assets model
   */
  interface maintenance_plan_assetsFieldRefs {
    readonly id: FieldRef<"maintenance_plan_assets", 'BigInt'>
    readonly maintenance_plan_id: FieldRef<"maintenance_plan_assets", 'BigInt'>
    readonly asset_id: FieldRef<"maintenance_plan_assets", 'BigInt'>
    readonly assigned_at: FieldRef<"maintenance_plan_assets", 'String'>
    readonly created_at: FieldRef<"maintenance_plan_assets", 'String'>
    readonly updated_at: FieldRef<"maintenance_plan_assets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * maintenance_plan_assets findUnique
   */
  export type maintenance_plan_assetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plan_assets to fetch.
     */
    where: maintenance_plan_assetsWhereUniqueInput
  }

  /**
   * maintenance_plan_assets findUniqueOrThrow
   */
  export type maintenance_plan_assetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plan_assets to fetch.
     */
    where: maintenance_plan_assetsWhereUniqueInput
  }

  /**
   * maintenance_plan_assets findFirst
   */
  export type maintenance_plan_assetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plan_assets to fetch.
     */
    where?: maintenance_plan_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plan_assets to fetch.
     */
    orderBy?: maintenance_plan_assetsOrderByWithRelationInput | maintenance_plan_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maintenance_plan_assets.
     */
    cursor?: maintenance_plan_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plan_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plan_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maintenance_plan_assets.
     */
    distinct?: Maintenance_plan_assetsScalarFieldEnum | Maintenance_plan_assetsScalarFieldEnum[]
  }

  /**
   * maintenance_plan_assets findFirstOrThrow
   */
  export type maintenance_plan_assetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plan_assets to fetch.
     */
    where?: maintenance_plan_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plan_assets to fetch.
     */
    orderBy?: maintenance_plan_assetsOrderByWithRelationInput | maintenance_plan_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maintenance_plan_assets.
     */
    cursor?: maintenance_plan_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plan_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plan_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maintenance_plan_assets.
     */
    distinct?: Maintenance_plan_assetsScalarFieldEnum | Maintenance_plan_assetsScalarFieldEnum[]
  }

  /**
   * maintenance_plan_assets findMany
   */
  export type maintenance_plan_assetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * Filter, which maintenance_plan_assets to fetch.
     */
    where?: maintenance_plan_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maintenance_plan_assets to fetch.
     */
    orderBy?: maintenance_plan_assetsOrderByWithRelationInput | maintenance_plan_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing maintenance_plan_assets.
     */
    cursor?: maintenance_plan_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maintenance_plan_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maintenance_plan_assets.
     */
    skip?: number
    distinct?: Maintenance_plan_assetsScalarFieldEnum | Maintenance_plan_assetsScalarFieldEnum[]
  }

  /**
   * maintenance_plan_assets create
   */
  export type maintenance_plan_assetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * The data needed to create a maintenance_plan_assets.
     */
    data: XOR<maintenance_plan_assetsCreateInput, maintenance_plan_assetsUncheckedCreateInput>
  }

  /**
   * maintenance_plan_assets createMany
   */
  export type maintenance_plan_assetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many maintenance_plan_assets.
     */
    data: maintenance_plan_assetsCreateManyInput | maintenance_plan_assetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * maintenance_plan_assets createManyAndReturn
   */
  export type maintenance_plan_assetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * The data used to create many maintenance_plan_assets.
     */
    data: maintenance_plan_assetsCreateManyInput | maintenance_plan_assetsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * maintenance_plan_assets update
   */
  export type maintenance_plan_assetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * The data needed to update a maintenance_plan_assets.
     */
    data: XOR<maintenance_plan_assetsUpdateInput, maintenance_plan_assetsUncheckedUpdateInput>
    /**
     * Choose, which maintenance_plan_assets to update.
     */
    where: maintenance_plan_assetsWhereUniqueInput
  }

  /**
   * maintenance_plan_assets updateMany
   */
  export type maintenance_plan_assetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update maintenance_plan_assets.
     */
    data: XOR<maintenance_plan_assetsUpdateManyMutationInput, maintenance_plan_assetsUncheckedUpdateManyInput>
    /**
     * Filter which maintenance_plan_assets to update
     */
    where?: maintenance_plan_assetsWhereInput
    /**
     * Limit how many maintenance_plan_assets to update.
     */
    limit?: number
  }

  /**
   * maintenance_plan_assets updateManyAndReturn
   */
  export type maintenance_plan_assetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * The data used to update maintenance_plan_assets.
     */
    data: XOR<maintenance_plan_assetsUpdateManyMutationInput, maintenance_plan_assetsUncheckedUpdateManyInput>
    /**
     * Filter which maintenance_plan_assets to update
     */
    where?: maintenance_plan_assetsWhereInput
    /**
     * Limit how many maintenance_plan_assets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * maintenance_plan_assets upsert
   */
  export type maintenance_plan_assetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * The filter to search for the maintenance_plan_assets to update in case it exists.
     */
    where: maintenance_plan_assetsWhereUniqueInput
    /**
     * In case the maintenance_plan_assets found by the `where` argument doesn't exist, create a new maintenance_plan_assets with this data.
     */
    create: XOR<maintenance_plan_assetsCreateInput, maintenance_plan_assetsUncheckedCreateInput>
    /**
     * In case the maintenance_plan_assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<maintenance_plan_assetsUpdateInput, maintenance_plan_assetsUncheckedUpdateInput>
  }

  /**
   * maintenance_plan_assets delete
   */
  export type maintenance_plan_assetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
    /**
     * Filter which maintenance_plan_assets to delete.
     */
    where: maintenance_plan_assetsWhereUniqueInput
  }

  /**
   * maintenance_plan_assets deleteMany
   */
  export type maintenance_plan_assetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maintenance_plan_assets to delete
     */
    where?: maintenance_plan_assetsWhereInput
    /**
     * Limit how many maintenance_plan_assets to delete.
     */
    limit?: number
  }

  /**
   * maintenance_plan_assets without action
   */
  export type maintenance_plan_assetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maintenance_plan_assets
     */
    select?: maintenance_plan_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maintenance_plan_assets
     */
    omit?: maintenance_plan_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maintenance_plan_assetsInclude<ExtArgs> | null
  }


  /**
   * Model work_orders
   */

  export type AggregateWork_orders = {
    _count: Work_ordersCountAggregateOutputType | null
    _avg: Work_ordersAvgAggregateOutputType | null
    _sum: Work_ordersSumAggregateOutputType | null
    _min: Work_ordersMinAggregateOutputType | null
    _max: Work_ordersMaxAggregateOutputType | null
  }

  export type Work_ordersAvgAggregateOutputType = {
    id: number | null
    organization_id: number | null
    customer_id: number | null
    company_id: number | null
    asset_id: number | null
    maintenance_plan_id: number | null
    assigned_crew_id: number | null
    currency_id: number | null
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
    is_multi_day: number | null
  }

  export type Work_ordersSumAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    customer_id: bigint | null
    company_id: bigint | null
    asset_id: bigint | null
    maintenance_plan_id: bigint | null
    assigned_crew_id: number | null
    currency_id: number | null
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
    is_multi_day: number | null
  }

  export type Work_ordersMinAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    customer_id: bigint | null
    company_id: bigint | null
    asset_id: bigint | null
    maintenance_plan_id: bigint | null
    title: string | null
    description: string | null
    priority: $Enums.Prioirty | null
    status: $Enums.WorkOrderStatus | null
    assigned_to: string | null
    assigned_crew_id: number | null
    scheduled_start_date: string | null
    scheduled_end_date: string | null
    actual_start_date: string | null
    actual_end_date: string | null
    currency_id: number | null
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
    address: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_multi_day: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_ordersMaxAggregateOutputType = {
    id: bigint | null
    organization_id: bigint | null
    customer_id: bigint | null
    company_id: bigint | null
    asset_id: bigint | null
    maintenance_plan_id: bigint | null
    title: string | null
    description: string | null
    priority: $Enums.Prioirty | null
    status: $Enums.WorkOrderStatus | null
    assigned_to: string | null
    assigned_crew_id: number | null
    scheduled_start_date: string | null
    scheduled_end_date: string | null
    actual_start_date: string | null
    actual_end_date: string | null
    currency_id: number | null
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
    address: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_multi_day: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_ordersCountAggregateOutputType = {
    id: number
    organization_id: number
    customer_id: number
    company_id: number
    asset_id: number
    maintenance_plan_id: number
    title: number
    description: number
    priority: number
    status: number
    assigned_to: number
    assigned_crew_id: number
    scheduled_start_date: number
    scheduled_end_date: number
    actual_start_date: number
    actual_end_date: number
    currency_id: number
    estimated_cost: number
    actual_cost: number
    address: number
    city: number
    state: number
    postal_code: number
    country: number
    is_multi_day: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Work_ordersAvgAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    company_id?: true
    asset_id?: true
    maintenance_plan_id?: true
    assigned_crew_id?: true
    currency_id?: true
    estimated_cost?: true
    actual_cost?: true
    is_multi_day?: true
  }

  export type Work_ordersSumAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    company_id?: true
    asset_id?: true
    maintenance_plan_id?: true
    assigned_crew_id?: true
    currency_id?: true
    estimated_cost?: true
    actual_cost?: true
    is_multi_day?: true
  }

  export type Work_ordersMinAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    company_id?: true
    asset_id?: true
    maintenance_plan_id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    assigned_to?: true
    assigned_crew_id?: true
    scheduled_start_date?: true
    scheduled_end_date?: true
    actual_start_date?: true
    actual_end_date?: true
    currency_id?: true
    estimated_cost?: true
    actual_cost?: true
    address?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_multi_day?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_ordersMaxAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    company_id?: true
    asset_id?: true
    maintenance_plan_id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    assigned_to?: true
    assigned_crew_id?: true
    scheduled_start_date?: true
    scheduled_end_date?: true
    actual_start_date?: true
    actual_end_date?: true
    currency_id?: true
    estimated_cost?: true
    actual_cost?: true
    address?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_multi_day?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_ordersCountAggregateInputType = {
    id?: true
    organization_id?: true
    customer_id?: true
    company_id?: true
    asset_id?: true
    maintenance_plan_id?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    assigned_to?: true
    assigned_crew_id?: true
    scheduled_start_date?: true
    scheduled_end_date?: true
    actual_start_date?: true
    actual_end_date?: true
    currency_id?: true
    estimated_cost?: true
    actual_cost?: true
    address?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_multi_day?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Work_ordersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_orders to aggregate.
     */
    where?: work_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_orders to fetch.
     */
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: work_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned work_orders
    **/
    _count?: true | Work_ordersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Work_ordersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Work_ordersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Work_ordersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Work_ordersMaxAggregateInputType
  }

  export type GetWork_ordersAggregateType<T extends Work_ordersAggregateArgs> = {
        [P in keyof T & keyof AggregateWork_orders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork_orders[P]>
      : GetScalarType<T[P], AggregateWork_orders[P]>
  }




  export type work_ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_ordersWhereInput
    orderBy?: work_ordersOrderByWithAggregationInput | work_ordersOrderByWithAggregationInput[]
    by: Work_ordersScalarFieldEnum[] | Work_ordersScalarFieldEnum
    having?: work_ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Work_ordersCountAggregateInputType | true
    _avg?: Work_ordersAvgAggregateInputType
    _sum?: Work_ordersSumAggregateInputType
    _min?: Work_ordersMinAggregateInputType
    _max?: Work_ordersMaxAggregateInputType
  }

  export type Work_ordersGroupByOutputType = {
    id: bigint
    organization_id: bigint
    customer_id: bigint
    company_id: bigint
    asset_id: bigint
    maintenance_plan_id: bigint
    title: string
    description: string
    priority: $Enums.Prioirty
    status: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal
    actual_cost: Decimal
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    _count: Work_ordersCountAggregateOutputType | null
    _avg: Work_ordersAvgAggregateOutputType | null
    _sum: Work_ordersSumAggregateOutputType | null
    _min: Work_ordersMinAggregateOutputType | null
    _max: Work_ordersMaxAggregateOutputType | null
  }

  type GetWork_ordersGroupByPayload<T extends work_ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Work_ordersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Work_ordersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Work_ordersGroupByOutputType[P]>
            : GetScalarType<T[P], Work_ordersGroupByOutputType[P]>
        }
      >
    >


  export type work_ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    company_id?: boolean
    asset_id?: boolean
    maintenance_plan_id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assigned_to?: boolean
    assigned_crew_id?: boolean
    scheduled_start_date?: boolean
    scheduled_end_date?: boolean
    actual_start_date?: boolean
    actual_end_date?: boolean
    currency_id?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_multi_day?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | assetsDefaultArgs<ExtArgs>
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
    work_order_services?: boolean | work_orders$work_order_servicesArgs<ExtArgs>
    work_order_tasks?: boolean | work_orders$work_order_tasksArgs<ExtArgs>
    work_order_assets?: boolean | work_orders$work_order_assetsArgs<ExtArgs>
    work_order_crew?: boolean | work_orders$work_order_crewArgs<ExtArgs>
    work_order_approvals?: boolean | work_orders$work_order_approvalsArgs<ExtArgs>
    invoices?: boolean | work_orders$invoicesArgs<ExtArgs>
    _count?: boolean | Work_ordersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_orders"]>

  export type work_ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    company_id?: boolean
    asset_id?: boolean
    maintenance_plan_id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assigned_to?: boolean
    assigned_crew_id?: boolean
    scheduled_start_date?: boolean
    scheduled_end_date?: boolean
    actual_start_date?: boolean
    actual_end_date?: boolean
    currency_id?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_multi_day?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | assetsDefaultArgs<ExtArgs>
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_orders"]>

  export type work_ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    company_id?: boolean
    asset_id?: boolean
    maintenance_plan_id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assigned_to?: boolean
    assigned_crew_id?: boolean
    scheduled_start_date?: boolean
    scheduled_end_date?: boolean
    actual_start_date?: boolean
    actual_end_date?: boolean
    currency_id?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_multi_day?: boolean
    created_at?: boolean
    updated_at?: boolean
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | assetsDefaultArgs<ExtArgs>
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_orders"]>

  export type work_ordersSelectScalar = {
    id?: boolean
    organization_id?: boolean
    customer_id?: boolean
    company_id?: boolean
    asset_id?: boolean
    maintenance_plan_id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assigned_to?: boolean
    assigned_crew_id?: boolean
    scheduled_start_date?: boolean
    scheduled_end_date?: boolean
    actual_start_date?: boolean
    actual_end_date?: boolean
    currency_id?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_multi_day?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type work_ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "customer_id" | "company_id" | "asset_id" | "maintenance_plan_id" | "title" | "description" | "priority" | "status" | "assigned_to" | "assigned_crew_id" | "scheduled_start_date" | "scheduled_end_date" | "actual_start_date" | "actual_end_date" | "currency_id" | "estimated_cost" | "actual_cost" | "address" | "city" | "state" | "postal_code" | "country" | "is_multi_day" | "created_at" | "updated_at", ExtArgs["result"]["work_orders"]>
  export type work_ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | assetsDefaultArgs<ExtArgs>
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
    work_order_services?: boolean | work_orders$work_order_servicesArgs<ExtArgs>
    work_order_tasks?: boolean | work_orders$work_order_tasksArgs<ExtArgs>
    work_order_assets?: boolean | work_orders$work_order_assetsArgs<ExtArgs>
    work_order_crew?: boolean | work_orders$work_order_crewArgs<ExtArgs>
    work_order_approvals?: boolean | work_orders$work_order_approvalsArgs<ExtArgs>
    invoices?: boolean | work_orders$invoicesArgs<ExtArgs>
    _count?: boolean | Work_ordersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type work_ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | assetsDefaultArgs<ExtArgs>
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }
  export type work_ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizations?: boolean | organizationsDefaultArgs<ExtArgs>
    customers?: boolean | customersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    assets?: boolean | assetsDefaultArgs<ExtArgs>
    maintenance_plans?: boolean | maintenance_plansDefaultArgs<ExtArgs>
  }

  export type $work_ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "work_orders"
    objects: {
      organizations: Prisma.$organizationsPayload<ExtArgs>
      customers: Prisma.$customersPayload<ExtArgs>
      companies: Prisma.$companiesPayload<ExtArgs>
      assets: Prisma.$assetsPayload<ExtArgs>
      maintenance_plans: Prisma.$maintenance_plansPayload<ExtArgs>
      work_order_services: Prisma.$work_order_servicesPayload<ExtArgs>[]
      work_order_tasks: Prisma.$work_order_tasksPayload<ExtArgs>[]
      work_order_assets: Prisma.$work_order_assetsPayload<ExtArgs>[]
      work_order_crew: Prisma.$work_order_crewPayload<ExtArgs>[]
      work_order_approvals: Prisma.$work_order_approvalsPayload<ExtArgs>[]
      invoices: Prisma.$invoicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      organization_id: bigint
      customer_id: bigint
      company_id: bigint
      asset_id: bigint
      maintenance_plan_id: bigint
      title: string
      description: string
      priority: $Enums.Prioirty
      status: $Enums.WorkOrderStatus
      assigned_to: string
      assigned_crew_id: number
      scheduled_start_date: string
      scheduled_end_date: string
      actual_start_date: string
      actual_end_date: string
      currency_id: number
      estimated_cost: Prisma.Decimal
      actual_cost: Prisma.Decimal
      address: string
      city: string
      state: string
      postal_code: string
      country: string
      is_multi_day: number
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["work_orders"]>
    composites: {}
  }

  type work_ordersGetPayload<S extends boolean | null | undefined | work_ordersDefaultArgs> = $Result.GetResult<Prisma.$work_ordersPayload, S>

  type work_ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<work_ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Work_ordersCountAggregateInputType | true
    }

  export interface work_ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['work_orders'], meta: { name: 'work_orders' } }
    /**
     * Find zero or one Work_orders that matches the filter.
     * @param {work_ordersFindUniqueArgs} args - Arguments to find a Work_orders
     * @example
     * // Get one Work_orders
     * const work_orders = await prisma.work_orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends work_ordersFindUniqueArgs>(args: SelectSubset<T, work_ordersFindUniqueArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Work_orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {work_ordersFindUniqueOrThrowArgs} args - Arguments to find a Work_orders
     * @example
     * // Get one Work_orders
     * const work_orders = await prisma.work_orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends work_ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, work_ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_ordersFindFirstArgs} args - Arguments to find a Work_orders
     * @example
     * // Get one Work_orders
     * const work_orders = await prisma.work_orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends work_ordersFindFirstArgs>(args?: SelectSubset<T, work_ordersFindFirstArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_ordersFindFirstOrThrowArgs} args - Arguments to find a Work_orders
     * @example
     * // Get one Work_orders
     * const work_orders = await prisma.work_orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends work_ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, work_ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Work_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Work_orders
     * const work_orders = await prisma.work_orders.findMany()
     * 
     * // Get first 10 Work_orders
     * const work_orders = await prisma.work_orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const work_ordersWithIdOnly = await prisma.work_orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends work_ordersFindManyArgs>(args?: SelectSubset<T, work_ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Work_orders.
     * @param {work_ordersCreateArgs} args - Arguments to create a Work_orders.
     * @example
     * // Create one Work_orders
     * const Work_orders = await prisma.work_orders.create({
     *   data: {
     *     // ... data to create a Work_orders
     *   }
     * })
     * 
     */
    create<T extends work_ordersCreateArgs>(args: SelectSubset<T, work_ordersCreateArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Work_orders.
     * @param {work_ordersCreateManyArgs} args - Arguments to create many Work_orders.
     * @example
     * // Create many Work_orders
     * const work_orders = await prisma.work_orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends work_ordersCreateManyArgs>(args?: SelectSubset<T, work_ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Work_orders and returns the data saved in the database.
     * @param {work_ordersCreateManyAndReturnArgs} args - Arguments to create many Work_orders.
     * @example
     * // Create many Work_orders
     * const work_orders = await prisma.work_orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Work_orders and only return the `id`
     * const work_ordersWithIdOnly = await prisma.work_orders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends work_ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, work_ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Work_orders.
     * @param {work_ordersDeleteArgs} args - Arguments to delete one Work_orders.
     * @example
     * // Delete one Work_orders
     * const Work_orders = await prisma.work_orders.delete({
     *   where: {
     *     // ... filter to delete one Work_orders
     *   }
     * })
     * 
     */
    delete<T extends work_ordersDeleteArgs>(args: SelectSubset<T, work_ordersDeleteArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Work_orders.
     * @param {work_ordersUpdateArgs} args - Arguments to update one Work_orders.
     * @example
     * // Update one Work_orders
     * const work_orders = await prisma.work_orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends work_ordersUpdateArgs>(args: SelectSubset<T, work_ordersUpdateArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Work_orders.
     * @param {work_ordersDeleteManyArgs} args - Arguments to filter Work_orders to delete.
     * @example
     * // Delete a few Work_orders
     * const { count } = await prisma.work_orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends work_ordersDeleteManyArgs>(args?: SelectSubset<T, work_ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Work_orders
     * const work_orders = await prisma.work_orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends work_ordersUpdateManyArgs>(args: SelectSubset<T, work_ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_orders and returns the data updated in the database.
     * @param {work_ordersUpdateManyAndReturnArgs} args - Arguments to update many Work_orders.
     * @example
     * // Update many Work_orders
     * const work_orders = await prisma.work_orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Work_orders and only return the `id`
     * const work_ordersWithIdOnly = await prisma.work_orders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends work_ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, work_ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Work_orders.
     * @param {work_ordersUpsertArgs} args - Arguments to update or create a Work_orders.
     * @example
     * // Update or create a Work_orders
     * const work_orders = await prisma.work_orders.upsert({
     *   create: {
     *     // ... data to create a Work_orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work_orders we want to update
     *   }
     * })
     */
    upsert<T extends work_ordersUpsertArgs>(args: SelectSubset<T, work_ordersUpsertArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Work_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_ordersCountArgs} args - Arguments to filter Work_orders to count.
     * @example
     * // Count the number of Work_orders
     * const count = await prisma.work_orders.count({
     *   where: {
     *     // ... the filter for the Work_orders we want to count
     *   }
     * })
    **/
    count<T extends work_ordersCountArgs>(
      args?: Subset<T, work_ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Work_ordersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Work_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Work_ordersAggregateArgs>(args: Subset<T, Work_ordersAggregateArgs>): Prisma.PrismaPromise<GetWork_ordersAggregateType<T>>

    /**
     * Group by Work_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends work_ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: work_ordersGroupByArgs['orderBy'] }
        : { orderBy?: work_ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, work_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWork_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the work_orders model
   */
  readonly fields: work_ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for work_orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__work_ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizations<T extends organizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationsDefaultArgs<ExtArgs>>): Prisma__organizationsClient<$Result.GetResult<Prisma.$organizationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends customersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customersDefaultArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends assetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, assetsDefaultArgs<ExtArgs>>): Prisma__assetsClient<$Result.GetResult<Prisma.$assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maintenance_plans<T extends maintenance_plansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, maintenance_plansDefaultArgs<ExtArgs>>): Prisma__maintenance_plansClient<$Result.GetResult<Prisma.$maintenance_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    work_order_services<T extends work_orders$work_order_servicesArgs<ExtArgs> = {}>(args?: Subset<T, work_orders$work_order_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_order_tasks<T extends work_orders$work_order_tasksArgs<ExtArgs> = {}>(args?: Subset<T, work_orders$work_order_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_order_assets<T extends work_orders$work_order_assetsArgs<ExtArgs> = {}>(args?: Subset<T, work_orders$work_order_assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_order_crew<T extends work_orders$work_order_crewArgs<ExtArgs> = {}>(args?: Subset<T, work_orders$work_order_crewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    work_order_approvals<T extends work_orders$work_order_approvalsArgs<ExtArgs> = {}>(args?: Subset<T, work_orders$work_order_approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends work_orders$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, work_orders$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the work_orders model
   */
  interface work_ordersFieldRefs {
    readonly id: FieldRef<"work_orders", 'BigInt'>
    readonly organization_id: FieldRef<"work_orders", 'BigInt'>
    readonly customer_id: FieldRef<"work_orders", 'BigInt'>
    readonly company_id: FieldRef<"work_orders", 'BigInt'>
    readonly asset_id: FieldRef<"work_orders", 'BigInt'>
    readonly maintenance_plan_id: FieldRef<"work_orders", 'BigInt'>
    readonly title: FieldRef<"work_orders", 'String'>
    readonly description: FieldRef<"work_orders", 'String'>
    readonly priority: FieldRef<"work_orders", 'Prioirty'>
    readonly status: FieldRef<"work_orders", 'WorkOrderStatus'>
    readonly assigned_to: FieldRef<"work_orders", 'String'>
    readonly assigned_crew_id: FieldRef<"work_orders", 'Int'>
    readonly scheduled_start_date: FieldRef<"work_orders", 'String'>
    readonly scheduled_end_date: FieldRef<"work_orders", 'String'>
    readonly actual_start_date: FieldRef<"work_orders", 'String'>
    readonly actual_end_date: FieldRef<"work_orders", 'String'>
    readonly currency_id: FieldRef<"work_orders", 'Int'>
    readonly estimated_cost: FieldRef<"work_orders", 'Decimal'>
    readonly actual_cost: FieldRef<"work_orders", 'Decimal'>
    readonly address: FieldRef<"work_orders", 'String'>
    readonly city: FieldRef<"work_orders", 'String'>
    readonly state: FieldRef<"work_orders", 'String'>
    readonly postal_code: FieldRef<"work_orders", 'String'>
    readonly country: FieldRef<"work_orders", 'String'>
    readonly is_multi_day: FieldRef<"work_orders", 'Int'>
    readonly created_at: FieldRef<"work_orders", 'String'>
    readonly updated_at: FieldRef<"work_orders", 'String'>
  }
    

  // Custom InputTypes
  /**
   * work_orders findUnique
   */
  export type work_ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * Filter, which work_orders to fetch.
     */
    where: work_ordersWhereUniqueInput
  }

  /**
   * work_orders findUniqueOrThrow
   */
  export type work_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * Filter, which work_orders to fetch.
     */
    where: work_ordersWhereUniqueInput
  }

  /**
   * work_orders findFirst
   */
  export type work_ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * Filter, which work_orders to fetch.
     */
    where?: work_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_orders to fetch.
     */
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_orders.
     */
    cursor?: work_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_orders.
     */
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * work_orders findFirstOrThrow
   */
  export type work_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * Filter, which work_orders to fetch.
     */
    where?: work_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_orders to fetch.
     */
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_orders.
     */
    cursor?: work_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_orders.
     */
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * work_orders findMany
   */
  export type work_ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * Filter, which work_orders to fetch.
     */
    where?: work_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_orders to fetch.
     */
    orderBy?: work_ordersOrderByWithRelationInput | work_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing work_orders.
     */
    cursor?: work_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_orders.
     */
    skip?: number
    distinct?: Work_ordersScalarFieldEnum | Work_ordersScalarFieldEnum[]
  }

  /**
   * work_orders create
   */
  export type work_ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * The data needed to create a work_orders.
     */
    data: XOR<work_ordersCreateInput, work_ordersUncheckedCreateInput>
  }

  /**
   * work_orders createMany
   */
  export type work_ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many work_orders.
     */
    data: work_ordersCreateManyInput | work_ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * work_orders createManyAndReturn
   */
  export type work_ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * The data used to create many work_orders.
     */
    data: work_ordersCreateManyInput | work_ordersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_orders update
   */
  export type work_ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * The data needed to update a work_orders.
     */
    data: XOR<work_ordersUpdateInput, work_ordersUncheckedUpdateInput>
    /**
     * Choose, which work_orders to update.
     */
    where: work_ordersWhereUniqueInput
  }

  /**
   * work_orders updateMany
   */
  export type work_ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update work_orders.
     */
    data: XOR<work_ordersUpdateManyMutationInput, work_ordersUncheckedUpdateManyInput>
    /**
     * Filter which work_orders to update
     */
    where?: work_ordersWhereInput
    /**
     * Limit how many work_orders to update.
     */
    limit?: number
  }

  /**
   * work_orders updateManyAndReturn
   */
  export type work_ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * The data used to update work_orders.
     */
    data: XOR<work_ordersUpdateManyMutationInput, work_ordersUncheckedUpdateManyInput>
    /**
     * Filter which work_orders to update
     */
    where?: work_ordersWhereInput
    /**
     * Limit how many work_orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_orders upsert
   */
  export type work_ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * The filter to search for the work_orders to update in case it exists.
     */
    where: work_ordersWhereUniqueInput
    /**
     * In case the work_orders found by the `where` argument doesn't exist, create a new work_orders with this data.
     */
    create: XOR<work_ordersCreateInput, work_ordersUncheckedCreateInput>
    /**
     * In case the work_orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<work_ordersUpdateInput, work_ordersUncheckedUpdateInput>
  }

  /**
   * work_orders delete
   */
  export type work_ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
    /**
     * Filter which work_orders to delete.
     */
    where: work_ordersWhereUniqueInput
  }

  /**
   * work_orders deleteMany
   */
  export type work_ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_orders to delete
     */
    where?: work_ordersWhereInput
    /**
     * Limit how many work_orders to delete.
     */
    limit?: number
  }

  /**
   * work_orders.work_order_services
   */
  export type work_orders$work_order_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    where?: work_order_servicesWhereInput
    orderBy?: work_order_servicesOrderByWithRelationInput | work_order_servicesOrderByWithRelationInput[]
    cursor?: work_order_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_order_servicesScalarFieldEnum | Work_order_servicesScalarFieldEnum[]
  }

  /**
   * work_orders.work_order_tasks
   */
  export type work_orders$work_order_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    where?: work_order_tasksWhereInput
    orderBy?: work_order_tasksOrderByWithRelationInput | work_order_tasksOrderByWithRelationInput[]
    cursor?: work_order_tasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_order_tasksScalarFieldEnum | Work_order_tasksScalarFieldEnum[]
  }

  /**
   * work_orders.work_order_assets
   */
  export type work_orders$work_order_assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    where?: work_order_assetsWhereInput
    orderBy?: work_order_assetsOrderByWithRelationInput | work_order_assetsOrderByWithRelationInput[]
    cursor?: work_order_assetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_order_assetsScalarFieldEnum | Work_order_assetsScalarFieldEnum[]
  }

  /**
   * work_orders.work_order_crew
   */
  export type work_orders$work_order_crewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    where?: work_order_crewWhereInput
    orderBy?: work_order_crewOrderByWithRelationInput | work_order_crewOrderByWithRelationInput[]
    cursor?: work_order_crewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_order_crewScalarFieldEnum | Work_order_crewScalarFieldEnum[]
  }

  /**
   * work_orders.work_order_approvals
   */
  export type work_orders$work_order_approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    where?: work_order_approvalsWhereInput
    orderBy?: work_order_approvalsOrderByWithRelationInput | work_order_approvalsOrderByWithRelationInput[]
    cursor?: work_order_approvalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Work_order_approvalsScalarFieldEnum | Work_order_approvalsScalarFieldEnum[]
  }

  /**
   * work_orders.invoices
   */
  export type work_orders$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    cursor?: invoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * work_orders without action
   */
  export type work_ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_orders
     */
    select?: work_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_orders
     */
    omit?: work_ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_ordersInclude<ExtArgs> | null
  }


  /**
   * Model work_order_services
   */

  export type AggregateWork_order_services = {
    _count: Work_order_servicesCountAggregateOutputType | null
    _avg: Work_order_servicesAvgAggregateOutputType | null
    _sum: Work_order_servicesSumAggregateOutputType | null
    _min: Work_order_servicesMinAggregateOutputType | null
    _max: Work_order_servicesMaxAggregateOutputType | null
  }

  export type Work_order_servicesAvgAggregateOutputType = {
    id: number | null
    work_order_id: number | null
    service_id: number | null
    quantity: number | null
    service_cost: Decimal | null
  }

  export type Work_order_servicesSumAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    service_id: bigint | null
    quantity: number | null
    service_cost: Decimal | null
  }

  export type Work_order_servicesMinAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    service_id: bigint | null
    quantity: number | null
    service_cost: Decimal | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_servicesMaxAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    service_id: bigint | null
    quantity: number | null
    service_cost: Decimal | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_servicesCountAggregateOutputType = {
    id: number
    work_order_id: number
    service_id: number
    quantity: number
    service_cost: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Work_order_servicesAvgAggregateInputType = {
    id?: true
    work_order_id?: true
    service_id?: true
    quantity?: true
    service_cost?: true
  }

  export type Work_order_servicesSumAggregateInputType = {
    id?: true
    work_order_id?: true
    service_id?: true
    quantity?: true
    service_cost?: true
  }

  export type Work_order_servicesMinAggregateInputType = {
    id?: true
    work_order_id?: true
    service_id?: true
    quantity?: true
    service_cost?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_servicesMaxAggregateInputType = {
    id?: true
    work_order_id?: true
    service_id?: true
    quantity?: true
    service_cost?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_servicesCountAggregateInputType = {
    id?: true
    work_order_id?: true
    service_id?: true
    quantity?: true
    service_cost?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Work_order_servicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_services to aggregate.
     */
    where?: work_order_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_services to fetch.
     */
    orderBy?: work_order_servicesOrderByWithRelationInput | work_order_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: work_order_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned work_order_services
    **/
    _count?: true | Work_order_servicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Work_order_servicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Work_order_servicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Work_order_servicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Work_order_servicesMaxAggregateInputType
  }

  export type GetWork_order_servicesAggregateType<T extends Work_order_servicesAggregateArgs> = {
        [P in keyof T & keyof AggregateWork_order_services]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork_order_services[P]>
      : GetScalarType<T[P], AggregateWork_order_services[P]>
  }




  export type work_order_servicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_servicesWhereInput
    orderBy?: work_order_servicesOrderByWithAggregationInput | work_order_servicesOrderByWithAggregationInput[]
    by: Work_order_servicesScalarFieldEnum[] | Work_order_servicesScalarFieldEnum
    having?: work_order_servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Work_order_servicesCountAggregateInputType | true
    _avg?: Work_order_servicesAvgAggregateInputType
    _sum?: Work_order_servicesSumAggregateInputType
    _min?: Work_order_servicesMinAggregateInputType
    _max?: Work_order_servicesMaxAggregateInputType
  }

  export type Work_order_servicesGroupByOutputType = {
    id: bigint
    work_order_id: bigint
    service_id: bigint
    quantity: number
    service_cost: Decimal
    created_at: string
    updated_at: string
    _count: Work_order_servicesCountAggregateOutputType | null
    _avg: Work_order_servicesAvgAggregateOutputType | null
    _sum: Work_order_servicesSumAggregateOutputType | null
    _min: Work_order_servicesMinAggregateOutputType | null
    _max: Work_order_servicesMaxAggregateOutputType | null
  }

  type GetWork_order_servicesGroupByPayload<T extends work_order_servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Work_order_servicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Work_order_servicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Work_order_servicesGroupByOutputType[P]>
            : GetScalarType<T[P], Work_order_servicesGroupByOutputType[P]>
        }
      >
    >


  export type work_order_servicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    service_id?: boolean
    quantity?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_services"]>

  export type work_order_servicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    service_id?: boolean
    quantity?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_services"]>

  export type work_order_servicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    service_id?: boolean
    quantity?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_services"]>

  export type work_order_servicesSelectScalar = {
    id?: boolean
    work_order_id?: boolean
    service_id?: boolean
    quantity?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type work_order_servicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "work_order_id" | "service_id" | "quantity" | "service_cost" | "created_at" | "updated_at", ExtArgs["result"]["work_order_services"]>
  export type work_order_servicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }
  export type work_order_servicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }
  export type work_order_servicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
  }

  export type $work_order_servicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "work_order_services"
    objects: {
      work_orders: Prisma.$work_ordersPayload<ExtArgs>
      services: Prisma.$servicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      work_order_id: bigint
      service_id: bigint
      quantity: number
      service_cost: Prisma.Decimal
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["work_order_services"]>
    composites: {}
  }

  type work_order_servicesGetPayload<S extends boolean | null | undefined | work_order_servicesDefaultArgs> = $Result.GetResult<Prisma.$work_order_servicesPayload, S>

  type work_order_servicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<work_order_servicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Work_order_servicesCountAggregateInputType | true
    }

  export interface work_order_servicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['work_order_services'], meta: { name: 'work_order_services' } }
    /**
     * Find zero or one Work_order_services that matches the filter.
     * @param {work_order_servicesFindUniqueArgs} args - Arguments to find a Work_order_services
     * @example
     * // Get one Work_order_services
     * const work_order_services = await prisma.work_order_services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends work_order_servicesFindUniqueArgs>(args: SelectSubset<T, work_order_servicesFindUniqueArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Work_order_services that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {work_order_servicesFindUniqueOrThrowArgs} args - Arguments to find a Work_order_services
     * @example
     * // Get one Work_order_services
     * const work_order_services = await prisma.work_order_services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends work_order_servicesFindUniqueOrThrowArgs>(args: SelectSubset<T, work_order_servicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_servicesFindFirstArgs} args - Arguments to find a Work_order_services
     * @example
     * // Get one Work_order_services
     * const work_order_services = await prisma.work_order_services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends work_order_servicesFindFirstArgs>(args?: SelectSubset<T, work_order_servicesFindFirstArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_services that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_servicesFindFirstOrThrowArgs} args - Arguments to find a Work_order_services
     * @example
     * // Get one Work_order_services
     * const work_order_services = await prisma.work_order_services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends work_order_servicesFindFirstOrThrowArgs>(args?: SelectSubset<T, work_order_servicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Work_order_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_servicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Work_order_services
     * const work_order_services = await prisma.work_order_services.findMany()
     * 
     * // Get first 10 Work_order_services
     * const work_order_services = await prisma.work_order_services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const work_order_servicesWithIdOnly = await prisma.work_order_services.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends work_order_servicesFindManyArgs>(args?: SelectSubset<T, work_order_servicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Work_order_services.
     * @param {work_order_servicesCreateArgs} args - Arguments to create a Work_order_services.
     * @example
     * // Create one Work_order_services
     * const Work_order_services = await prisma.work_order_services.create({
     *   data: {
     *     // ... data to create a Work_order_services
     *   }
     * })
     * 
     */
    create<T extends work_order_servicesCreateArgs>(args: SelectSubset<T, work_order_servicesCreateArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Work_order_services.
     * @param {work_order_servicesCreateManyArgs} args - Arguments to create many Work_order_services.
     * @example
     * // Create many Work_order_services
     * const work_order_services = await prisma.work_order_services.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends work_order_servicesCreateManyArgs>(args?: SelectSubset<T, work_order_servicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Work_order_services and returns the data saved in the database.
     * @param {work_order_servicesCreateManyAndReturnArgs} args - Arguments to create many Work_order_services.
     * @example
     * // Create many Work_order_services
     * const work_order_services = await prisma.work_order_services.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Work_order_services and only return the `id`
     * const work_order_servicesWithIdOnly = await prisma.work_order_services.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends work_order_servicesCreateManyAndReturnArgs>(args?: SelectSubset<T, work_order_servicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Work_order_services.
     * @param {work_order_servicesDeleteArgs} args - Arguments to delete one Work_order_services.
     * @example
     * // Delete one Work_order_services
     * const Work_order_services = await prisma.work_order_services.delete({
     *   where: {
     *     // ... filter to delete one Work_order_services
     *   }
     * })
     * 
     */
    delete<T extends work_order_servicesDeleteArgs>(args: SelectSubset<T, work_order_servicesDeleteArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Work_order_services.
     * @param {work_order_servicesUpdateArgs} args - Arguments to update one Work_order_services.
     * @example
     * // Update one Work_order_services
     * const work_order_services = await prisma.work_order_services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends work_order_servicesUpdateArgs>(args: SelectSubset<T, work_order_servicesUpdateArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Work_order_services.
     * @param {work_order_servicesDeleteManyArgs} args - Arguments to filter Work_order_services to delete.
     * @example
     * // Delete a few Work_order_services
     * const { count } = await prisma.work_order_services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends work_order_servicesDeleteManyArgs>(args?: SelectSubset<T, work_order_servicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Work_order_services
     * const work_order_services = await prisma.work_order_services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends work_order_servicesUpdateManyArgs>(args: SelectSubset<T, work_order_servicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_services and returns the data updated in the database.
     * @param {work_order_servicesUpdateManyAndReturnArgs} args - Arguments to update many Work_order_services.
     * @example
     * // Update many Work_order_services
     * const work_order_services = await prisma.work_order_services.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Work_order_services and only return the `id`
     * const work_order_servicesWithIdOnly = await prisma.work_order_services.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends work_order_servicesUpdateManyAndReturnArgs>(args: SelectSubset<T, work_order_servicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Work_order_services.
     * @param {work_order_servicesUpsertArgs} args - Arguments to update or create a Work_order_services.
     * @example
     * // Update or create a Work_order_services
     * const work_order_services = await prisma.work_order_services.upsert({
     *   create: {
     *     // ... data to create a Work_order_services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work_order_services we want to update
     *   }
     * })
     */
    upsert<T extends work_order_servicesUpsertArgs>(args: SelectSubset<T, work_order_servicesUpsertArgs<ExtArgs>>): Prisma__work_order_servicesClient<$Result.GetResult<Prisma.$work_order_servicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Work_order_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_servicesCountArgs} args - Arguments to filter Work_order_services to count.
     * @example
     * // Count the number of Work_order_services
     * const count = await prisma.work_order_services.count({
     *   where: {
     *     // ... the filter for the Work_order_services we want to count
     *   }
     * })
    **/
    count<T extends work_order_servicesCountArgs>(
      args?: Subset<T, work_order_servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Work_order_servicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work_order_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Work_order_servicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Work_order_servicesAggregateArgs>(args: Subset<T, Work_order_servicesAggregateArgs>): Prisma.PrismaPromise<GetWork_order_servicesAggregateType<T>>

    /**
     * Group by Work_order_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends work_order_servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: work_order_servicesGroupByArgs['orderBy'] }
        : { orderBy?: work_order_servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, work_order_servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWork_order_servicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the work_order_services model
   */
  readonly fields: work_order_servicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for work_order_services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__work_order_servicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work_orders<T extends work_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, work_ordersDefaultArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends servicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, servicesDefaultArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the work_order_services model
   */
  interface work_order_servicesFieldRefs {
    readonly id: FieldRef<"work_order_services", 'BigInt'>
    readonly work_order_id: FieldRef<"work_order_services", 'BigInt'>
    readonly service_id: FieldRef<"work_order_services", 'BigInt'>
    readonly quantity: FieldRef<"work_order_services", 'Int'>
    readonly service_cost: FieldRef<"work_order_services", 'Decimal'>
    readonly created_at: FieldRef<"work_order_services", 'String'>
    readonly updated_at: FieldRef<"work_order_services", 'String'>
  }
    

  // Custom InputTypes
  /**
   * work_order_services findUnique
   */
  export type work_order_servicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * Filter, which work_order_services to fetch.
     */
    where: work_order_servicesWhereUniqueInput
  }

  /**
   * work_order_services findUniqueOrThrow
   */
  export type work_order_servicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * Filter, which work_order_services to fetch.
     */
    where: work_order_servicesWhereUniqueInput
  }

  /**
   * work_order_services findFirst
   */
  export type work_order_servicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * Filter, which work_order_services to fetch.
     */
    where?: work_order_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_services to fetch.
     */
    orderBy?: work_order_servicesOrderByWithRelationInput | work_order_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_services.
     */
    cursor?: work_order_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_services.
     */
    distinct?: Work_order_servicesScalarFieldEnum | Work_order_servicesScalarFieldEnum[]
  }

  /**
   * work_order_services findFirstOrThrow
   */
  export type work_order_servicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * Filter, which work_order_services to fetch.
     */
    where?: work_order_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_services to fetch.
     */
    orderBy?: work_order_servicesOrderByWithRelationInput | work_order_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_services.
     */
    cursor?: work_order_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_services.
     */
    distinct?: Work_order_servicesScalarFieldEnum | Work_order_servicesScalarFieldEnum[]
  }

  /**
   * work_order_services findMany
   */
  export type work_order_servicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * Filter, which work_order_services to fetch.
     */
    where?: work_order_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_services to fetch.
     */
    orderBy?: work_order_servicesOrderByWithRelationInput | work_order_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing work_order_services.
     */
    cursor?: work_order_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_services.
     */
    skip?: number
    distinct?: Work_order_servicesScalarFieldEnum | Work_order_servicesScalarFieldEnum[]
  }

  /**
   * work_order_services create
   */
  export type work_order_servicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * The data needed to create a work_order_services.
     */
    data: XOR<work_order_servicesCreateInput, work_order_servicesUncheckedCreateInput>
  }

  /**
   * work_order_services createMany
   */
  export type work_order_servicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many work_order_services.
     */
    data: work_order_servicesCreateManyInput | work_order_servicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * work_order_services createManyAndReturn
   */
  export type work_order_servicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * The data used to create many work_order_services.
     */
    data: work_order_servicesCreateManyInput | work_order_servicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_services update
   */
  export type work_order_servicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * The data needed to update a work_order_services.
     */
    data: XOR<work_order_servicesUpdateInput, work_order_servicesUncheckedUpdateInput>
    /**
     * Choose, which work_order_services to update.
     */
    where: work_order_servicesWhereUniqueInput
  }

  /**
   * work_order_services updateMany
   */
  export type work_order_servicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update work_order_services.
     */
    data: XOR<work_order_servicesUpdateManyMutationInput, work_order_servicesUncheckedUpdateManyInput>
    /**
     * Filter which work_order_services to update
     */
    where?: work_order_servicesWhereInput
    /**
     * Limit how many work_order_services to update.
     */
    limit?: number
  }

  /**
   * work_order_services updateManyAndReturn
   */
  export type work_order_servicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * The data used to update work_order_services.
     */
    data: XOR<work_order_servicesUpdateManyMutationInput, work_order_servicesUncheckedUpdateManyInput>
    /**
     * Filter which work_order_services to update
     */
    where?: work_order_servicesWhereInput
    /**
     * Limit how many work_order_services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_services upsert
   */
  export type work_order_servicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * The filter to search for the work_order_services to update in case it exists.
     */
    where: work_order_servicesWhereUniqueInput
    /**
     * In case the work_order_services found by the `where` argument doesn't exist, create a new work_order_services with this data.
     */
    create: XOR<work_order_servicesCreateInput, work_order_servicesUncheckedCreateInput>
    /**
     * In case the work_order_services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<work_order_servicesUpdateInput, work_order_servicesUncheckedUpdateInput>
  }

  /**
   * work_order_services delete
   */
  export type work_order_servicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
    /**
     * Filter which work_order_services to delete.
     */
    where: work_order_servicesWhereUniqueInput
  }

  /**
   * work_order_services deleteMany
   */
  export type work_order_servicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_services to delete
     */
    where?: work_order_servicesWhereInput
    /**
     * Limit how many work_order_services to delete.
     */
    limit?: number
  }

  /**
   * work_order_services without action
   */
  export type work_order_servicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_services
     */
    select?: work_order_servicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_services
     */
    omit?: work_order_servicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_servicesInclude<ExtArgs> | null
  }


  /**
   * Model work_order_tasks
   */

  export type AggregateWork_order_tasks = {
    _count: Work_order_tasksCountAggregateOutputType | null
    _avg: Work_order_tasksAvgAggregateOutputType | null
    _sum: Work_order_tasksSumAggregateOutputType | null
    _min: Work_order_tasksMinAggregateOutputType | null
    _max: Work_order_tasksMaxAggregateOutputType | null
  }

  export type Work_order_tasksAvgAggregateOutputType = {
    id: number | null
    work_order_id: number | null
    assigned_to: number | null
  }

  export type Work_order_tasksSumAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    assigned_to: bigint | null
  }

  export type Work_order_tasksMinAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    task_name: string | null
    task_description: string | null
    assigned_to: bigint | null
    status: $Enums.WorkOrderTaskStatus | null
    due_date: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_tasksMaxAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    task_name: string | null
    task_description: string | null
    assigned_to: bigint | null
    status: $Enums.WorkOrderTaskStatus | null
    due_date: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_tasksCountAggregateOutputType = {
    id: number
    work_order_id: number
    task_name: number
    task_description: number
    assigned_to: number
    status: number
    due_date: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Work_order_tasksAvgAggregateInputType = {
    id?: true
    work_order_id?: true
    assigned_to?: true
  }

  export type Work_order_tasksSumAggregateInputType = {
    id?: true
    work_order_id?: true
    assigned_to?: true
  }

  export type Work_order_tasksMinAggregateInputType = {
    id?: true
    work_order_id?: true
    task_name?: true
    task_description?: true
    assigned_to?: true
    status?: true
    due_date?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_tasksMaxAggregateInputType = {
    id?: true
    work_order_id?: true
    task_name?: true
    task_description?: true
    assigned_to?: true
    status?: true
    due_date?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_tasksCountAggregateInputType = {
    id?: true
    work_order_id?: true
    task_name?: true
    task_description?: true
    assigned_to?: true
    status?: true
    due_date?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Work_order_tasksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_tasks to aggregate.
     */
    where?: work_order_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_tasks to fetch.
     */
    orderBy?: work_order_tasksOrderByWithRelationInput | work_order_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: work_order_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned work_order_tasks
    **/
    _count?: true | Work_order_tasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Work_order_tasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Work_order_tasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Work_order_tasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Work_order_tasksMaxAggregateInputType
  }

  export type GetWork_order_tasksAggregateType<T extends Work_order_tasksAggregateArgs> = {
        [P in keyof T & keyof AggregateWork_order_tasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork_order_tasks[P]>
      : GetScalarType<T[P], AggregateWork_order_tasks[P]>
  }




  export type work_order_tasksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_tasksWhereInput
    orderBy?: work_order_tasksOrderByWithAggregationInput | work_order_tasksOrderByWithAggregationInput[]
    by: Work_order_tasksScalarFieldEnum[] | Work_order_tasksScalarFieldEnum
    having?: work_order_tasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Work_order_tasksCountAggregateInputType | true
    _avg?: Work_order_tasksAvgAggregateInputType
    _sum?: Work_order_tasksSumAggregateInputType
    _min?: Work_order_tasksMinAggregateInputType
    _max?: Work_order_tasksMaxAggregateInputType
  }

  export type Work_order_tasksGroupByOutputType = {
    id: bigint
    work_order_id: bigint
    task_name: string
    task_description: string
    assigned_to: bigint
    status: $Enums.WorkOrderTaskStatus
    due_date: string
    created_at: string
    updated_at: string
    _count: Work_order_tasksCountAggregateOutputType | null
    _avg: Work_order_tasksAvgAggregateOutputType | null
    _sum: Work_order_tasksSumAggregateOutputType | null
    _min: Work_order_tasksMinAggregateOutputType | null
    _max: Work_order_tasksMaxAggregateOutputType | null
  }

  type GetWork_order_tasksGroupByPayload<T extends work_order_tasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Work_order_tasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Work_order_tasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Work_order_tasksGroupByOutputType[P]>
            : GetScalarType<T[P], Work_order_tasksGroupByOutputType[P]>
        }
      >
    >


  export type work_order_tasksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    task_name?: boolean
    task_description?: boolean
    assigned_to?: boolean
    status?: boolean
    due_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_tasks"]>

  export type work_order_tasksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    task_name?: boolean
    task_description?: boolean
    assigned_to?: boolean
    status?: boolean
    due_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_tasks"]>

  export type work_order_tasksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    task_name?: boolean
    task_description?: boolean
    assigned_to?: boolean
    status?: boolean
    due_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_tasks"]>

  export type work_order_tasksSelectScalar = {
    id?: boolean
    work_order_id?: boolean
    task_name?: boolean
    task_description?: boolean
    assigned_to?: boolean
    status?: boolean
    due_date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type work_order_tasksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "work_order_id" | "task_name" | "task_description" | "assigned_to" | "status" | "due_date" | "created_at" | "updated_at", ExtArgs["result"]["work_order_tasks"]>
  export type work_order_tasksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }
  export type work_order_tasksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }
  export type work_order_tasksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }

  export type $work_order_tasksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "work_order_tasks"
    objects: {
      work_orders: Prisma.$work_ordersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      work_order_id: bigint
      task_name: string
      task_description: string
      assigned_to: bigint
      status: $Enums.WorkOrderTaskStatus
      due_date: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["work_order_tasks"]>
    composites: {}
  }

  type work_order_tasksGetPayload<S extends boolean | null | undefined | work_order_tasksDefaultArgs> = $Result.GetResult<Prisma.$work_order_tasksPayload, S>

  type work_order_tasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<work_order_tasksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Work_order_tasksCountAggregateInputType | true
    }

  export interface work_order_tasksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['work_order_tasks'], meta: { name: 'work_order_tasks' } }
    /**
     * Find zero or one Work_order_tasks that matches the filter.
     * @param {work_order_tasksFindUniqueArgs} args - Arguments to find a Work_order_tasks
     * @example
     * // Get one Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends work_order_tasksFindUniqueArgs>(args: SelectSubset<T, work_order_tasksFindUniqueArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Work_order_tasks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {work_order_tasksFindUniqueOrThrowArgs} args - Arguments to find a Work_order_tasks
     * @example
     * // Get one Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends work_order_tasksFindUniqueOrThrowArgs>(args: SelectSubset<T, work_order_tasksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_tasksFindFirstArgs} args - Arguments to find a Work_order_tasks
     * @example
     * // Get one Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends work_order_tasksFindFirstArgs>(args?: SelectSubset<T, work_order_tasksFindFirstArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_tasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_tasksFindFirstOrThrowArgs} args - Arguments to find a Work_order_tasks
     * @example
     * // Get one Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends work_order_tasksFindFirstOrThrowArgs>(args?: SelectSubset<T, work_order_tasksFindFirstOrThrowArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Work_order_tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_tasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.findMany()
     * 
     * // Get first 10 Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const work_order_tasksWithIdOnly = await prisma.work_order_tasks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends work_order_tasksFindManyArgs>(args?: SelectSubset<T, work_order_tasksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Work_order_tasks.
     * @param {work_order_tasksCreateArgs} args - Arguments to create a Work_order_tasks.
     * @example
     * // Create one Work_order_tasks
     * const Work_order_tasks = await prisma.work_order_tasks.create({
     *   data: {
     *     // ... data to create a Work_order_tasks
     *   }
     * })
     * 
     */
    create<T extends work_order_tasksCreateArgs>(args: SelectSubset<T, work_order_tasksCreateArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Work_order_tasks.
     * @param {work_order_tasksCreateManyArgs} args - Arguments to create many Work_order_tasks.
     * @example
     * // Create many Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends work_order_tasksCreateManyArgs>(args?: SelectSubset<T, work_order_tasksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Work_order_tasks and returns the data saved in the database.
     * @param {work_order_tasksCreateManyAndReturnArgs} args - Arguments to create many Work_order_tasks.
     * @example
     * // Create many Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Work_order_tasks and only return the `id`
     * const work_order_tasksWithIdOnly = await prisma.work_order_tasks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends work_order_tasksCreateManyAndReturnArgs>(args?: SelectSubset<T, work_order_tasksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Work_order_tasks.
     * @param {work_order_tasksDeleteArgs} args - Arguments to delete one Work_order_tasks.
     * @example
     * // Delete one Work_order_tasks
     * const Work_order_tasks = await prisma.work_order_tasks.delete({
     *   where: {
     *     // ... filter to delete one Work_order_tasks
     *   }
     * })
     * 
     */
    delete<T extends work_order_tasksDeleteArgs>(args: SelectSubset<T, work_order_tasksDeleteArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Work_order_tasks.
     * @param {work_order_tasksUpdateArgs} args - Arguments to update one Work_order_tasks.
     * @example
     * // Update one Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends work_order_tasksUpdateArgs>(args: SelectSubset<T, work_order_tasksUpdateArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Work_order_tasks.
     * @param {work_order_tasksDeleteManyArgs} args - Arguments to filter Work_order_tasks to delete.
     * @example
     * // Delete a few Work_order_tasks
     * const { count } = await prisma.work_order_tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends work_order_tasksDeleteManyArgs>(args?: SelectSubset<T, work_order_tasksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_tasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends work_order_tasksUpdateManyArgs>(args: SelectSubset<T, work_order_tasksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_tasks and returns the data updated in the database.
     * @param {work_order_tasksUpdateManyAndReturnArgs} args - Arguments to update many Work_order_tasks.
     * @example
     * // Update many Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Work_order_tasks and only return the `id`
     * const work_order_tasksWithIdOnly = await prisma.work_order_tasks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends work_order_tasksUpdateManyAndReturnArgs>(args: SelectSubset<T, work_order_tasksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Work_order_tasks.
     * @param {work_order_tasksUpsertArgs} args - Arguments to update or create a Work_order_tasks.
     * @example
     * // Update or create a Work_order_tasks
     * const work_order_tasks = await prisma.work_order_tasks.upsert({
     *   create: {
     *     // ... data to create a Work_order_tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work_order_tasks we want to update
     *   }
     * })
     */
    upsert<T extends work_order_tasksUpsertArgs>(args: SelectSubset<T, work_order_tasksUpsertArgs<ExtArgs>>): Prisma__work_order_tasksClient<$Result.GetResult<Prisma.$work_order_tasksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Work_order_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_tasksCountArgs} args - Arguments to filter Work_order_tasks to count.
     * @example
     * // Count the number of Work_order_tasks
     * const count = await prisma.work_order_tasks.count({
     *   where: {
     *     // ... the filter for the Work_order_tasks we want to count
     *   }
     * })
    **/
    count<T extends work_order_tasksCountArgs>(
      args?: Subset<T, work_order_tasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Work_order_tasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work_order_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Work_order_tasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Work_order_tasksAggregateArgs>(args: Subset<T, Work_order_tasksAggregateArgs>): Prisma.PrismaPromise<GetWork_order_tasksAggregateType<T>>

    /**
     * Group by Work_order_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_tasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends work_order_tasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: work_order_tasksGroupByArgs['orderBy'] }
        : { orderBy?: work_order_tasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, work_order_tasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWork_order_tasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the work_order_tasks model
   */
  readonly fields: work_order_tasksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for work_order_tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__work_order_tasksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work_orders<T extends work_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, work_ordersDefaultArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the work_order_tasks model
   */
  interface work_order_tasksFieldRefs {
    readonly id: FieldRef<"work_order_tasks", 'BigInt'>
    readonly work_order_id: FieldRef<"work_order_tasks", 'BigInt'>
    readonly task_name: FieldRef<"work_order_tasks", 'String'>
    readonly task_description: FieldRef<"work_order_tasks", 'String'>
    readonly assigned_to: FieldRef<"work_order_tasks", 'BigInt'>
    readonly status: FieldRef<"work_order_tasks", 'WorkOrderTaskStatus'>
    readonly due_date: FieldRef<"work_order_tasks", 'String'>
    readonly created_at: FieldRef<"work_order_tasks", 'String'>
    readonly updated_at: FieldRef<"work_order_tasks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * work_order_tasks findUnique
   */
  export type work_order_tasksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * Filter, which work_order_tasks to fetch.
     */
    where: work_order_tasksWhereUniqueInput
  }

  /**
   * work_order_tasks findUniqueOrThrow
   */
  export type work_order_tasksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * Filter, which work_order_tasks to fetch.
     */
    where: work_order_tasksWhereUniqueInput
  }

  /**
   * work_order_tasks findFirst
   */
  export type work_order_tasksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * Filter, which work_order_tasks to fetch.
     */
    where?: work_order_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_tasks to fetch.
     */
    orderBy?: work_order_tasksOrderByWithRelationInput | work_order_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_tasks.
     */
    cursor?: work_order_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_tasks.
     */
    distinct?: Work_order_tasksScalarFieldEnum | Work_order_tasksScalarFieldEnum[]
  }

  /**
   * work_order_tasks findFirstOrThrow
   */
  export type work_order_tasksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * Filter, which work_order_tasks to fetch.
     */
    where?: work_order_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_tasks to fetch.
     */
    orderBy?: work_order_tasksOrderByWithRelationInput | work_order_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_tasks.
     */
    cursor?: work_order_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_tasks.
     */
    distinct?: Work_order_tasksScalarFieldEnum | Work_order_tasksScalarFieldEnum[]
  }

  /**
   * work_order_tasks findMany
   */
  export type work_order_tasksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * Filter, which work_order_tasks to fetch.
     */
    where?: work_order_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_tasks to fetch.
     */
    orderBy?: work_order_tasksOrderByWithRelationInput | work_order_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing work_order_tasks.
     */
    cursor?: work_order_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_tasks.
     */
    skip?: number
    distinct?: Work_order_tasksScalarFieldEnum | Work_order_tasksScalarFieldEnum[]
  }

  /**
   * work_order_tasks create
   */
  export type work_order_tasksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * The data needed to create a work_order_tasks.
     */
    data: XOR<work_order_tasksCreateInput, work_order_tasksUncheckedCreateInput>
  }

  /**
   * work_order_tasks createMany
   */
  export type work_order_tasksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many work_order_tasks.
     */
    data: work_order_tasksCreateManyInput | work_order_tasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * work_order_tasks createManyAndReturn
   */
  export type work_order_tasksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * The data used to create many work_order_tasks.
     */
    data: work_order_tasksCreateManyInput | work_order_tasksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_tasks update
   */
  export type work_order_tasksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * The data needed to update a work_order_tasks.
     */
    data: XOR<work_order_tasksUpdateInput, work_order_tasksUncheckedUpdateInput>
    /**
     * Choose, which work_order_tasks to update.
     */
    where: work_order_tasksWhereUniqueInput
  }

  /**
   * work_order_tasks updateMany
   */
  export type work_order_tasksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update work_order_tasks.
     */
    data: XOR<work_order_tasksUpdateManyMutationInput, work_order_tasksUncheckedUpdateManyInput>
    /**
     * Filter which work_order_tasks to update
     */
    where?: work_order_tasksWhereInput
    /**
     * Limit how many work_order_tasks to update.
     */
    limit?: number
  }

  /**
   * work_order_tasks updateManyAndReturn
   */
  export type work_order_tasksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * The data used to update work_order_tasks.
     */
    data: XOR<work_order_tasksUpdateManyMutationInput, work_order_tasksUncheckedUpdateManyInput>
    /**
     * Filter which work_order_tasks to update
     */
    where?: work_order_tasksWhereInput
    /**
     * Limit how many work_order_tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_tasks upsert
   */
  export type work_order_tasksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * The filter to search for the work_order_tasks to update in case it exists.
     */
    where: work_order_tasksWhereUniqueInput
    /**
     * In case the work_order_tasks found by the `where` argument doesn't exist, create a new work_order_tasks with this data.
     */
    create: XOR<work_order_tasksCreateInput, work_order_tasksUncheckedCreateInput>
    /**
     * In case the work_order_tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<work_order_tasksUpdateInput, work_order_tasksUncheckedUpdateInput>
  }

  /**
   * work_order_tasks delete
   */
  export type work_order_tasksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
    /**
     * Filter which work_order_tasks to delete.
     */
    where: work_order_tasksWhereUniqueInput
  }

  /**
   * work_order_tasks deleteMany
   */
  export type work_order_tasksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_tasks to delete
     */
    where?: work_order_tasksWhereInput
    /**
     * Limit how many work_order_tasks to delete.
     */
    limit?: number
  }

  /**
   * work_order_tasks without action
   */
  export type work_order_tasksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_tasks
     */
    select?: work_order_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_tasks
     */
    omit?: work_order_tasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_tasksInclude<ExtArgs> | null
  }


  /**
   * Model work_order_assets
   */

  export type AggregateWork_order_assets = {
    _count: Work_order_assetsCountAggregateOutputType | null
    _avg: Work_order_assetsAvgAggregateOutputType | null
    _sum: Work_order_assetsSumAggregateOutputType | null
    _min: Work_order_assetsMinAggregateOutputType | null
    _max: Work_order_assetsMaxAggregateOutputType | null
  }

  export type Work_order_assetsAvgAggregateOutputType = {
    id: number | null
    work_order_id: number | null
    asset_id: number | null
    quantity: number | null
  }

  export type Work_order_assetsSumAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    asset_id: bigint | null
    quantity: number | null
  }

  export type Work_order_assetsMinAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    asset_id: bigint | null
    quantity: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_assetsMaxAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    asset_id: bigint | null
    quantity: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_assetsCountAggregateOutputType = {
    id: number
    work_order_id: number
    asset_id: number
    quantity: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Work_order_assetsAvgAggregateInputType = {
    id?: true
    work_order_id?: true
    asset_id?: true
    quantity?: true
  }

  export type Work_order_assetsSumAggregateInputType = {
    id?: true
    work_order_id?: true
    asset_id?: true
    quantity?: true
  }

  export type Work_order_assetsMinAggregateInputType = {
    id?: true
    work_order_id?: true
    asset_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_assetsMaxAggregateInputType = {
    id?: true
    work_order_id?: true
    asset_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_assetsCountAggregateInputType = {
    id?: true
    work_order_id?: true
    asset_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Work_order_assetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_assets to aggregate.
     */
    where?: work_order_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_assets to fetch.
     */
    orderBy?: work_order_assetsOrderByWithRelationInput | work_order_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: work_order_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned work_order_assets
    **/
    _count?: true | Work_order_assetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Work_order_assetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Work_order_assetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Work_order_assetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Work_order_assetsMaxAggregateInputType
  }

  export type GetWork_order_assetsAggregateType<T extends Work_order_assetsAggregateArgs> = {
        [P in keyof T & keyof AggregateWork_order_assets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork_order_assets[P]>
      : GetScalarType<T[P], AggregateWork_order_assets[P]>
  }




  export type work_order_assetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_assetsWhereInput
    orderBy?: work_order_assetsOrderByWithAggregationInput | work_order_assetsOrderByWithAggregationInput[]
    by: Work_order_assetsScalarFieldEnum[] | Work_order_assetsScalarFieldEnum
    having?: work_order_assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Work_order_assetsCountAggregateInputType | true
    _avg?: Work_order_assetsAvgAggregateInputType
    _sum?: Work_order_assetsSumAggregateInputType
    _min?: Work_order_assetsMinAggregateInputType
    _max?: Work_order_assetsMaxAggregateInputType
  }

  export type Work_order_assetsGroupByOutputType = {
    id: bigint
    work_order_id: bigint
    asset_id: bigint
    quantity: number
    created_at: string
    updated_at: string
    _count: Work_order_assetsCountAggregateOutputType | null
    _avg: Work_order_assetsAvgAggregateOutputType | null
    _sum: Work_order_assetsSumAggregateOutputType | null
    _min: Work_order_assetsMinAggregateOutputType | null
    _max: Work_order_assetsMaxAggregateOutputType | null
  }

  type GetWork_order_assetsGroupByPayload<T extends work_order_assetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Work_order_assetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Work_order_assetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Work_order_assetsGroupByOutputType[P]>
            : GetScalarType<T[P], Work_order_assetsGroupByOutputType[P]>
        }
      >
    >


  export type work_order_assetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    asset_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_assets"]>

  export type work_order_assetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    asset_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_assets"]>

  export type work_order_assetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    asset_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_assets"]>

  export type work_order_assetsSelectScalar = {
    id?: boolean
    work_order_id?: boolean
    asset_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type work_order_assetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "work_order_id" | "asset_id" | "quantity" | "created_at" | "updated_at", ExtArgs["result"]["work_order_assets"]>
  export type work_order_assetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }
  export type work_order_assetsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }
  export type work_order_assetsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }

  export type $work_order_assetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "work_order_assets"
    objects: {
      work_orders: Prisma.$work_ordersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      work_order_id: bigint
      asset_id: bigint
      quantity: number
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["work_order_assets"]>
    composites: {}
  }

  type work_order_assetsGetPayload<S extends boolean | null | undefined | work_order_assetsDefaultArgs> = $Result.GetResult<Prisma.$work_order_assetsPayload, S>

  type work_order_assetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<work_order_assetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Work_order_assetsCountAggregateInputType | true
    }

  export interface work_order_assetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['work_order_assets'], meta: { name: 'work_order_assets' } }
    /**
     * Find zero or one Work_order_assets that matches the filter.
     * @param {work_order_assetsFindUniqueArgs} args - Arguments to find a Work_order_assets
     * @example
     * // Get one Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends work_order_assetsFindUniqueArgs>(args: SelectSubset<T, work_order_assetsFindUniqueArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Work_order_assets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {work_order_assetsFindUniqueOrThrowArgs} args - Arguments to find a Work_order_assets
     * @example
     * // Get one Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends work_order_assetsFindUniqueOrThrowArgs>(args: SelectSubset<T, work_order_assetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_assetsFindFirstArgs} args - Arguments to find a Work_order_assets
     * @example
     * // Get one Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends work_order_assetsFindFirstArgs>(args?: SelectSubset<T, work_order_assetsFindFirstArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_assets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_assetsFindFirstOrThrowArgs} args - Arguments to find a Work_order_assets
     * @example
     * // Get one Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends work_order_assetsFindFirstOrThrowArgs>(args?: SelectSubset<T, work_order_assetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Work_order_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_assetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.findMany()
     * 
     * // Get first 10 Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const work_order_assetsWithIdOnly = await prisma.work_order_assets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends work_order_assetsFindManyArgs>(args?: SelectSubset<T, work_order_assetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Work_order_assets.
     * @param {work_order_assetsCreateArgs} args - Arguments to create a Work_order_assets.
     * @example
     * // Create one Work_order_assets
     * const Work_order_assets = await prisma.work_order_assets.create({
     *   data: {
     *     // ... data to create a Work_order_assets
     *   }
     * })
     * 
     */
    create<T extends work_order_assetsCreateArgs>(args: SelectSubset<T, work_order_assetsCreateArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Work_order_assets.
     * @param {work_order_assetsCreateManyArgs} args - Arguments to create many Work_order_assets.
     * @example
     * // Create many Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends work_order_assetsCreateManyArgs>(args?: SelectSubset<T, work_order_assetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Work_order_assets and returns the data saved in the database.
     * @param {work_order_assetsCreateManyAndReturnArgs} args - Arguments to create many Work_order_assets.
     * @example
     * // Create many Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Work_order_assets and only return the `id`
     * const work_order_assetsWithIdOnly = await prisma.work_order_assets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends work_order_assetsCreateManyAndReturnArgs>(args?: SelectSubset<T, work_order_assetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Work_order_assets.
     * @param {work_order_assetsDeleteArgs} args - Arguments to delete one Work_order_assets.
     * @example
     * // Delete one Work_order_assets
     * const Work_order_assets = await prisma.work_order_assets.delete({
     *   where: {
     *     // ... filter to delete one Work_order_assets
     *   }
     * })
     * 
     */
    delete<T extends work_order_assetsDeleteArgs>(args: SelectSubset<T, work_order_assetsDeleteArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Work_order_assets.
     * @param {work_order_assetsUpdateArgs} args - Arguments to update one Work_order_assets.
     * @example
     * // Update one Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends work_order_assetsUpdateArgs>(args: SelectSubset<T, work_order_assetsUpdateArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Work_order_assets.
     * @param {work_order_assetsDeleteManyArgs} args - Arguments to filter Work_order_assets to delete.
     * @example
     * // Delete a few Work_order_assets
     * const { count } = await prisma.work_order_assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends work_order_assetsDeleteManyArgs>(args?: SelectSubset<T, work_order_assetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends work_order_assetsUpdateManyArgs>(args: SelectSubset<T, work_order_assetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_assets and returns the data updated in the database.
     * @param {work_order_assetsUpdateManyAndReturnArgs} args - Arguments to update many Work_order_assets.
     * @example
     * // Update many Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Work_order_assets and only return the `id`
     * const work_order_assetsWithIdOnly = await prisma.work_order_assets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends work_order_assetsUpdateManyAndReturnArgs>(args: SelectSubset<T, work_order_assetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Work_order_assets.
     * @param {work_order_assetsUpsertArgs} args - Arguments to update or create a Work_order_assets.
     * @example
     * // Update or create a Work_order_assets
     * const work_order_assets = await prisma.work_order_assets.upsert({
     *   create: {
     *     // ... data to create a Work_order_assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work_order_assets we want to update
     *   }
     * })
     */
    upsert<T extends work_order_assetsUpsertArgs>(args: SelectSubset<T, work_order_assetsUpsertArgs<ExtArgs>>): Prisma__work_order_assetsClient<$Result.GetResult<Prisma.$work_order_assetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Work_order_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_assetsCountArgs} args - Arguments to filter Work_order_assets to count.
     * @example
     * // Count the number of Work_order_assets
     * const count = await prisma.work_order_assets.count({
     *   where: {
     *     // ... the filter for the Work_order_assets we want to count
     *   }
     * })
    **/
    count<T extends work_order_assetsCountArgs>(
      args?: Subset<T, work_order_assetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Work_order_assetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work_order_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Work_order_assetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Work_order_assetsAggregateArgs>(args: Subset<T, Work_order_assetsAggregateArgs>): Prisma.PrismaPromise<GetWork_order_assetsAggregateType<T>>

    /**
     * Group by Work_order_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_assetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends work_order_assetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: work_order_assetsGroupByArgs['orderBy'] }
        : { orderBy?: work_order_assetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, work_order_assetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWork_order_assetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the work_order_assets model
   */
  readonly fields: work_order_assetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for work_order_assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__work_order_assetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work_orders<T extends work_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, work_ordersDefaultArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the work_order_assets model
   */
  interface work_order_assetsFieldRefs {
    readonly id: FieldRef<"work_order_assets", 'BigInt'>
    readonly work_order_id: FieldRef<"work_order_assets", 'BigInt'>
    readonly asset_id: FieldRef<"work_order_assets", 'BigInt'>
    readonly quantity: FieldRef<"work_order_assets", 'Int'>
    readonly created_at: FieldRef<"work_order_assets", 'String'>
    readonly updated_at: FieldRef<"work_order_assets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * work_order_assets findUnique
   */
  export type work_order_assetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_assets to fetch.
     */
    where: work_order_assetsWhereUniqueInput
  }

  /**
   * work_order_assets findUniqueOrThrow
   */
  export type work_order_assetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_assets to fetch.
     */
    where: work_order_assetsWhereUniqueInput
  }

  /**
   * work_order_assets findFirst
   */
  export type work_order_assetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_assets to fetch.
     */
    where?: work_order_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_assets to fetch.
     */
    orderBy?: work_order_assetsOrderByWithRelationInput | work_order_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_assets.
     */
    cursor?: work_order_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_assets.
     */
    distinct?: Work_order_assetsScalarFieldEnum | Work_order_assetsScalarFieldEnum[]
  }

  /**
   * work_order_assets findFirstOrThrow
   */
  export type work_order_assetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_assets to fetch.
     */
    where?: work_order_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_assets to fetch.
     */
    orderBy?: work_order_assetsOrderByWithRelationInput | work_order_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_assets.
     */
    cursor?: work_order_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_assets.
     */
    distinct?: Work_order_assetsScalarFieldEnum | Work_order_assetsScalarFieldEnum[]
  }

  /**
   * work_order_assets findMany
   */
  export type work_order_assetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_assets to fetch.
     */
    where?: work_order_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_assets to fetch.
     */
    orderBy?: work_order_assetsOrderByWithRelationInput | work_order_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing work_order_assets.
     */
    cursor?: work_order_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_assets.
     */
    skip?: number
    distinct?: Work_order_assetsScalarFieldEnum | Work_order_assetsScalarFieldEnum[]
  }

  /**
   * work_order_assets create
   */
  export type work_order_assetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * The data needed to create a work_order_assets.
     */
    data: XOR<work_order_assetsCreateInput, work_order_assetsUncheckedCreateInput>
  }

  /**
   * work_order_assets createMany
   */
  export type work_order_assetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many work_order_assets.
     */
    data: work_order_assetsCreateManyInput | work_order_assetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * work_order_assets createManyAndReturn
   */
  export type work_order_assetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * The data used to create many work_order_assets.
     */
    data: work_order_assetsCreateManyInput | work_order_assetsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_assets update
   */
  export type work_order_assetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * The data needed to update a work_order_assets.
     */
    data: XOR<work_order_assetsUpdateInput, work_order_assetsUncheckedUpdateInput>
    /**
     * Choose, which work_order_assets to update.
     */
    where: work_order_assetsWhereUniqueInput
  }

  /**
   * work_order_assets updateMany
   */
  export type work_order_assetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update work_order_assets.
     */
    data: XOR<work_order_assetsUpdateManyMutationInput, work_order_assetsUncheckedUpdateManyInput>
    /**
     * Filter which work_order_assets to update
     */
    where?: work_order_assetsWhereInput
    /**
     * Limit how many work_order_assets to update.
     */
    limit?: number
  }

  /**
   * work_order_assets updateManyAndReturn
   */
  export type work_order_assetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * The data used to update work_order_assets.
     */
    data: XOR<work_order_assetsUpdateManyMutationInput, work_order_assetsUncheckedUpdateManyInput>
    /**
     * Filter which work_order_assets to update
     */
    where?: work_order_assetsWhereInput
    /**
     * Limit how many work_order_assets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_assets upsert
   */
  export type work_order_assetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * The filter to search for the work_order_assets to update in case it exists.
     */
    where: work_order_assetsWhereUniqueInput
    /**
     * In case the work_order_assets found by the `where` argument doesn't exist, create a new work_order_assets with this data.
     */
    create: XOR<work_order_assetsCreateInput, work_order_assetsUncheckedCreateInput>
    /**
     * In case the work_order_assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<work_order_assetsUpdateInput, work_order_assetsUncheckedUpdateInput>
  }

  /**
   * work_order_assets delete
   */
  export type work_order_assetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
    /**
     * Filter which work_order_assets to delete.
     */
    where: work_order_assetsWhereUniqueInput
  }

  /**
   * work_order_assets deleteMany
   */
  export type work_order_assetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_assets to delete
     */
    where?: work_order_assetsWhereInput
    /**
     * Limit how many work_order_assets to delete.
     */
    limit?: number
  }

  /**
   * work_order_assets without action
   */
  export type work_order_assetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_assets
     */
    select?: work_order_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_assets
     */
    omit?: work_order_assetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_assetsInclude<ExtArgs> | null
  }


  /**
   * Model work_order_crew
   */

  export type AggregateWork_order_crew = {
    _count: Work_order_crewCountAggregateOutputType | null
    _avg: Work_order_crewAvgAggregateOutputType | null
    _sum: Work_order_crewSumAggregateOutputType | null
    _min: Work_order_crewMinAggregateOutputType | null
    _max: Work_order_crewMaxAggregateOutputType | null
  }

  export type Work_order_crewAvgAggregateOutputType = {
    id: number | null
    work_order_id: number | null
    crew_id: number | null
  }

  export type Work_order_crewSumAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    crew_id: bigint | null
  }

  export type Work_order_crewMinAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    crew_id: bigint | null
    assigned_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_crewMaxAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    crew_id: bigint | null
    assigned_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_crewCountAggregateOutputType = {
    id: number
    work_order_id: number
    crew_id: number
    assigned_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Work_order_crewAvgAggregateInputType = {
    id?: true
    work_order_id?: true
    crew_id?: true
  }

  export type Work_order_crewSumAggregateInputType = {
    id?: true
    work_order_id?: true
    crew_id?: true
  }

  export type Work_order_crewMinAggregateInputType = {
    id?: true
    work_order_id?: true
    crew_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_crewMaxAggregateInputType = {
    id?: true
    work_order_id?: true
    crew_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_crewCountAggregateInputType = {
    id?: true
    work_order_id?: true
    crew_id?: true
    assigned_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Work_order_crewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_crew to aggregate.
     */
    where?: work_order_crewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_crews to fetch.
     */
    orderBy?: work_order_crewOrderByWithRelationInput | work_order_crewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: work_order_crewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned work_order_crews
    **/
    _count?: true | Work_order_crewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Work_order_crewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Work_order_crewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Work_order_crewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Work_order_crewMaxAggregateInputType
  }

  export type GetWork_order_crewAggregateType<T extends Work_order_crewAggregateArgs> = {
        [P in keyof T & keyof AggregateWork_order_crew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork_order_crew[P]>
      : GetScalarType<T[P], AggregateWork_order_crew[P]>
  }




  export type work_order_crewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_crewWhereInput
    orderBy?: work_order_crewOrderByWithAggregationInput | work_order_crewOrderByWithAggregationInput[]
    by: Work_order_crewScalarFieldEnum[] | Work_order_crewScalarFieldEnum
    having?: work_order_crewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Work_order_crewCountAggregateInputType | true
    _avg?: Work_order_crewAvgAggregateInputType
    _sum?: Work_order_crewSumAggregateInputType
    _min?: Work_order_crewMinAggregateInputType
    _max?: Work_order_crewMaxAggregateInputType
  }

  export type Work_order_crewGroupByOutputType = {
    id: bigint
    work_order_id: bigint
    crew_id: bigint
    assigned_at: string
    created_at: string
    updated_at: string
    _count: Work_order_crewCountAggregateOutputType | null
    _avg: Work_order_crewAvgAggregateOutputType | null
    _sum: Work_order_crewSumAggregateOutputType | null
    _min: Work_order_crewMinAggregateOutputType | null
    _max: Work_order_crewMaxAggregateOutputType | null
  }

  type GetWork_order_crewGroupByPayload<T extends work_order_crewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Work_order_crewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Work_order_crewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Work_order_crewGroupByOutputType[P]>
            : GetScalarType<T[P], Work_order_crewGroupByOutputType[P]>
        }
      >
    >


  export type work_order_crewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    crew_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_crew"]>

  export type work_order_crewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    crew_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_crew"]>

  export type work_order_crewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    crew_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_crew"]>

  export type work_order_crewSelectScalar = {
    id?: boolean
    work_order_id?: boolean
    crew_id?: boolean
    assigned_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type work_order_crewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "work_order_id" | "crew_id" | "assigned_at" | "created_at" | "updated_at", ExtArgs["result"]["work_order_crew"]>
  export type work_order_crewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
  }
  export type work_order_crewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
  }
  export type work_order_crewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    crews?: boolean | crewsDefaultArgs<ExtArgs>
  }

  export type $work_order_crewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "work_order_crew"
    objects: {
      work_orders: Prisma.$work_ordersPayload<ExtArgs>
      crews: Prisma.$crewsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      work_order_id: bigint
      crew_id: bigint
      assigned_at: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["work_order_crew"]>
    composites: {}
  }

  type work_order_crewGetPayload<S extends boolean | null | undefined | work_order_crewDefaultArgs> = $Result.GetResult<Prisma.$work_order_crewPayload, S>

  type work_order_crewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<work_order_crewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Work_order_crewCountAggregateInputType | true
    }

  export interface work_order_crewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['work_order_crew'], meta: { name: 'work_order_crew' } }
    /**
     * Find zero or one Work_order_crew that matches the filter.
     * @param {work_order_crewFindUniqueArgs} args - Arguments to find a Work_order_crew
     * @example
     * // Get one Work_order_crew
     * const work_order_crew = await prisma.work_order_crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends work_order_crewFindUniqueArgs>(args: SelectSubset<T, work_order_crewFindUniqueArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Work_order_crew that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {work_order_crewFindUniqueOrThrowArgs} args - Arguments to find a Work_order_crew
     * @example
     * // Get one Work_order_crew
     * const work_order_crew = await prisma.work_order_crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends work_order_crewFindUniqueOrThrowArgs>(args: SelectSubset<T, work_order_crewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_crewFindFirstArgs} args - Arguments to find a Work_order_crew
     * @example
     * // Get one Work_order_crew
     * const work_order_crew = await prisma.work_order_crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends work_order_crewFindFirstArgs>(args?: SelectSubset<T, work_order_crewFindFirstArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_crew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_crewFindFirstOrThrowArgs} args - Arguments to find a Work_order_crew
     * @example
     * // Get one Work_order_crew
     * const work_order_crew = await prisma.work_order_crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends work_order_crewFindFirstOrThrowArgs>(args?: SelectSubset<T, work_order_crewFindFirstOrThrowArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Work_order_crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_crewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Work_order_crews
     * const work_order_crews = await prisma.work_order_crew.findMany()
     * 
     * // Get first 10 Work_order_crews
     * const work_order_crews = await prisma.work_order_crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const work_order_crewWithIdOnly = await prisma.work_order_crew.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends work_order_crewFindManyArgs>(args?: SelectSubset<T, work_order_crewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Work_order_crew.
     * @param {work_order_crewCreateArgs} args - Arguments to create a Work_order_crew.
     * @example
     * // Create one Work_order_crew
     * const Work_order_crew = await prisma.work_order_crew.create({
     *   data: {
     *     // ... data to create a Work_order_crew
     *   }
     * })
     * 
     */
    create<T extends work_order_crewCreateArgs>(args: SelectSubset<T, work_order_crewCreateArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Work_order_crews.
     * @param {work_order_crewCreateManyArgs} args - Arguments to create many Work_order_crews.
     * @example
     * // Create many Work_order_crews
     * const work_order_crew = await prisma.work_order_crew.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends work_order_crewCreateManyArgs>(args?: SelectSubset<T, work_order_crewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Work_order_crews and returns the data saved in the database.
     * @param {work_order_crewCreateManyAndReturnArgs} args - Arguments to create many Work_order_crews.
     * @example
     * // Create many Work_order_crews
     * const work_order_crew = await prisma.work_order_crew.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Work_order_crews and only return the `id`
     * const work_order_crewWithIdOnly = await prisma.work_order_crew.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends work_order_crewCreateManyAndReturnArgs>(args?: SelectSubset<T, work_order_crewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Work_order_crew.
     * @param {work_order_crewDeleteArgs} args - Arguments to delete one Work_order_crew.
     * @example
     * // Delete one Work_order_crew
     * const Work_order_crew = await prisma.work_order_crew.delete({
     *   where: {
     *     // ... filter to delete one Work_order_crew
     *   }
     * })
     * 
     */
    delete<T extends work_order_crewDeleteArgs>(args: SelectSubset<T, work_order_crewDeleteArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Work_order_crew.
     * @param {work_order_crewUpdateArgs} args - Arguments to update one Work_order_crew.
     * @example
     * // Update one Work_order_crew
     * const work_order_crew = await prisma.work_order_crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends work_order_crewUpdateArgs>(args: SelectSubset<T, work_order_crewUpdateArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Work_order_crews.
     * @param {work_order_crewDeleteManyArgs} args - Arguments to filter Work_order_crews to delete.
     * @example
     * // Delete a few Work_order_crews
     * const { count } = await prisma.work_order_crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends work_order_crewDeleteManyArgs>(args?: SelectSubset<T, work_order_crewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_crewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Work_order_crews
     * const work_order_crew = await prisma.work_order_crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends work_order_crewUpdateManyArgs>(args: SelectSubset<T, work_order_crewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_crews and returns the data updated in the database.
     * @param {work_order_crewUpdateManyAndReturnArgs} args - Arguments to update many Work_order_crews.
     * @example
     * // Update many Work_order_crews
     * const work_order_crew = await prisma.work_order_crew.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Work_order_crews and only return the `id`
     * const work_order_crewWithIdOnly = await prisma.work_order_crew.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends work_order_crewUpdateManyAndReturnArgs>(args: SelectSubset<T, work_order_crewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Work_order_crew.
     * @param {work_order_crewUpsertArgs} args - Arguments to update or create a Work_order_crew.
     * @example
     * // Update or create a Work_order_crew
     * const work_order_crew = await prisma.work_order_crew.upsert({
     *   create: {
     *     // ... data to create a Work_order_crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work_order_crew we want to update
     *   }
     * })
     */
    upsert<T extends work_order_crewUpsertArgs>(args: SelectSubset<T, work_order_crewUpsertArgs<ExtArgs>>): Prisma__work_order_crewClient<$Result.GetResult<Prisma.$work_order_crewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Work_order_crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_crewCountArgs} args - Arguments to filter Work_order_crews to count.
     * @example
     * // Count the number of Work_order_crews
     * const count = await prisma.work_order_crew.count({
     *   where: {
     *     // ... the filter for the Work_order_crews we want to count
     *   }
     * })
    **/
    count<T extends work_order_crewCountArgs>(
      args?: Subset<T, work_order_crewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Work_order_crewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work_order_crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Work_order_crewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Work_order_crewAggregateArgs>(args: Subset<T, Work_order_crewAggregateArgs>): Prisma.PrismaPromise<GetWork_order_crewAggregateType<T>>

    /**
     * Group by Work_order_crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_crewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends work_order_crewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: work_order_crewGroupByArgs['orderBy'] }
        : { orderBy?: work_order_crewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, work_order_crewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWork_order_crewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the work_order_crew model
   */
  readonly fields: work_order_crewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for work_order_crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__work_order_crewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work_orders<T extends work_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, work_ordersDefaultArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    crews<T extends crewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, crewsDefaultArgs<ExtArgs>>): Prisma__crewsClient<$Result.GetResult<Prisma.$crewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the work_order_crew model
   */
  interface work_order_crewFieldRefs {
    readonly id: FieldRef<"work_order_crew", 'BigInt'>
    readonly work_order_id: FieldRef<"work_order_crew", 'BigInt'>
    readonly crew_id: FieldRef<"work_order_crew", 'BigInt'>
    readonly assigned_at: FieldRef<"work_order_crew", 'String'>
    readonly created_at: FieldRef<"work_order_crew", 'String'>
    readonly updated_at: FieldRef<"work_order_crew", 'String'>
  }
    

  // Custom InputTypes
  /**
   * work_order_crew findUnique
   */
  export type work_order_crewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * Filter, which work_order_crew to fetch.
     */
    where: work_order_crewWhereUniqueInput
  }

  /**
   * work_order_crew findUniqueOrThrow
   */
  export type work_order_crewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * Filter, which work_order_crew to fetch.
     */
    where: work_order_crewWhereUniqueInput
  }

  /**
   * work_order_crew findFirst
   */
  export type work_order_crewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * Filter, which work_order_crew to fetch.
     */
    where?: work_order_crewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_crews to fetch.
     */
    orderBy?: work_order_crewOrderByWithRelationInput | work_order_crewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_crews.
     */
    cursor?: work_order_crewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_crews.
     */
    distinct?: Work_order_crewScalarFieldEnum | Work_order_crewScalarFieldEnum[]
  }

  /**
   * work_order_crew findFirstOrThrow
   */
  export type work_order_crewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * Filter, which work_order_crew to fetch.
     */
    where?: work_order_crewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_crews to fetch.
     */
    orderBy?: work_order_crewOrderByWithRelationInput | work_order_crewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_crews.
     */
    cursor?: work_order_crewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_crews.
     */
    distinct?: Work_order_crewScalarFieldEnum | Work_order_crewScalarFieldEnum[]
  }

  /**
   * work_order_crew findMany
   */
  export type work_order_crewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * Filter, which work_order_crews to fetch.
     */
    where?: work_order_crewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_crews to fetch.
     */
    orderBy?: work_order_crewOrderByWithRelationInput | work_order_crewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing work_order_crews.
     */
    cursor?: work_order_crewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_crews.
     */
    skip?: number
    distinct?: Work_order_crewScalarFieldEnum | Work_order_crewScalarFieldEnum[]
  }

  /**
   * work_order_crew create
   */
  export type work_order_crewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * The data needed to create a work_order_crew.
     */
    data: XOR<work_order_crewCreateInput, work_order_crewUncheckedCreateInput>
  }

  /**
   * work_order_crew createMany
   */
  export type work_order_crewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many work_order_crews.
     */
    data: work_order_crewCreateManyInput | work_order_crewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * work_order_crew createManyAndReturn
   */
  export type work_order_crewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * The data used to create many work_order_crews.
     */
    data: work_order_crewCreateManyInput | work_order_crewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_crew update
   */
  export type work_order_crewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * The data needed to update a work_order_crew.
     */
    data: XOR<work_order_crewUpdateInput, work_order_crewUncheckedUpdateInput>
    /**
     * Choose, which work_order_crew to update.
     */
    where: work_order_crewWhereUniqueInput
  }

  /**
   * work_order_crew updateMany
   */
  export type work_order_crewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update work_order_crews.
     */
    data: XOR<work_order_crewUpdateManyMutationInput, work_order_crewUncheckedUpdateManyInput>
    /**
     * Filter which work_order_crews to update
     */
    where?: work_order_crewWhereInput
    /**
     * Limit how many work_order_crews to update.
     */
    limit?: number
  }

  /**
   * work_order_crew updateManyAndReturn
   */
  export type work_order_crewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * The data used to update work_order_crews.
     */
    data: XOR<work_order_crewUpdateManyMutationInput, work_order_crewUncheckedUpdateManyInput>
    /**
     * Filter which work_order_crews to update
     */
    where?: work_order_crewWhereInput
    /**
     * Limit how many work_order_crews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_crew upsert
   */
  export type work_order_crewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * The filter to search for the work_order_crew to update in case it exists.
     */
    where: work_order_crewWhereUniqueInput
    /**
     * In case the work_order_crew found by the `where` argument doesn't exist, create a new work_order_crew with this data.
     */
    create: XOR<work_order_crewCreateInput, work_order_crewUncheckedCreateInput>
    /**
     * In case the work_order_crew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<work_order_crewUpdateInput, work_order_crewUncheckedUpdateInput>
  }

  /**
   * work_order_crew delete
   */
  export type work_order_crewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
    /**
     * Filter which work_order_crew to delete.
     */
    where: work_order_crewWhereUniqueInput
  }

  /**
   * work_order_crew deleteMany
   */
  export type work_order_crewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_crews to delete
     */
    where?: work_order_crewWhereInput
    /**
     * Limit how many work_order_crews to delete.
     */
    limit?: number
  }

  /**
   * work_order_crew without action
   */
  export type work_order_crewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_crew
     */
    select?: work_order_crewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_crew
     */
    omit?: work_order_crewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_crewInclude<ExtArgs> | null
  }


  /**
   * Model work_order_approvals
   */

  export type AggregateWork_order_approvals = {
    _count: Work_order_approvalsCountAggregateOutputType | null
    _avg: Work_order_approvalsAvgAggregateOutputType | null
    _sum: Work_order_approvalsSumAggregateOutputType | null
    _min: Work_order_approvalsMinAggregateOutputType | null
    _max: Work_order_approvalsMaxAggregateOutputType | null
  }

  export type Work_order_approvalsAvgAggregateOutputType = {
    id: number | null
    work_order_id: number | null
    approved_by: number | null
  }

  export type Work_order_approvalsSumAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    approved_by: bigint | null
  }

  export type Work_order_approvalsMinAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    approved_by: bigint | null
    approval_status: $Enums.ApprovalStatus | null
    approved_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_approvalsMaxAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    approved_by: bigint | null
    approval_status: $Enums.ApprovalStatus | null
    approved_at: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Work_order_approvalsCountAggregateOutputType = {
    id: number
    work_order_id: number
    approved_by: number
    approval_status: number
    approved_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Work_order_approvalsAvgAggregateInputType = {
    id?: true
    work_order_id?: true
    approved_by?: true
  }

  export type Work_order_approvalsSumAggregateInputType = {
    id?: true
    work_order_id?: true
    approved_by?: true
  }

  export type Work_order_approvalsMinAggregateInputType = {
    id?: true
    work_order_id?: true
    approved_by?: true
    approval_status?: true
    approved_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_approvalsMaxAggregateInputType = {
    id?: true
    work_order_id?: true
    approved_by?: true
    approval_status?: true
    approved_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Work_order_approvalsCountAggregateInputType = {
    id?: true
    work_order_id?: true
    approved_by?: true
    approval_status?: true
    approved_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Work_order_approvalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_approvals to aggregate.
     */
    where?: work_order_approvalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_approvals to fetch.
     */
    orderBy?: work_order_approvalsOrderByWithRelationInput | work_order_approvalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: work_order_approvalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned work_order_approvals
    **/
    _count?: true | Work_order_approvalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Work_order_approvalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Work_order_approvalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Work_order_approvalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Work_order_approvalsMaxAggregateInputType
  }

  export type GetWork_order_approvalsAggregateType<T extends Work_order_approvalsAggregateArgs> = {
        [P in keyof T & keyof AggregateWork_order_approvals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork_order_approvals[P]>
      : GetScalarType<T[P], AggregateWork_order_approvals[P]>
  }




  export type work_order_approvalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: work_order_approvalsWhereInput
    orderBy?: work_order_approvalsOrderByWithAggregationInput | work_order_approvalsOrderByWithAggregationInput[]
    by: Work_order_approvalsScalarFieldEnum[] | Work_order_approvalsScalarFieldEnum
    having?: work_order_approvalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Work_order_approvalsCountAggregateInputType | true
    _avg?: Work_order_approvalsAvgAggregateInputType
    _sum?: Work_order_approvalsSumAggregateInputType
    _min?: Work_order_approvalsMinAggregateInputType
    _max?: Work_order_approvalsMaxAggregateInputType
  }

  export type Work_order_approvalsGroupByOutputType = {
    id: bigint
    work_order_id: bigint
    approved_by: bigint
    approval_status: $Enums.ApprovalStatus
    approved_at: string
    created_at: string
    updated_at: string
    _count: Work_order_approvalsCountAggregateOutputType | null
    _avg: Work_order_approvalsAvgAggregateOutputType | null
    _sum: Work_order_approvalsSumAggregateOutputType | null
    _min: Work_order_approvalsMinAggregateOutputType | null
    _max: Work_order_approvalsMaxAggregateOutputType | null
  }

  type GetWork_order_approvalsGroupByPayload<T extends work_order_approvalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Work_order_approvalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Work_order_approvalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Work_order_approvalsGroupByOutputType[P]>
            : GetScalarType<T[P], Work_order_approvalsGroupByOutputType[P]>
        }
      >
    >


  export type work_order_approvalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    approved_by?: boolean
    approval_status?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_approvals"]>

  export type work_order_approvalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    approved_by?: boolean
    approval_status?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_approvals"]>

  export type work_order_approvalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    approved_by?: boolean
    approval_status?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["work_order_approvals"]>

  export type work_order_approvalsSelectScalar = {
    id?: boolean
    work_order_id?: boolean
    approved_by?: boolean
    approval_status?: boolean
    approved_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type work_order_approvalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "work_order_id" | "approved_by" | "approval_status" | "approved_at" | "created_at" | "updated_at", ExtArgs["result"]["work_order_approvals"]>
  export type work_order_approvalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }
  export type work_order_approvalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }
  export type work_order_approvalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }

  export type $work_order_approvalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "work_order_approvals"
    objects: {
      work_orders: Prisma.$work_ordersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      work_order_id: bigint
      approved_by: bigint
      approval_status: $Enums.ApprovalStatus
      approved_at: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["work_order_approvals"]>
    composites: {}
  }

  type work_order_approvalsGetPayload<S extends boolean | null | undefined | work_order_approvalsDefaultArgs> = $Result.GetResult<Prisma.$work_order_approvalsPayload, S>

  type work_order_approvalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<work_order_approvalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Work_order_approvalsCountAggregateInputType | true
    }

  export interface work_order_approvalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['work_order_approvals'], meta: { name: 'work_order_approvals' } }
    /**
     * Find zero or one Work_order_approvals that matches the filter.
     * @param {work_order_approvalsFindUniqueArgs} args - Arguments to find a Work_order_approvals
     * @example
     * // Get one Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends work_order_approvalsFindUniqueArgs>(args: SelectSubset<T, work_order_approvalsFindUniqueArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Work_order_approvals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {work_order_approvalsFindUniqueOrThrowArgs} args - Arguments to find a Work_order_approvals
     * @example
     * // Get one Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends work_order_approvalsFindUniqueOrThrowArgs>(args: SelectSubset<T, work_order_approvalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_approvalsFindFirstArgs} args - Arguments to find a Work_order_approvals
     * @example
     * // Get one Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends work_order_approvalsFindFirstArgs>(args?: SelectSubset<T, work_order_approvalsFindFirstArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Work_order_approvals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_approvalsFindFirstOrThrowArgs} args - Arguments to find a Work_order_approvals
     * @example
     * // Get one Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends work_order_approvalsFindFirstOrThrowArgs>(args?: SelectSubset<T, work_order_approvalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Work_order_approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_approvalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.findMany()
     * 
     * // Get first 10 Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const work_order_approvalsWithIdOnly = await prisma.work_order_approvals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends work_order_approvalsFindManyArgs>(args?: SelectSubset<T, work_order_approvalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Work_order_approvals.
     * @param {work_order_approvalsCreateArgs} args - Arguments to create a Work_order_approvals.
     * @example
     * // Create one Work_order_approvals
     * const Work_order_approvals = await prisma.work_order_approvals.create({
     *   data: {
     *     // ... data to create a Work_order_approvals
     *   }
     * })
     * 
     */
    create<T extends work_order_approvalsCreateArgs>(args: SelectSubset<T, work_order_approvalsCreateArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Work_order_approvals.
     * @param {work_order_approvalsCreateManyArgs} args - Arguments to create many Work_order_approvals.
     * @example
     * // Create many Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends work_order_approvalsCreateManyArgs>(args?: SelectSubset<T, work_order_approvalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Work_order_approvals and returns the data saved in the database.
     * @param {work_order_approvalsCreateManyAndReturnArgs} args - Arguments to create many Work_order_approvals.
     * @example
     * // Create many Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Work_order_approvals and only return the `id`
     * const work_order_approvalsWithIdOnly = await prisma.work_order_approvals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends work_order_approvalsCreateManyAndReturnArgs>(args?: SelectSubset<T, work_order_approvalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Work_order_approvals.
     * @param {work_order_approvalsDeleteArgs} args - Arguments to delete one Work_order_approvals.
     * @example
     * // Delete one Work_order_approvals
     * const Work_order_approvals = await prisma.work_order_approvals.delete({
     *   where: {
     *     // ... filter to delete one Work_order_approvals
     *   }
     * })
     * 
     */
    delete<T extends work_order_approvalsDeleteArgs>(args: SelectSubset<T, work_order_approvalsDeleteArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Work_order_approvals.
     * @param {work_order_approvalsUpdateArgs} args - Arguments to update one Work_order_approvals.
     * @example
     * // Update one Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends work_order_approvalsUpdateArgs>(args: SelectSubset<T, work_order_approvalsUpdateArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Work_order_approvals.
     * @param {work_order_approvalsDeleteManyArgs} args - Arguments to filter Work_order_approvals to delete.
     * @example
     * // Delete a few Work_order_approvals
     * const { count } = await prisma.work_order_approvals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends work_order_approvalsDeleteManyArgs>(args?: SelectSubset<T, work_order_approvalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_approvalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends work_order_approvalsUpdateManyArgs>(args: SelectSubset<T, work_order_approvalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Work_order_approvals and returns the data updated in the database.
     * @param {work_order_approvalsUpdateManyAndReturnArgs} args - Arguments to update many Work_order_approvals.
     * @example
     * // Update many Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Work_order_approvals and only return the `id`
     * const work_order_approvalsWithIdOnly = await prisma.work_order_approvals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends work_order_approvalsUpdateManyAndReturnArgs>(args: SelectSubset<T, work_order_approvalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Work_order_approvals.
     * @param {work_order_approvalsUpsertArgs} args - Arguments to update or create a Work_order_approvals.
     * @example
     * // Update or create a Work_order_approvals
     * const work_order_approvals = await prisma.work_order_approvals.upsert({
     *   create: {
     *     // ... data to create a Work_order_approvals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work_order_approvals we want to update
     *   }
     * })
     */
    upsert<T extends work_order_approvalsUpsertArgs>(args: SelectSubset<T, work_order_approvalsUpsertArgs<ExtArgs>>): Prisma__work_order_approvalsClient<$Result.GetResult<Prisma.$work_order_approvalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Work_order_approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_approvalsCountArgs} args - Arguments to filter Work_order_approvals to count.
     * @example
     * // Count the number of Work_order_approvals
     * const count = await prisma.work_order_approvals.count({
     *   where: {
     *     // ... the filter for the Work_order_approvals we want to count
     *   }
     * })
    **/
    count<T extends work_order_approvalsCountArgs>(
      args?: Subset<T, work_order_approvalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Work_order_approvalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work_order_approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Work_order_approvalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Work_order_approvalsAggregateArgs>(args: Subset<T, Work_order_approvalsAggregateArgs>): Prisma.PrismaPromise<GetWork_order_approvalsAggregateType<T>>

    /**
     * Group by Work_order_approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {work_order_approvalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends work_order_approvalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: work_order_approvalsGroupByArgs['orderBy'] }
        : { orderBy?: work_order_approvalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, work_order_approvalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWork_order_approvalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the work_order_approvals model
   */
  readonly fields: work_order_approvalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for work_order_approvals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__work_order_approvalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work_orders<T extends work_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, work_ordersDefaultArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the work_order_approvals model
   */
  interface work_order_approvalsFieldRefs {
    readonly id: FieldRef<"work_order_approvals", 'BigInt'>
    readonly work_order_id: FieldRef<"work_order_approvals", 'BigInt'>
    readonly approved_by: FieldRef<"work_order_approvals", 'BigInt'>
    readonly approval_status: FieldRef<"work_order_approvals", 'ApprovalStatus'>
    readonly approved_at: FieldRef<"work_order_approvals", 'String'>
    readonly created_at: FieldRef<"work_order_approvals", 'String'>
    readonly updated_at: FieldRef<"work_order_approvals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * work_order_approvals findUnique
   */
  export type work_order_approvalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_approvals to fetch.
     */
    where: work_order_approvalsWhereUniqueInput
  }

  /**
   * work_order_approvals findUniqueOrThrow
   */
  export type work_order_approvalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_approvals to fetch.
     */
    where: work_order_approvalsWhereUniqueInput
  }

  /**
   * work_order_approvals findFirst
   */
  export type work_order_approvalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_approvals to fetch.
     */
    where?: work_order_approvalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_approvals to fetch.
     */
    orderBy?: work_order_approvalsOrderByWithRelationInput | work_order_approvalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_approvals.
     */
    cursor?: work_order_approvalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_approvals.
     */
    distinct?: Work_order_approvalsScalarFieldEnum | Work_order_approvalsScalarFieldEnum[]
  }

  /**
   * work_order_approvals findFirstOrThrow
   */
  export type work_order_approvalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_approvals to fetch.
     */
    where?: work_order_approvalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_approvals to fetch.
     */
    orderBy?: work_order_approvalsOrderByWithRelationInput | work_order_approvalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for work_order_approvals.
     */
    cursor?: work_order_approvalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of work_order_approvals.
     */
    distinct?: Work_order_approvalsScalarFieldEnum | Work_order_approvalsScalarFieldEnum[]
  }

  /**
   * work_order_approvals findMany
   */
  export type work_order_approvalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * Filter, which work_order_approvals to fetch.
     */
    where?: work_order_approvalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of work_order_approvals to fetch.
     */
    orderBy?: work_order_approvalsOrderByWithRelationInput | work_order_approvalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing work_order_approvals.
     */
    cursor?: work_order_approvalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` work_order_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` work_order_approvals.
     */
    skip?: number
    distinct?: Work_order_approvalsScalarFieldEnum | Work_order_approvalsScalarFieldEnum[]
  }

  /**
   * work_order_approvals create
   */
  export type work_order_approvalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * The data needed to create a work_order_approvals.
     */
    data: XOR<work_order_approvalsCreateInput, work_order_approvalsUncheckedCreateInput>
  }

  /**
   * work_order_approvals createMany
   */
  export type work_order_approvalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many work_order_approvals.
     */
    data: work_order_approvalsCreateManyInput | work_order_approvalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * work_order_approvals createManyAndReturn
   */
  export type work_order_approvalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * The data used to create many work_order_approvals.
     */
    data: work_order_approvalsCreateManyInput | work_order_approvalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_approvals update
   */
  export type work_order_approvalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * The data needed to update a work_order_approvals.
     */
    data: XOR<work_order_approvalsUpdateInput, work_order_approvalsUncheckedUpdateInput>
    /**
     * Choose, which work_order_approvals to update.
     */
    where: work_order_approvalsWhereUniqueInput
  }

  /**
   * work_order_approvals updateMany
   */
  export type work_order_approvalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update work_order_approvals.
     */
    data: XOR<work_order_approvalsUpdateManyMutationInput, work_order_approvalsUncheckedUpdateManyInput>
    /**
     * Filter which work_order_approvals to update
     */
    where?: work_order_approvalsWhereInput
    /**
     * Limit how many work_order_approvals to update.
     */
    limit?: number
  }

  /**
   * work_order_approvals updateManyAndReturn
   */
  export type work_order_approvalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * The data used to update work_order_approvals.
     */
    data: XOR<work_order_approvalsUpdateManyMutationInput, work_order_approvalsUncheckedUpdateManyInput>
    /**
     * Filter which work_order_approvals to update
     */
    where?: work_order_approvalsWhereInput
    /**
     * Limit how many work_order_approvals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * work_order_approvals upsert
   */
  export type work_order_approvalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * The filter to search for the work_order_approvals to update in case it exists.
     */
    where: work_order_approvalsWhereUniqueInput
    /**
     * In case the work_order_approvals found by the `where` argument doesn't exist, create a new work_order_approvals with this data.
     */
    create: XOR<work_order_approvalsCreateInput, work_order_approvalsUncheckedCreateInput>
    /**
     * In case the work_order_approvals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<work_order_approvalsUpdateInput, work_order_approvalsUncheckedUpdateInput>
  }

  /**
   * work_order_approvals delete
   */
  export type work_order_approvalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
    /**
     * Filter which work_order_approvals to delete.
     */
    where: work_order_approvalsWhereUniqueInput
  }

  /**
   * work_order_approvals deleteMany
   */
  export type work_order_approvalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which work_order_approvals to delete
     */
    where?: work_order_approvalsWhereInput
    /**
     * Limit how many work_order_approvals to delete.
     */
    limit?: number
  }

  /**
   * work_order_approvals without action
   */
  export type work_order_approvalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the work_order_approvals
     */
    select?: work_order_approvalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the work_order_approvals
     */
    omit?: work_order_approvalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: work_order_approvalsInclude<ExtArgs> | null
  }


  /**
   * Model invoices
   */

  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  export type InvoicesAvgAggregateOutputType = {
    id: number | null
    work_order_id: number | null
    total_amount: Decimal | null
    currency_id: number | null
  }

  export type InvoicesSumAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    total_amount: Decimal | null
    currency_id: number | null
  }

  export type InvoicesMinAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    invoice_number: string | null
    invoice_date: string | null
    due_date: string | null
    total_amount: Decimal | null
    status: $Enums.InvoiceStatus | null
    currency_id: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type InvoicesMaxAggregateOutputType = {
    id: bigint | null
    work_order_id: bigint | null
    invoice_number: string | null
    invoice_date: string | null
    due_date: string | null
    total_amount: Decimal | null
    status: $Enums.InvoiceStatus | null
    currency_id: number | null
    created_at: string | null
    updated_at: string | null
  }

  export type InvoicesCountAggregateOutputType = {
    id: number
    work_order_id: number
    invoice_number: number
    invoice_date: number
    due_date: number
    total_amount: number
    status: number
    currency_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvoicesAvgAggregateInputType = {
    id?: true
    work_order_id?: true
    total_amount?: true
    currency_id?: true
  }

  export type InvoicesSumAggregateInputType = {
    id?: true
    work_order_id?: true
    total_amount?: true
    currency_id?: true
  }

  export type InvoicesMinAggregateInputType = {
    id?: true
    work_order_id?: true
    invoice_number?: true
    invoice_date?: true
    due_date?: true
    total_amount?: true
    status?: true
    currency_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoicesMaxAggregateInputType = {
    id?: true
    work_order_id?: true
    invoice_number?: true
    invoice_date?: true
    due_date?: true
    total_amount?: true
    status?: true
    currency_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoicesCountAggregateInputType = {
    id?: true
    work_order_id?: true
    invoice_number?: true
    invoice_date?: true
    due_date?: true
    total_amount?: true
    status?: true
    currency_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to aggregate.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoices
    **/
    _count?: true | InvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicesMaxAggregateInputType
  }

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>
  }




  export type invoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithAggregationInput | invoicesOrderByWithAggregationInput[]
    by: InvoicesScalarFieldEnum[] | InvoicesScalarFieldEnum
    having?: invoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicesCountAggregateInputType | true
    _avg?: InvoicesAvgAggregateInputType
    _sum?: InvoicesSumAggregateInputType
    _min?: InvoicesMinAggregateInputType
    _max?: InvoicesMaxAggregateInputType
  }

  export type InvoicesGroupByOutputType = {
    id: bigint
    work_order_id: bigint
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  type GetInvoicesGroupByPayload<T extends invoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
        }
      >
    >


  export type invoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    invoice_number?: boolean
    invoice_date?: boolean
    due_date?: boolean
    total_amount?: boolean
    status?: boolean
    currency_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    invoice_items?: boolean | invoices$invoice_itemsArgs<ExtArgs>
    payments?: boolean | invoices$paymentsArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type invoicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    invoice_number?: boolean
    invoice_date?: boolean
    due_date?: boolean
    total_amount?: boolean
    status?: boolean
    currency_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type invoicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work_order_id?: boolean
    invoice_number?: boolean
    invoice_date?: boolean
    due_date?: boolean
    total_amount?: boolean
    status?: boolean
    currency_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type invoicesSelectScalar = {
    id?: boolean
    work_order_id?: boolean
    invoice_number?: boolean
    invoice_date?: boolean
    due_date?: boolean
    total_amount?: boolean
    status?: boolean
    currency_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type invoicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "work_order_id" | "invoice_number" | "invoice_date" | "due_date" | "total_amount" | "status" | "currency_id" | "created_at" | "updated_at", ExtArgs["result"]["invoices"]>
  export type invoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
    invoice_items?: boolean | invoices$invoice_itemsArgs<ExtArgs>
    payments?: boolean | invoices$paymentsArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type invoicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }
  export type invoicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    work_orders?: boolean | work_ordersDefaultArgs<ExtArgs>
  }

  export type $invoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoices"
    objects: {
      work_orders: Prisma.$work_ordersPayload<ExtArgs>
      invoice_items: Prisma.$invoice_itemsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      work_order_id: bigint
      invoice_number: string
      invoice_date: string
      due_date: string
      total_amount: Prisma.Decimal
      status: $Enums.InvoiceStatus
      currency_id: number
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["invoices"]>
    composites: {}
  }

  type invoicesGetPayload<S extends boolean | null | undefined | invoicesDefaultArgs> = $Result.GetResult<Prisma.$invoicesPayload, S>

  type invoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicesCountAggregateInputType | true
    }

  export interface invoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoices'], meta: { name: 'invoices' } }
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {invoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoicesFindUniqueArgs>(args: SelectSubset<T, invoicesFindUniqueArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, invoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoicesFindFirstArgs>(args?: SelectSubset<T, invoicesFindFirstArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, invoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicesWithIdOnly = await prisma.invoices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoicesFindManyArgs>(args?: SelectSubset<T, invoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoices.
     * @param {invoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     * 
     */
    create<T extends invoicesCreateArgs>(args: SelectSubset<T, invoicesCreateArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {invoicesCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoicesCreateManyArgs>(args?: SelectSubset<T, invoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {invoicesCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoicesWithIdOnly = await prisma.invoices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoicesCreateManyAndReturnArgs>(args?: SelectSubset<T, invoicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoices.
     * @param {invoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     * 
     */
    delete<T extends invoicesDeleteArgs>(args: SelectSubset<T, invoicesDeleteArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoices.
     * @param {invoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoicesUpdateArgs>(args: SelectSubset<T, invoicesUpdateArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {invoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoicesDeleteManyArgs>(args?: SelectSubset<T, invoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoicesUpdateManyArgs>(args: SelectSubset<T, invoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {invoicesUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoicesWithIdOnly = await prisma.invoices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoicesUpdateManyAndReturnArgs>(args: SelectSubset<T, invoicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoices.
     * @param {invoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
     */
    upsert<T extends invoicesUpsertArgs>(args: SelectSubset<T, invoicesUpsertArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends invoicesCountArgs>(
      args?: Subset<T, invoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicesAggregateArgs>(args: Subset<T, InvoicesAggregateArgs>): Prisma.PrismaPromise<GetInvoicesAggregateType<T>>

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoicesGroupByArgs['orderBy'] }
        : { orderBy?: invoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoices model
   */
  readonly fields: invoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    work_orders<T extends work_ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, work_ordersDefaultArgs<ExtArgs>>): Prisma__work_ordersClient<$Result.GetResult<Prisma.$work_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice_items<T extends invoices$invoice_itemsArgs<ExtArgs> = {}>(args?: Subset<T, invoices$invoice_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends invoices$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, invoices$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoices model
   */
  interface invoicesFieldRefs {
    readonly id: FieldRef<"invoices", 'BigInt'>
    readonly work_order_id: FieldRef<"invoices", 'BigInt'>
    readonly invoice_number: FieldRef<"invoices", 'String'>
    readonly invoice_date: FieldRef<"invoices", 'String'>
    readonly due_date: FieldRef<"invoices", 'String'>
    readonly total_amount: FieldRef<"invoices", 'Decimal'>
    readonly status: FieldRef<"invoices", 'InvoiceStatus'>
    readonly currency_id: FieldRef<"invoices", 'Int'>
    readonly created_at: FieldRef<"invoices", 'String'>
    readonly updated_at: FieldRef<"invoices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * invoices findUnique
   */
  export type invoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices findUniqueOrThrow
   */
  export type invoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices findFirst
   */
  export type invoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices findFirstOrThrow
   */
  export type invoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices findMany
   */
  export type invoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices create
   */
  export type invoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a invoices.
     */
    data: XOR<invoicesCreateInput, invoicesUncheckedCreateInput>
  }

  /**
   * invoices createMany
   */
  export type invoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoices.
     */
    data: invoicesCreateManyInput | invoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoices createManyAndReturn
   */
  export type invoicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * The data used to create many invoices.
     */
    data: invoicesCreateManyInput | invoicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoices update
   */
  export type invoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a invoices.
     */
    data: XOR<invoicesUpdateInput, invoicesUncheckedUpdateInput>
    /**
     * Choose, which invoices to update.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices updateMany
   */
  export type invoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoices.
     */
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
  }

  /**
   * invoices updateManyAndReturn
   */
  export type invoicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * The data used to update invoices.
     */
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoices upsert
   */
  export type invoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the invoices to update in case it exists.
     */
    where: invoicesWhereUniqueInput
    /**
     * In case the invoices found by the `where` argument doesn't exist, create a new invoices with this data.
     */
    create: XOR<invoicesCreateInput, invoicesUncheckedCreateInput>
    /**
     * In case the invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoicesUpdateInput, invoicesUncheckedUpdateInput>
  }

  /**
   * invoices delete
   */
  export type invoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter which invoices to delete.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices deleteMany
   */
  export type invoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to delete
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to delete.
     */
    limit?: number
  }

  /**
   * invoices.invoice_items
   */
  export type invoices$invoice_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    cursor?: invoice_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoices.payments
   */
  export type invoices$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * invoices without action
   */
  export type invoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
  }


  /**
   * Model invoice_items
   */

  export type AggregateInvoice_items = {
    _count: Invoice_itemsCountAggregateOutputType | null
    _avg: Invoice_itemsAvgAggregateOutputType | null
    _sum: Invoice_itemsSumAggregateOutputType | null
    _min: Invoice_itemsMinAggregateOutputType | null
    _max: Invoice_itemsMaxAggregateOutputType | null
  }

  export type Invoice_itemsAvgAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    service_id: number | null
    part_id: number | null
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
  }

  export type Invoice_itemsSumAggregateOutputType = {
    id: bigint | null
    invoice_id: bigint | null
    service_id: bigint | null
    part_id: bigint | null
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
  }

  export type Invoice_itemsMinAggregateOutputType = {
    id: bigint | null
    invoice_id: bigint | null
    service_id: bigint | null
    part_id: bigint | null
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
    description: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Invoice_itemsMaxAggregateOutputType = {
    id: bigint | null
    invoice_id: bigint | null
    service_id: bigint | null
    part_id: bigint | null
    quantity: number | null
    unit_price: Decimal | null
    total_price: Decimal | null
    description: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Invoice_itemsCountAggregateOutputType = {
    id: number
    invoice_id: number
    service_id: number
    part_id: number
    quantity: number
    unit_price: number
    total_price: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Invoice_itemsAvgAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    part_id?: true
    quantity?: true
    unit_price?: true
    total_price?: true
  }

  export type Invoice_itemsSumAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    part_id?: true
    quantity?: true
    unit_price?: true
    total_price?: true
  }

  export type Invoice_itemsMinAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    part_id?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Invoice_itemsMaxAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    part_id?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Invoice_itemsCountAggregateInputType = {
    id?: true
    invoice_id?: true
    service_id?: true
    part_id?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Invoice_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_items to aggregate.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoice_items
    **/
    _count?: true | Invoice_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Invoice_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Invoice_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Invoice_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Invoice_itemsMaxAggregateInputType
  }

  export type GetInvoice_itemsAggregateType<T extends Invoice_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice_items[P]>
      : GetScalarType<T[P], AggregateInvoice_items[P]>
  }




  export type invoice_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoice_itemsWhereInput
    orderBy?: invoice_itemsOrderByWithAggregationInput | invoice_itemsOrderByWithAggregationInput[]
    by: Invoice_itemsScalarFieldEnum[] | Invoice_itemsScalarFieldEnum
    having?: invoice_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Invoice_itemsCountAggregateInputType | true
    _avg?: Invoice_itemsAvgAggregateInputType
    _sum?: Invoice_itemsSumAggregateInputType
    _min?: Invoice_itemsMinAggregateInputType
    _max?: Invoice_itemsMaxAggregateInputType
  }

  export type Invoice_itemsGroupByOutputType = {
    id: bigint
    invoice_id: bigint
    service_id: bigint
    part_id: bigint
    quantity: number
    unit_price: Decimal
    total_price: Decimal
    description: string
    created_at: string
    updated_at: string
    _count: Invoice_itemsCountAggregateOutputType | null
    _avg: Invoice_itemsAvgAggregateOutputType | null
    _sum: Invoice_itemsSumAggregateOutputType | null
    _min: Invoice_itemsMinAggregateOutputType | null
    _max: Invoice_itemsMaxAggregateOutputType | null
  }

  type GetInvoice_itemsGroupByPayload<T extends invoice_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Invoice_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Invoice_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Invoice_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Invoice_itemsGroupByOutputType[P]>
        }
      >
    >


  export type invoice_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    part_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    parts?: boolean | partsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_items"]>

  export type invoice_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    part_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    parts?: boolean | partsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_items"]>

  export type invoice_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    part_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    parts?: boolean | partsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_items"]>

  export type invoice_itemsSelectScalar = {
    id?: boolean
    invoice_id?: boolean
    service_id?: boolean
    part_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type invoice_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_id" | "service_id" | "part_id" | "quantity" | "unit_price" | "total_price" | "description" | "created_at" | "updated_at", ExtArgs["result"]["invoice_items"]>
  export type invoice_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    parts?: boolean | partsDefaultArgs<ExtArgs>
  }
  export type invoice_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    parts?: boolean | partsDefaultArgs<ExtArgs>
  }
  export type invoice_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
    services?: boolean | servicesDefaultArgs<ExtArgs>
    parts?: boolean | partsDefaultArgs<ExtArgs>
  }

  export type $invoice_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoice_items"
    objects: {
      invoices: Prisma.$invoicesPayload<ExtArgs>
      services: Prisma.$servicesPayload<ExtArgs>
      parts: Prisma.$partsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      invoice_id: bigint
      service_id: bigint
      part_id: bigint
      quantity: number
      unit_price: Prisma.Decimal
      total_price: Prisma.Decimal
      description: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["invoice_items"]>
    composites: {}
  }

  type invoice_itemsGetPayload<S extends boolean | null | undefined | invoice_itemsDefaultArgs> = $Result.GetResult<Prisma.$invoice_itemsPayload, S>

  type invoice_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoice_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Invoice_itemsCountAggregateInputType | true
    }

  export interface invoice_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoice_items'], meta: { name: 'invoice_items' } }
    /**
     * Find zero or one Invoice_items that matches the filter.
     * @param {invoice_itemsFindUniqueArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoice_itemsFindUniqueArgs>(args: SelectSubset<T, invoice_itemsFindUniqueArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoice_itemsFindUniqueOrThrowArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoice_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, invoice_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsFindFirstArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoice_itemsFindFirstArgs>(args?: SelectSubset<T, invoice_itemsFindFirstArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsFindFirstOrThrowArgs} args - Arguments to find a Invoice_items
     * @example
     * // Get one Invoice_items
     * const invoice_items = await prisma.invoice_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoice_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, invoice_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoice_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoice_items
     * const invoice_items = await prisma.invoice_items.findMany()
     * 
     * // Get first 10 Invoice_items
     * const invoice_items = await prisma.invoice_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoice_itemsWithIdOnly = await prisma.invoice_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoice_itemsFindManyArgs>(args?: SelectSubset<T, invoice_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice_items.
     * @param {invoice_itemsCreateArgs} args - Arguments to create a Invoice_items.
     * @example
     * // Create one Invoice_items
     * const Invoice_items = await prisma.invoice_items.create({
     *   data: {
     *     // ... data to create a Invoice_items
     *   }
     * })
     * 
     */
    create<T extends invoice_itemsCreateArgs>(args: SelectSubset<T, invoice_itemsCreateArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoice_items.
     * @param {invoice_itemsCreateManyArgs} args - Arguments to create many Invoice_items.
     * @example
     * // Create many Invoice_items
     * const invoice_items = await prisma.invoice_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoice_itemsCreateManyArgs>(args?: SelectSubset<T, invoice_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoice_items and returns the data saved in the database.
     * @param {invoice_itemsCreateManyAndReturnArgs} args - Arguments to create many Invoice_items.
     * @example
     * // Create many Invoice_items
     * const invoice_items = await prisma.invoice_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoice_items and only return the `id`
     * const invoice_itemsWithIdOnly = await prisma.invoice_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoice_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, invoice_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice_items.
     * @param {invoice_itemsDeleteArgs} args - Arguments to delete one Invoice_items.
     * @example
     * // Delete one Invoice_items
     * const Invoice_items = await prisma.invoice_items.delete({
     *   where: {
     *     // ... filter to delete one Invoice_items
     *   }
     * })
     * 
     */
    delete<T extends invoice_itemsDeleteArgs>(args: SelectSubset<T, invoice_itemsDeleteArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice_items.
     * @param {invoice_itemsUpdateArgs} args - Arguments to update one Invoice_items.
     * @example
     * // Update one Invoice_items
     * const invoice_items = await prisma.invoice_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoice_itemsUpdateArgs>(args: SelectSubset<T, invoice_itemsUpdateArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoice_items.
     * @param {invoice_itemsDeleteManyArgs} args - Arguments to filter Invoice_items to delete.
     * @example
     * // Delete a few Invoice_items
     * const { count } = await prisma.invoice_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoice_itemsDeleteManyArgs>(args?: SelectSubset<T, invoice_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoice_items
     * const invoice_items = await prisma.invoice_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoice_itemsUpdateManyArgs>(args: SelectSubset<T, invoice_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_items and returns the data updated in the database.
     * @param {invoice_itemsUpdateManyAndReturnArgs} args - Arguments to update many Invoice_items.
     * @example
     * // Update many Invoice_items
     * const invoice_items = await prisma.invoice_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoice_items and only return the `id`
     * const invoice_itemsWithIdOnly = await prisma.invoice_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoice_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, invoice_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice_items.
     * @param {invoice_itemsUpsertArgs} args - Arguments to update or create a Invoice_items.
     * @example
     * // Update or create a Invoice_items
     * const invoice_items = await prisma.invoice_items.upsert({
     *   create: {
     *     // ... data to create a Invoice_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice_items we want to update
     *   }
     * })
     */
    upsert<T extends invoice_itemsUpsertArgs>(args: SelectSubset<T, invoice_itemsUpsertArgs<ExtArgs>>): Prisma__invoice_itemsClient<$Result.GetResult<Prisma.$invoice_itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsCountArgs} args - Arguments to filter Invoice_items to count.
     * @example
     * // Count the number of Invoice_items
     * const count = await prisma.invoice_items.count({
     *   where: {
     *     // ... the filter for the Invoice_items we want to count
     *   }
     * })
    **/
    count<T extends invoice_itemsCountArgs>(
      args?: Subset<T, invoice_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invoice_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invoice_itemsAggregateArgs>(args: Subset<T, Invoice_itemsAggregateArgs>): Prisma.PrismaPromise<GetInvoice_itemsAggregateType<T>>

    /**
     * Group by Invoice_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoice_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoice_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoice_itemsGroupByArgs['orderBy'] }
        : { orderBy?: invoice_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoice_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoice_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoice_items model
   */
  readonly fields: invoice_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoice_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends invoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoicesDefaultArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends servicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, servicesDefaultArgs<ExtArgs>>): Prisma__servicesClient<$Result.GetResult<Prisma.$servicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parts<T extends partsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, partsDefaultArgs<ExtArgs>>): Prisma__partsClient<$Result.GetResult<Prisma.$partsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoice_items model
   */
  interface invoice_itemsFieldRefs {
    readonly id: FieldRef<"invoice_items", 'BigInt'>
    readonly invoice_id: FieldRef<"invoice_items", 'BigInt'>
    readonly service_id: FieldRef<"invoice_items", 'BigInt'>
    readonly part_id: FieldRef<"invoice_items", 'BigInt'>
    readonly quantity: FieldRef<"invoice_items", 'Int'>
    readonly unit_price: FieldRef<"invoice_items", 'Decimal'>
    readonly total_price: FieldRef<"invoice_items", 'Decimal'>
    readonly description: FieldRef<"invoice_items", 'String'>
    readonly created_at: FieldRef<"invoice_items", 'String'>
    readonly updated_at: FieldRef<"invoice_items", 'String'>
  }
    

  // Custom InputTypes
  /**
   * invoice_items findUnique
   */
  export type invoice_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items findUniqueOrThrow
   */
  export type invoice_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items findFirst
   */
  export type invoice_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_items.
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_items.
     */
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoice_items findFirstOrThrow
   */
  export type invoice_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoice_items.
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoice_items.
     */
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoice_items findMany
   */
  export type invoice_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter, which invoice_items to fetch.
     */
    where?: invoice_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoice_items to fetch.
     */
    orderBy?: invoice_itemsOrderByWithRelationInput | invoice_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoice_items.
     */
    cursor?: invoice_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoice_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoice_items.
     */
    skip?: number
    distinct?: Invoice_itemsScalarFieldEnum | Invoice_itemsScalarFieldEnum[]
  }

  /**
   * invoice_items create
   */
  export type invoice_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a invoice_items.
     */
    data: XOR<invoice_itemsCreateInput, invoice_itemsUncheckedCreateInput>
  }

  /**
   * invoice_items createMany
   */
  export type invoice_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoice_items.
     */
    data: invoice_itemsCreateManyInput | invoice_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoice_items createManyAndReturn
   */
  export type invoice_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many invoice_items.
     */
    data: invoice_itemsCreateManyInput | invoice_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_items update
   */
  export type invoice_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a invoice_items.
     */
    data: XOR<invoice_itemsUpdateInput, invoice_itemsUncheckedUpdateInput>
    /**
     * Choose, which invoice_items to update.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items updateMany
   */
  export type invoice_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoice_items.
     */
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyInput>
    /**
     * Filter which invoice_items to update
     */
    where?: invoice_itemsWhereInput
    /**
     * Limit how many invoice_items to update.
     */
    limit?: number
  }

  /**
   * invoice_items updateManyAndReturn
   */
  export type invoice_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * The data used to update invoice_items.
     */
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyInput>
    /**
     * Filter which invoice_items to update
     */
    where?: invoice_itemsWhereInput
    /**
     * Limit how many invoice_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice_items upsert
   */
  export type invoice_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the invoice_items to update in case it exists.
     */
    where: invoice_itemsWhereUniqueInput
    /**
     * In case the invoice_items found by the `where` argument doesn't exist, create a new invoice_items with this data.
     */
    create: XOR<invoice_itemsCreateInput, invoice_itemsUncheckedCreateInput>
    /**
     * In case the invoice_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoice_itemsUpdateInput, invoice_itemsUncheckedUpdateInput>
  }

  /**
   * invoice_items delete
   */
  export type invoice_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
    /**
     * Filter which invoice_items to delete.
     */
    where: invoice_itemsWhereUniqueInput
  }

  /**
   * invoice_items deleteMany
   */
  export type invoice_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice_items to delete
     */
    where?: invoice_itemsWhereInput
    /**
     * Limit how many invoice_items to delete.
     */
    limit?: number
  }

  /**
   * invoice_items without action
   */
  export type invoice_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice_items
     */
    select?: invoice_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice_items
     */
    omit?: invoice_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoice_itemsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    payment_amount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: bigint | null
    invoice_id: bigint | null
    payment_amount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: bigint | null
    invoice_id: bigint | null
    payment_date: string | null
    payment_amount: Decimal | null
    payment_method: $Enums.PaymentMethod | null
    payment_status: $Enums.PaymentStatus | null
    transaction_id: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: bigint | null
    invoice_id: bigint | null
    payment_date: string | null
    payment_amount: Decimal | null
    payment_method: $Enums.PaymentMethod | null
    payment_status: $Enums.PaymentStatus | null
    transaction_id: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    invoice_id: number
    payment_date: number
    payment_amount: number
    payment_method: number
    payment_status: number
    transaction_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    invoice_id?: true
    payment_amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    invoice_id?: true
    payment_amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    invoice_id?: true
    payment_date?: true
    payment_amount?: true
    payment_method?: true
    payment_status?: true
    transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    invoice_id?: true
    payment_date?: true
    payment_amount?: true
    payment_method?: true
    payment_status?: true
    transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    invoice_id?: true
    payment_date?: true
    payment_amount?: true
    payment_method?: true
    payment_status?: true
    transaction_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: bigint
    invoice_id: bigint
    payment_date: string
    payment_amount: Decimal
    payment_method: $Enums.PaymentMethod
    payment_status: $Enums.PaymentStatus
    transaction_id: string
    created_at: string
    updated_at: string
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    payment_date?: boolean
    payment_amount?: boolean
    payment_method?: boolean
    payment_status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    payment_date?: boolean
    payment_amount?: boolean
    payment_method?: boolean
    payment_status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    payment_date?: boolean
    payment_amount?: boolean
    payment_method?: boolean
    payment_status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    invoice_id?: boolean
    payment_date?: boolean
    payment_amount?: boolean
    payment_method?: boolean
    payment_status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_id" | "payment_date" | "payment_amount" | "payment_method" | "payment_status" | "transaction_id" | "created_at" | "updated_at", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      invoices: Prisma.$invoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      invoice_id: bigint
      payment_date: string
      payment_amount: Prisma.Decimal
      payment_method: $Enums.PaymentMethod
      payment_status: $Enums.PaymentStatus
      transaction_id: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends invoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoicesDefaultArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'BigInt'>
    readonly invoice_id: FieldRef<"payments", 'BigInt'>
    readonly payment_date: FieldRef<"payments", 'String'>
    readonly payment_amount: FieldRef<"payments", 'Decimal'>
    readonly payment_method: FieldRef<"payments", 'PaymentMethod'>
    readonly payment_status: FieldRef<"payments", 'PaymentStatus'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'String'>
    readonly updated_at: FieldRef<"payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    notification_type: $Enums.NotificationType | null
    message: string | null
    status: $Enums.NotificationStatus | null
    created_at: string | null
    updated_at: string | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    notification_type: $Enums.NotificationType | null
    message: string | null
    status: $Enums.NotificationStatus | null
    created_at: string | null
    updated_at: string | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    user_id: number
    notification_type: number
    message: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    notification_type?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    notification_type?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    notification_type?: true
    message?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: bigint
    user_id: bigint
    notification_type: $Enums.NotificationType
    message: string
    status: $Enums.NotificationStatus
    created_at: string
    updated_at: string
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    notification_type?: boolean
    message?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "notification_type" | "message" | "status" | "created_at" | "updated_at", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      notification_type: $Enums.NotificationType
      message: string
      status: $Enums.NotificationStatus
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'BigInt'>
    readonly user_id: FieldRef<"notifications", 'BigInt'>
    readonly notification_type: FieldRef<"notifications", 'NotificationType'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly status: FieldRef<"notifications", 'NotificationStatus'>
    readonly created_at: FieldRef<"notifications", 'String'>
    readonly updated_at: FieldRef<"notifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model email_templates
   */

  export type AggregateEmail_templates = {
    _count: Email_templatesCountAggregateOutputType | null
    _avg: Email_templatesAvgAggregateOutputType | null
    _sum: Email_templatesSumAggregateOutputType | null
    _min: Email_templatesMinAggregateOutputType | null
    _max: Email_templatesMaxAggregateOutputType | null
  }

  export type Email_templatesAvgAggregateOutputType = {
    id: number | null
  }

  export type Email_templatesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Email_templatesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    subject: string | null
    body: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Email_templatesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    subject: string | null
    body: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Email_templatesCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Email_templatesAvgAggregateInputType = {
    id?: true
  }

  export type Email_templatesSumAggregateInputType = {
    id?: true
  }

  export type Email_templatesMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    created_at?: true
    updated_at?: true
  }

  export type Email_templatesMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    created_at?: true
    updated_at?: true
  }

  export type Email_templatesCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Email_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_templates to aggregate.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_templates
    **/
    _count?: true | Email_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Email_templatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Email_templatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_templatesMaxAggregateInputType
  }

  export type GetEmail_templatesAggregateType<T extends Email_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_templates[P]>
      : GetScalarType<T[P], AggregateEmail_templates[P]>
  }




  export type email_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_templatesWhereInput
    orderBy?: email_templatesOrderByWithAggregationInput | email_templatesOrderByWithAggregationInput[]
    by: Email_templatesScalarFieldEnum[] | Email_templatesScalarFieldEnum
    having?: email_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_templatesCountAggregateInputType | true
    _avg?: Email_templatesAvgAggregateInputType
    _sum?: Email_templatesSumAggregateInputType
    _min?: Email_templatesMinAggregateInputType
    _max?: Email_templatesMaxAggregateInputType
  }

  export type Email_templatesGroupByOutputType = {
    id: bigint
    name: string
    subject: string
    body: string
    created_at: string
    updated_at: string
    _count: Email_templatesCountAggregateOutputType | null
    _avg: Email_templatesAvgAggregateOutputType | null
    _sum: Email_templatesSumAggregateOutputType | null
    _min: Email_templatesMinAggregateOutputType | null
    _max: Email_templatesMaxAggregateOutputType | null
  }

  type GetEmail_templatesGroupByPayload<T extends email_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Email_templatesGroupByOutputType[P]>
        }
      >
    >


  export type email_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["email_templates"]>

  export type email_templatesSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type email_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subject" | "body" | "created_at" | "updated_at", ExtArgs["result"]["email_templates"]>

  export type $email_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_templates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      subject: string
      body: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["email_templates"]>
    composites: {}
  }

  type email_templatesGetPayload<S extends boolean | null | undefined | email_templatesDefaultArgs> = $Result.GetResult<Prisma.$email_templatesPayload, S>

  type email_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<email_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Email_templatesCountAggregateInputType | true
    }

  export interface email_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_templates'], meta: { name: 'email_templates' } }
    /**
     * Find zero or one Email_templates that matches the filter.
     * @param {email_templatesFindUniqueArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_templatesFindUniqueArgs>(args: SelectSubset<T, email_templatesFindUniqueArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {email_templatesFindUniqueOrThrowArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, email_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindFirstArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_templatesFindFirstArgs>(args?: SelectSubset<T, email_templatesFindFirstArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindFirstOrThrowArgs} args - Arguments to find a Email_templates
     * @example
     * // Get one Email_templates
     * const email_templates = await prisma.email_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, email_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Email_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_templates
     * const email_templates = await prisma.email_templates.findMany()
     * 
     * // Get first 10 Email_templates
     * const email_templates = await prisma.email_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_templatesFindManyArgs>(args?: SelectSubset<T, email_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email_templates.
     * @param {email_templatesCreateArgs} args - Arguments to create a Email_templates.
     * @example
     * // Create one Email_templates
     * const Email_templates = await prisma.email_templates.create({
     *   data: {
     *     // ... data to create a Email_templates
     *   }
     * })
     * 
     */
    create<T extends email_templatesCreateArgs>(args: SelectSubset<T, email_templatesCreateArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Email_templates.
     * @param {email_templatesCreateManyArgs} args - Arguments to create many Email_templates.
     * @example
     * // Create many Email_templates
     * const email_templates = await prisma.email_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_templatesCreateManyArgs>(args?: SelectSubset<T, email_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_templates and returns the data saved in the database.
     * @param {email_templatesCreateManyAndReturnArgs} args - Arguments to create many Email_templates.
     * @example
     * // Create many Email_templates
     * const email_templates = await prisma.email_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_templates and only return the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, email_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email_templates.
     * @param {email_templatesDeleteArgs} args - Arguments to delete one Email_templates.
     * @example
     * // Delete one Email_templates
     * const Email_templates = await prisma.email_templates.delete({
     *   where: {
     *     // ... filter to delete one Email_templates
     *   }
     * })
     * 
     */
    delete<T extends email_templatesDeleteArgs>(args: SelectSubset<T, email_templatesDeleteArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email_templates.
     * @param {email_templatesUpdateArgs} args - Arguments to update one Email_templates.
     * @example
     * // Update one Email_templates
     * const email_templates = await prisma.email_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_templatesUpdateArgs>(args: SelectSubset<T, email_templatesUpdateArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Email_templates.
     * @param {email_templatesDeleteManyArgs} args - Arguments to filter Email_templates to delete.
     * @example
     * // Delete a few Email_templates
     * const { count } = await prisma.email_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_templatesDeleteManyArgs>(args?: SelectSubset<T, email_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_templates
     * const email_templates = await prisma.email_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_templatesUpdateManyArgs>(args: SelectSubset<T, email_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_templates and returns the data updated in the database.
     * @param {email_templatesUpdateManyAndReturnArgs} args - Arguments to update many Email_templates.
     * @example
     * // Update many Email_templates
     * const email_templates = await prisma.email_templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Email_templates and only return the `id`
     * const email_templatesWithIdOnly = await prisma.email_templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends email_templatesUpdateManyAndReturnArgs>(args: SelectSubset<T, email_templatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email_templates.
     * @param {email_templatesUpsertArgs} args - Arguments to update or create a Email_templates.
     * @example
     * // Update or create a Email_templates
     * const email_templates = await prisma.email_templates.upsert({
     *   create: {
     *     // ... data to create a Email_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_templates we want to update
     *   }
     * })
     */
    upsert<T extends email_templatesUpsertArgs>(args: SelectSubset<T, email_templatesUpsertArgs<ExtArgs>>): Prisma__email_templatesClient<$Result.GetResult<Prisma.$email_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesCountArgs} args - Arguments to filter Email_templates to count.
     * @example
     * // Count the number of Email_templates
     * const count = await prisma.email_templates.count({
     *   where: {
     *     // ... the filter for the Email_templates we want to count
     *   }
     * })
    **/
    count<T extends email_templatesCountArgs>(
      args?: Subset<T, email_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_templatesAggregateArgs>(args: Subset<T, Email_templatesAggregateArgs>): Prisma.PrismaPromise<GetEmail_templatesAggregateType<T>>

    /**
     * Group by Email_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_templatesGroupByArgs['orderBy'] }
        : { orderBy?: email_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_templates model
   */
  readonly fields: email_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_templates model
   */
  interface email_templatesFieldRefs {
    readonly id: FieldRef<"email_templates", 'BigInt'>
    readonly name: FieldRef<"email_templates", 'String'>
    readonly subject: FieldRef<"email_templates", 'String'>
    readonly body: FieldRef<"email_templates", 'String'>
    readonly created_at: FieldRef<"email_templates", 'String'>
    readonly updated_at: FieldRef<"email_templates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * email_templates findUnique
   */
  export type email_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates findUniqueOrThrow
   */
  export type email_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates findFirst
   */
  export type email_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_templates.
     */
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates findFirstOrThrow
   */
  export type email_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_templates.
     */
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates findMany
   */
  export type email_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter, which email_templates to fetch.
     */
    where?: email_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_templates to fetch.
     */
    orderBy?: email_templatesOrderByWithRelationInput | email_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_templates.
     */
    cursor?: email_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_templates.
     */
    skip?: number
    distinct?: Email_templatesScalarFieldEnum | Email_templatesScalarFieldEnum[]
  }

  /**
   * email_templates create
   */
  export type email_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data needed to create a email_templates.
     */
    data: XOR<email_templatesCreateInput, email_templatesUncheckedCreateInput>
  }

  /**
   * email_templates createMany
   */
  export type email_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_templates.
     */
    data: email_templatesCreateManyInput | email_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_templates createManyAndReturn
   */
  export type email_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data used to create many email_templates.
     */
    data: email_templatesCreateManyInput | email_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_templates update
   */
  export type email_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data needed to update a email_templates.
     */
    data: XOR<email_templatesUpdateInput, email_templatesUncheckedUpdateInput>
    /**
     * Choose, which email_templates to update.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates updateMany
   */
  export type email_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_templates.
     */
    data: XOR<email_templatesUpdateManyMutationInput, email_templatesUncheckedUpdateManyInput>
    /**
     * Filter which email_templates to update
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to update.
     */
    limit?: number
  }

  /**
   * email_templates updateManyAndReturn
   */
  export type email_templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The data used to update email_templates.
     */
    data: XOR<email_templatesUpdateManyMutationInput, email_templatesUncheckedUpdateManyInput>
    /**
     * Filter which email_templates to update
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to update.
     */
    limit?: number
  }

  /**
   * email_templates upsert
   */
  export type email_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * The filter to search for the email_templates to update in case it exists.
     */
    where: email_templatesWhereUniqueInput
    /**
     * In case the email_templates found by the `where` argument doesn't exist, create a new email_templates with this data.
     */
    create: XOR<email_templatesCreateInput, email_templatesUncheckedCreateInput>
    /**
     * In case the email_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_templatesUpdateInput, email_templatesUncheckedUpdateInput>
  }

  /**
   * email_templates delete
   */
  export type email_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
    /**
     * Filter which email_templates to delete.
     */
    where: email_templatesWhereUniqueInput
  }

  /**
   * email_templates deleteMany
   */
  export type email_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_templates to delete
     */
    where?: email_templatesWhereInput
    /**
     * Limit how many email_templates to delete.
     */
    limit?: number
  }

  /**
   * email_templates without action
   */
  export type email_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_templates
     */
    select?: email_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_templates
     */
    omit?: email_templatesOmit<ExtArgs> | null
  }


  /**
   * Model audit_logs
   */

  export type AggregateAudit_logs = {
    _count: Audit_logsCountAggregateOutputType | null
    _avg: Audit_logsAvgAggregateOutputType | null
    _sum: Audit_logsSumAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  export type Audit_logsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    entity_id: number | null
  }

  export type Audit_logsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    entity_id: bigint | null
  }

  export type Audit_logsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    action: string | null
    entity_type: $Enums.LogType | null
    entity_id: bigint | null
    changes: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Audit_logsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    action: string | null
    entity_type: $Enums.LogType | null
    entity_id: bigint | null
    changes: string | null
    created_at: string | null
    updated_at: string | null
  }

  export type Audit_logsCountAggregateOutputType = {
    id: number
    user_id: number
    action: number
    entity_type: number
    entity_id: number
    changes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Audit_logsAvgAggregateInputType = {
    id?: true
    user_id?: true
    entity_id?: true
  }

  export type Audit_logsSumAggregateInputType = {
    id?: true
    user_id?: true
    entity_id?: true
  }

  export type Audit_logsMinAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    entity_type?: true
    entity_id?: true
    changes?: true
    created_at?: true
    updated_at?: true
  }

  export type Audit_logsMaxAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    entity_type?: true
    entity_id?: true
    changes?: true
    created_at?: true
    updated_at?: true
  }

  export type Audit_logsCountAggregateInputType = {
    id?: true
    user_id?: true
    action?: true
    entity_type?: true
    entity_id?: true
    changes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to aggregate.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Audit_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Audit_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logsMaxAggregateInputType
  }

  export type GetAudit_logsAggregateType<T extends Audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_logs[P]>
      : GetScalarType<T[P], AggregateAudit_logs[P]>
  }




  export type audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithAggregationInput | audit_logsOrderByWithAggregationInput[]
    by: Audit_logsScalarFieldEnum[] | Audit_logsScalarFieldEnum
    having?: audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logsCountAggregateInputType | true
    _avg?: Audit_logsAvgAggregateInputType
    _sum?: Audit_logsSumAggregateInputType
    _min?: Audit_logsMinAggregateInputType
    _max?: Audit_logsMaxAggregateInputType
  }

  export type Audit_logsGroupByOutputType = {
    id: bigint
    user_id: bigint
    action: string
    entity_type: $Enums.LogType
    entity_id: bigint
    changes: string
    created_at: string
    updated_at: string
    _count: Audit_logsCountAggregateOutputType | null
    _avg: Audit_logsAvgAggregateOutputType | null
    _sum: Audit_logsSumAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  type GetAudit_logsGroupByPayload<T extends audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    action?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectScalar = {
    id?: boolean
    user_id?: boolean
    action?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "action" | "entity_type" | "entity_id" | "changes" | "created_at" | "updated_at", ExtArgs["result"]["audit_logs"]>
  export type audit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type audit_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type audit_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      action: string
      entity_type: $Enums.LogType
      entity_id: bigint
      changes: string
      created_at: string
      updated_at: string
    }, ExtArgs["result"]["audit_logs"]>
    composites: {}
  }

  type audit_logsGetPayload<S extends boolean | null | undefined | audit_logsDefaultArgs> = $Result.GetResult<Prisma.$audit_logsPayload, S>

  type audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_logsCountAggregateInputType | true
    }

  export interface audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_logs'], meta: { name: 'audit_logs' } }
    /**
     * Find zero or one Audit_logs that matches the filter.
     * @param {audit_logsFindUniqueArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_logsFindUniqueArgs>(args: SelectSubset<T, audit_logsFindUniqueArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_logsFindFirstArgs>(args?: SelectSubset<T, audit_logsFindFirstArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_logsFindManyArgs>(args?: SelectSubset<T, audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_logs.
     * @param {audit_logsCreateArgs} args - Arguments to create a Audit_logs.
     * @example
     * // Create one Audit_logs
     * const Audit_logs = await prisma.audit_logs.create({
     *   data: {
     *     // ... data to create a Audit_logs
     *   }
     * })
     * 
     */
    create<T extends audit_logsCreateArgs>(args: SelectSubset<T, audit_logsCreateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_logs.
     * @param {audit_logsCreateManyArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_logsCreateManyArgs>(args?: SelectSubset<T, audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audit_logs and returns the data saved in the database.
     * @param {audit_logsCreateManyAndReturnArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends audit_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, audit_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit_logs.
     * @param {audit_logsDeleteArgs} args - Arguments to delete one Audit_logs.
     * @example
     * // Delete one Audit_logs
     * const Audit_logs = await prisma.audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Audit_logs
     *   }
     * })
     * 
     */
    delete<T extends audit_logsDeleteArgs>(args: SelectSubset<T, audit_logsDeleteArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_logs.
     * @param {audit_logsUpdateArgs} args - Arguments to update one Audit_logs.
     * @example
     * // Update one Audit_logs
     * const audit_logs = await prisma.audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_logsUpdateArgs>(args: SelectSubset<T, audit_logsUpdateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logsDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_logsDeleteManyArgs>(args?: SelectSubset<T, audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_logsUpdateManyArgs>(args: SelectSubset<T, audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs and returns the data updated in the database.
     * @param {audit_logsUpdateManyAndReturnArgs} args - Arguments to update many Audit_logs.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends audit_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, audit_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit_logs.
     * @param {audit_logsUpsertArgs} args - Arguments to update or create a Audit_logs.
     * @example
     * // Update or create a Audit_logs
     * const audit_logs = await prisma.audit_logs.upsert({
     *   create: {
     *     // ... data to create a Audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_logs we want to update
     *   }
     * })
     */
    upsert<T extends audit_logsUpsertArgs>(args: SelectSubset<T, audit_logsUpsertArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_logs.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logsCountArgs>(
      args?: Subset<T, audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logsAggregateArgs>(args: Subset<T, Audit_logsAggregateArgs>): Prisma.PrismaPromise<GetAudit_logsAggregateType<T>>

    /**
     * Group by Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_logs model
   */
  readonly fields: audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_logs model
   */
  interface audit_logsFieldRefs {
    readonly id: FieldRef<"audit_logs", 'BigInt'>
    readonly user_id: FieldRef<"audit_logs", 'BigInt'>
    readonly action: FieldRef<"audit_logs", 'String'>
    readonly entity_type: FieldRef<"audit_logs", 'LogType'>
    readonly entity_id: FieldRef<"audit_logs", 'BigInt'>
    readonly changes: FieldRef<"audit_logs", 'String'>
    readonly created_at: FieldRef<"audit_logs", 'String'>
    readonly updated_at: FieldRef<"audit_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * audit_logs findUnique
   */
  export type audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findUniqueOrThrow
   */
  export type audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findFirst
   */
  export type audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findFirstOrThrow
   */
  export type audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findMany
   */
  export type audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs create
   */
  export type audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a audit_logs.
     */
    data: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
  }

  /**
   * audit_logs createMany
   */
  export type audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_logs createManyAndReturn
   */
  export type audit_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit_logs update
   */
  export type audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a audit_logs.
     */
    data: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
    /**
     * Choose, which audit_logs to update.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs updateMany
   */
  export type audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_logs updateManyAndReturn
   */
  export type audit_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit_logs upsert
   */
  export type audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the audit_logs to update in case it exists.
     */
    where: audit_logsWhereUniqueInput
    /**
     * In case the audit_logs found by the `where` argument doesn't exist, create a new audit_logs with this data.
     */
    create: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
    /**
     * In case the audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
  }

  /**
   * audit_logs delete
   */
  export type audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter which audit_logs to delete.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs deleteMany
   */
  export type audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to delete.
     */
    limit?: number
  }

  /**
   * audit_logs without action
   */
  export type audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
  }


  /**
   * Model tokens
   */

  export type AggregateTokens = {
    _count: TokensCountAggregateOutputType | null
    _avg: TokensAvgAggregateOutputType | null
    _sum: TokensSumAggregateOutputType | null
    _min: TokensMinAggregateOutputType | null
    _max: TokensMaxAggregateOutputType | null
  }

  export type TokensAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TokensSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TokensMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    token: string | null
    type: string | null
    expires: Date | null
    blacklisted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokensMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    token: string | null
    type: string | null
    expires: Date | null
    blacklisted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokensCountAggregateOutputType = {
    id: number
    user_id: number
    token: number
    type: number
    expires: number
    blacklisted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokensAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TokensSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TokensMinAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    type?: true
    expires?: true
    blacklisted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokensMaxAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    type?: true
    expires?: true
    blacklisted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokensCountAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    type?: true
    expires?: true
    blacklisted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens to aggregate.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokens
    **/
    _count?: true | TokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokensMaxAggregateInputType
  }

  export type GetTokensAggregateType<T extends TokensAggregateArgs> = {
        [P in keyof T & keyof AggregateTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens[P]>
      : GetScalarType<T[P], AggregateTokens[P]>
  }




  export type tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokensWhereInput
    orderBy?: tokensOrderByWithAggregationInput | tokensOrderByWithAggregationInput[]
    by: TokensScalarFieldEnum[] | TokensScalarFieldEnum
    having?: tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokensCountAggregateInputType | true
    _avg?: TokensAvgAggregateInputType
    _sum?: TokensSumAggregateInputType
    _min?: TokensMinAggregateInputType
    _max?: TokensMaxAggregateInputType
  }

  export type TokensGroupByOutputType = {
    id: number
    user_id: number
    token: string
    type: string
    expires: Date
    blacklisted: boolean
    createdAt: Date
    updatedAt: Date
    _count: TokensCountAggregateOutputType | null
    _avg: TokensAvgAggregateOutputType | null
    _sum: TokensSumAggregateOutputType | null
    _min: TokensMinAggregateOutputType | null
    _max: TokensMaxAggregateOutputType | null
  }

  type GetTokensGroupByPayload<T extends tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokensGroupByOutputType[P]>
            : GetScalarType<T[P], TokensGroupByOutputType[P]>
        }
      >
    >


  export type tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectScalar = {
    id?: boolean
    user_id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token" | "type" | "expires" | "blacklisted" | "createdAt" | "updatedAt", ExtArgs["result"]["tokens"]>

  export type $tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      token: string
      type: string
      expires: Date
      blacklisted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tokens"]>
    composites: {}
  }

  type tokensGetPayload<S extends boolean | null | undefined | tokensDefaultArgs> = $Result.GetResult<Prisma.$tokensPayload, S>

  type tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokensCountAggregateInputType | true
    }

  export interface tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tokens'], meta: { name: 'tokens' } }
    /**
     * Find zero or one Tokens that matches the filter.
     * @param {tokensFindUniqueArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tokensFindUniqueArgs>(args: SelectSubset<T, tokensFindUniqueArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tokensFindUniqueOrThrowArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindFirstArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tokensFindFirstArgs>(args?: SelectSubset<T, tokensFindFirstArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindFirstOrThrowArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.tokens.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokensWithIdOnly = await prisma.tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tokensFindManyArgs>(args?: SelectSubset<T, tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tokens.
     * @param {tokensCreateArgs} args - Arguments to create a Tokens.
     * @example
     * // Create one Tokens
     * const Tokens = await prisma.tokens.create({
     *   data: {
     *     // ... data to create a Tokens
     *   }
     * })
     * 
     */
    create<T extends tokensCreateArgs>(args: SelectSubset<T, tokensCreateArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {tokensCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const tokens = await prisma.tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tokensCreateManyArgs>(args?: SelectSubset<T, tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {tokensCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const tokens = await prisma.tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokensWithIdOnly = await prisma.tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tokens.
     * @param {tokensDeleteArgs} args - Arguments to delete one Tokens.
     * @example
     * // Delete one Tokens
     * const Tokens = await prisma.tokens.delete({
     *   where: {
     *     // ... filter to delete one Tokens
     *   }
     * })
     * 
     */
    delete<T extends tokensDeleteArgs>(args: SelectSubset<T, tokensDeleteArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tokens.
     * @param {tokensUpdateArgs} args - Arguments to update one Tokens.
     * @example
     * // Update one Tokens
     * const tokens = await prisma.tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tokensUpdateArgs>(args: SelectSubset<T, tokensUpdateArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {tokensDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tokensDeleteManyArgs>(args?: SelectSubset<T, tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const tokens = await prisma.tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tokensUpdateManyArgs>(args: SelectSubset<T, tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {tokensUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const tokens = await prisma.tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokensWithIdOnly = await prisma.tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tokens.
     * @param {tokensUpsertArgs} args - Arguments to update or create a Tokens.
     * @example
     * // Update or create a Tokens
     * const tokens = await prisma.tokens.upsert({
     *   create: {
     *     // ... data to create a Tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens we want to update
     *   }
     * })
     */
    upsert<T extends tokensUpsertArgs>(args: SelectSubset<T, tokensUpsertArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.tokens.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends tokensCountArgs>(
      args?: Subset<T, tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokensAggregateArgs>(args: Subset<T, TokensAggregateArgs>): Prisma.PrismaPromise<GetTokensAggregateType<T>>

    /**
     * Group by Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tokensGroupByArgs['orderBy'] }
        : { orderBy?: tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tokens model
   */
  readonly fields: tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tokens model
   */
  interface tokensFieldRefs {
    readonly id: FieldRef<"tokens", 'Int'>
    readonly user_id: FieldRef<"tokens", 'Int'>
    readonly token: FieldRef<"tokens", 'String'>
    readonly type: FieldRef<"tokens", 'String'>
    readonly expires: FieldRef<"tokens", 'DateTime'>
    readonly blacklisted: FieldRef<"tokens", 'Boolean'>
    readonly createdAt: FieldRef<"tokens", 'DateTime'>
    readonly updatedAt: FieldRef<"tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tokens findUnique
   */
  export type tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens findUniqueOrThrow
   */
  export type tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens findFirst
   */
  export type tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens.
     */
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens findFirstOrThrow
   */
  export type tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens.
     */
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens findMany
   */
  export type tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens create
   */
  export type tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data needed to create a tokens.
     */
    data: XOR<tokensCreateInput, tokensUncheckedCreateInput>
  }

  /**
   * tokens createMany
   */
  export type tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tokens.
     */
    data: tokensCreateManyInput | tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens createManyAndReturn
   */
  export type tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data used to create many tokens.
     */
    data: tokensCreateManyInput | tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens update
   */
  export type tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data needed to update a tokens.
     */
    data: XOR<tokensUpdateInput, tokensUncheckedUpdateInput>
    /**
     * Choose, which tokens to update.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens updateMany
   */
  export type tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tokens.
     */
    data: XOR<tokensUpdateManyMutationInput, tokensUncheckedUpdateManyInput>
    /**
     * Filter which tokens to update
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to update.
     */
    limit?: number
  }

  /**
   * tokens updateManyAndReturn
   */
  export type tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data used to update tokens.
     */
    data: XOR<tokensUpdateManyMutationInput, tokensUncheckedUpdateManyInput>
    /**
     * Filter which tokens to update
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to update.
     */
    limit?: number
  }

  /**
   * tokens upsert
   */
  export type tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The filter to search for the tokens to update in case it exists.
     */
    where: tokensWhereUniqueInput
    /**
     * In case the tokens found by the `where` argument doesn't exist, create a new tokens with this data.
     */
    create: XOR<tokensCreateInput, tokensUncheckedCreateInput>
    /**
     * In case the tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokensUpdateInput, tokensUncheckedUpdateInput>
  }

  /**
   * tokens delete
   */
  export type tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Filter which tokens to delete.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens deleteMany
   */
  export type tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens to delete
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to delete.
     */
    limit?: number
  }

  /**
   * tokens without action
   */
  export type tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    address: 'address',
    phone: 'phone',
    organization_name: 'organization_name',
    industry_name: 'industry_name',
    pincode: 'pincode',
    website: 'website',
    timezone: 'timezone',
    plan_type: 'plan_type',
    subscription_start_date: 'subscription_start_date',
    subscription_end_date: 'subscription_end_date',
    file_storage_limit: 'file_storage_limit',
    data_storage_limit: 'data_storage_limit',
    created_at: 'created_at',
    updated_at: 'updated_at',
    currencyid: 'currencyid'
  };

  export type OrganizationsScalarFieldEnum = (typeof OrganizationsScalarFieldEnum)[keyof typeof OrganizationsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    email: 'email',
    password_hash: 'password_hash',
    isVerified_Email: 'isVerified_Email',
    isVerified_PhoneNumber: 'isVerified_PhoneNumber',
    first_name: 'first_name',
    last_name: 'last_name',
    phone: 'phone',
    job_title: 'job_title',
    user_type: 'user_type',
    is_active: 'is_active',
    last_login_at: 'last_login_at',
    email_verified: 'email_verified',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const User_roleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    access_rights: 'access_rights',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_roleScalarFieldEnum = (typeof User_roleScalarFieldEnum)[keyof typeof User_roleScalarFieldEnum]


  export const CurrenciesScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    exchange_rate: 'exchange_rate',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CurrenciesScalarFieldEnum = (typeof CurrenciesScalarFieldEnum)[keyof typeof CurrenciesScalarFieldEnum]


  export const User_role_assignmentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    profile_id: 'profile_id',
    assigned_at: 'assigned_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_role_assignmentsScalarFieldEnum = (typeof User_role_assignmentsScalarFieldEnum)[keyof typeof User_role_assignmentsScalarFieldEnum]


  export const SkillsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SkillsScalarFieldEnum = (typeof SkillsScalarFieldEnum)[keyof typeof SkillsScalarFieldEnum]


  export const User_skillsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    skill_id: 'skill_id',
    organization_id: 'organization_id',
    proficiency_level: 'proficiency_level',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_skillsScalarFieldEnum = (typeof User_skillsScalarFieldEnum)[keyof typeof User_skillsScalarFieldEnum]


  export const Business_hoursScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    day_of_week: 'day_of_week',
    start_time: 'start_time',
    end_time: 'end_time',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Business_hoursScalarFieldEnum = (typeof Business_hoursScalarFieldEnum)[keyof typeof Business_hoursScalarFieldEnum]


  export const HolidaysScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    name: 'name',
    holiday_date: 'holiday_date',
    is_recurring: 'is_recurring',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type HolidaysScalarFieldEnum = (typeof HolidaysScalarFieldEnum)[keyof typeof HolidaysScalarFieldEnum]


  export const Time_off_requestsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    start_date: 'start_date',
    end_date: 'end_date',
    reason: 'reason',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Time_off_requestsScalarFieldEnum = (typeof Time_off_requestsScalarFieldEnum)[keyof typeof Time_off_requestsScalarFieldEnum]


  export const CrewsScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    name: 'name',
    leader_id: 'leader_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CrewsScalarFieldEnum = (typeof CrewsScalarFieldEnum)[keyof typeof CrewsScalarFieldEnum]


  export const Crew_membersScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    crew_id: 'crew_id',
    user_id: 'user_id',
    role: 'role',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Crew_membersScalarFieldEnum = (typeof Crew_membersScalarFieldEnum)[keyof typeof Crew_membersScalarFieldEnum]


  export const EquipmentsScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    name: 'name',
    equipment_type: 'equipment_type',
    status: 'status',
    location: 'location',
    availability_date: 'availability_date',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EquipmentsScalarFieldEnum = (typeof EquipmentsScalarFieldEnum)[keyof typeof EquipmentsScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    name: 'name',
    industry: 'industry',
    tax_id: 'tax_id',
    address: 'address',
    phone: 'phone',
    email: 'email',
    website: 'website',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    company_id: 'company_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    description: 'description',
    duration: 'duration',
    price: 'price',
    required_skills: 'required_skills',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const AssetsScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    customer_id: 'customer_id',
    asset_name: 'asset_name',
    serial_number: 'serial_number',
    model: 'model',
    manufacturer: 'manufacturer',
    status: 'status',
    location: 'location',
    notes: 'notes',
    purchase_date: 'purchase_date',
    warranty_expiry: 'warranty_expiry',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AssetsScalarFieldEnum = (typeof AssetsScalarFieldEnum)[keyof typeof AssetsScalarFieldEnum]


  export const PartsScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    name: 'name',
    description: 'description',
    price: 'price',
    inventory_count: 'inventory_count',
    reorder_level: 'reorder_level',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PartsScalarFieldEnum = (typeof PartsScalarFieldEnum)[keyof typeof PartsScalarFieldEnum]


  export const Maintenance_plansScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    name: 'name',
    description: 'description',
    start_date: 'start_date',
    end_date: 'end_date',
    frequency: 'frequency',
    frequency_unit: 'frequency_unit',
    frequency_unit_type: 'frequency_unit_type',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Maintenance_plansScalarFieldEnum = (typeof Maintenance_plansScalarFieldEnum)[keyof typeof Maintenance_plansScalarFieldEnum]


  export const Maintenance_plan_assetsScalarFieldEnum: {
    id: 'id',
    maintenance_plan_id: 'maintenance_plan_id',
    asset_id: 'asset_id',
    assigned_at: 'assigned_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Maintenance_plan_assetsScalarFieldEnum = (typeof Maintenance_plan_assetsScalarFieldEnum)[keyof typeof Maintenance_plan_assetsScalarFieldEnum]


  export const Work_ordersScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    customer_id: 'customer_id',
    company_id: 'company_id',
    asset_id: 'asset_id',
    maintenance_plan_id: 'maintenance_plan_id',
    title: 'title',
    description: 'description',
    priority: 'priority',
    status: 'status',
    assigned_to: 'assigned_to',
    assigned_crew_id: 'assigned_crew_id',
    scheduled_start_date: 'scheduled_start_date',
    scheduled_end_date: 'scheduled_end_date',
    actual_start_date: 'actual_start_date',
    actual_end_date: 'actual_end_date',
    currency_id: 'currency_id',
    estimated_cost: 'estimated_cost',
    actual_cost: 'actual_cost',
    address: 'address',
    city: 'city',
    state: 'state',
    postal_code: 'postal_code',
    country: 'country',
    is_multi_day: 'is_multi_day',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Work_ordersScalarFieldEnum = (typeof Work_ordersScalarFieldEnum)[keyof typeof Work_ordersScalarFieldEnum]


  export const Work_order_servicesScalarFieldEnum: {
    id: 'id',
    work_order_id: 'work_order_id',
    service_id: 'service_id',
    quantity: 'quantity',
    service_cost: 'service_cost',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Work_order_servicesScalarFieldEnum = (typeof Work_order_servicesScalarFieldEnum)[keyof typeof Work_order_servicesScalarFieldEnum]


  export const Work_order_tasksScalarFieldEnum: {
    id: 'id',
    work_order_id: 'work_order_id',
    task_name: 'task_name',
    task_description: 'task_description',
    assigned_to: 'assigned_to',
    status: 'status',
    due_date: 'due_date',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Work_order_tasksScalarFieldEnum = (typeof Work_order_tasksScalarFieldEnum)[keyof typeof Work_order_tasksScalarFieldEnum]


  export const Work_order_assetsScalarFieldEnum: {
    id: 'id',
    work_order_id: 'work_order_id',
    asset_id: 'asset_id',
    quantity: 'quantity',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Work_order_assetsScalarFieldEnum = (typeof Work_order_assetsScalarFieldEnum)[keyof typeof Work_order_assetsScalarFieldEnum]


  export const Work_order_crewScalarFieldEnum: {
    id: 'id',
    work_order_id: 'work_order_id',
    crew_id: 'crew_id',
    assigned_at: 'assigned_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Work_order_crewScalarFieldEnum = (typeof Work_order_crewScalarFieldEnum)[keyof typeof Work_order_crewScalarFieldEnum]


  export const Work_order_approvalsScalarFieldEnum: {
    id: 'id',
    work_order_id: 'work_order_id',
    approved_by: 'approved_by',
    approval_status: 'approval_status',
    approved_at: 'approved_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Work_order_approvalsScalarFieldEnum = (typeof Work_order_approvalsScalarFieldEnum)[keyof typeof Work_order_approvalsScalarFieldEnum]


  export const InvoicesScalarFieldEnum: {
    id: 'id',
    work_order_id: 'work_order_id',
    invoice_number: 'invoice_number',
    invoice_date: 'invoice_date',
    due_date: 'due_date',
    total_amount: 'total_amount',
    status: 'status',
    currency_id: 'currency_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvoicesScalarFieldEnum = (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum]


  export const Invoice_itemsScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id',
    service_id: 'service_id',
    part_id: 'part_id',
    quantity: 'quantity',
    unit_price: 'unit_price',
    total_price: 'total_price',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Invoice_itemsScalarFieldEnum = (typeof Invoice_itemsScalarFieldEnum)[keyof typeof Invoice_itemsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id',
    payment_date: 'payment_date',
    payment_amount: 'payment_amount',
    payment_method: 'payment_method',
    payment_status: 'payment_status',
    transaction_id: 'transaction_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    notification_type: 'notification_type',
    message: 'message',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const Email_templatesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Email_templatesScalarFieldEnum = (typeof Email_templatesScalarFieldEnum)[keyof typeof Email_templatesScalarFieldEnum]


  export const Audit_logsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    action: 'action',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    changes: 'changes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


  export const TokensScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token: 'token',
    type: 'type',
    expires: 'expires',
    blacklisted: 'blacklisted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokensScalarFieldEnum = (typeof TokensScalarFieldEnum)[keyof typeof TokensScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ProficiencyLevel'
   */
  export type EnumProficiencyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProficiencyLevel'>
    


  /**
   * Reference to a field of type 'ProficiencyLevel[]'
   */
  export type ListEnumProficiencyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProficiencyLevel[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DayOfWeek'
   */
  export type EnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek'>
    


  /**
   * Reference to a field of type 'DayOfWeek[]'
   */
  export type ListEnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'EqupmentStatus'
   */
  export type EnumEqupmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EqupmentStatus'>
    


  /**
   * Reference to a field of type 'EqupmentStatus[]'
   */
  export type ListEnumEqupmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EqupmentStatus[]'>
    


  /**
   * Reference to a field of type 'AssetStatus'
   */
  export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus'>
    


  /**
   * Reference to a field of type 'AssetStatus[]'
   */
  export type ListEnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus[]'>
    


  /**
   * Reference to a field of type 'Frequency'
   */
  export type EnumFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Frequency'>
    


  /**
   * Reference to a field of type 'Frequency[]'
   */
  export type ListEnumFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Frequency[]'>
    


  /**
   * Reference to a field of type 'FrequencyUnitType'
   */
  export type EnumFrequencyUnitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FrequencyUnitType'>
    


  /**
   * Reference to a field of type 'FrequencyUnitType[]'
   */
  export type ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FrequencyUnitType[]'>
    


  /**
   * Reference to a field of type 'Prioirty'
   */
  export type EnumPrioirtyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Prioirty'>
    


  /**
   * Reference to a field of type 'Prioirty[]'
   */
  export type ListEnumPrioirtyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Prioirty[]'>
    


  /**
   * Reference to a field of type 'WorkOrderStatus'
   */
  export type EnumWorkOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkOrderStatus'>
    


  /**
   * Reference to a field of type 'WorkOrderStatus[]'
   */
  export type ListEnumWorkOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkOrderStatus[]'>
    


  /**
   * Reference to a field of type 'WorkOrderTaskStatus'
   */
  export type EnumWorkOrderTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkOrderTaskStatus'>
    


  /**
   * Reference to a field of type 'WorkOrderTaskStatus[]'
   */
  export type ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkOrderTaskStatus[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'LogType'
   */
  export type EnumLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogType'>
    


  /**
   * Reference to a field of type 'LogType[]'
   */
  export type ListEnumLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type organizationsWhereInput = {
    AND?: organizationsWhereInput | organizationsWhereInput[]
    OR?: organizationsWhereInput[]
    NOT?: organizationsWhereInput | organizationsWhereInput[]
    id?: BigIntFilter<"organizations"> | bigint | number
    name?: StringFilter<"organizations"> | string
    email?: StringFilter<"organizations"> | string
    address?: StringFilter<"organizations"> | string
    phone?: StringFilter<"organizations"> | string
    organization_name?: StringFilter<"organizations"> | string
    industry_name?: StringFilter<"organizations"> | string
    pincode?: StringFilter<"organizations"> | string
    website?: StringFilter<"organizations"> | string
    timezone?: StringFilter<"organizations"> | string
    plan_type?: EnumPlanTypeFilter<"organizations"> | $Enums.PlanType
    subscription_start_date?: StringFilter<"organizations"> | string
    subscription_end_date?: StringFilter<"organizations"> | string
    file_storage_limit?: BigIntFilter<"organizations"> | bigint | number
    data_storage_limit?: BigIntFilter<"organizations"> | bigint | number
    created_at?: StringFilter<"organizations"> | string
    updated_at?: StringFilter<"organizations"> | string
    currencyid?: BigIntFilter<"organizations"> | bigint | number
    users?: UsersListRelationFilter
    user_skills?: User_skillsListRelationFilter
    business_hours?: Business_hoursListRelationFilter
    holidays?: HolidaysListRelationFilter
    crew_members?: Crew_membersListRelationFilter
    equipments?: EquipmentsListRelationFilter
    companies?: CompaniesListRelationFilter
    customers?: CustomersListRelationFilter
    services?: ServicesListRelationFilter
    assets?: AssetsListRelationFilter
    parts?: PartsListRelationFilter
    maintenance_plans?: Maintenance_plansListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }

  export type organizationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    organization_name?: SortOrder
    industry_name?: SortOrder
    pincode?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    plan_type?: SortOrder
    subscription_start_date?: SortOrder
    subscription_end_date?: SortOrder
    file_storage_limit?: SortOrder
    data_storage_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currencyid?: SortOrder
    users?: usersOrderByRelationAggregateInput
    user_skills?: user_skillsOrderByRelationAggregateInput
    business_hours?: business_hoursOrderByRelationAggregateInput
    holidays?: holidaysOrderByRelationAggregateInput
    crew_members?: crew_membersOrderByRelationAggregateInput
    equipments?: equipmentsOrderByRelationAggregateInput
    companies?: companiesOrderByRelationAggregateInput
    customers?: customersOrderByRelationAggregateInput
    services?: servicesOrderByRelationAggregateInput
    assets?: assetsOrderByRelationAggregateInput
    parts?: partsOrderByRelationAggregateInput
    maintenance_plans?: maintenance_plansOrderByRelationAggregateInput
    work_orders?: work_ordersOrderByRelationAggregateInput
  }

  export type organizationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: organizationsWhereInput | organizationsWhereInput[]
    OR?: organizationsWhereInput[]
    NOT?: organizationsWhereInput | organizationsWhereInput[]
    name?: StringFilter<"organizations"> | string
    address?: StringFilter<"organizations"> | string
    phone?: StringFilter<"organizations"> | string
    organization_name?: StringFilter<"organizations"> | string
    industry_name?: StringFilter<"organizations"> | string
    pincode?: StringFilter<"organizations"> | string
    website?: StringFilter<"organizations"> | string
    timezone?: StringFilter<"organizations"> | string
    plan_type?: EnumPlanTypeFilter<"organizations"> | $Enums.PlanType
    subscription_start_date?: StringFilter<"organizations"> | string
    subscription_end_date?: StringFilter<"organizations"> | string
    file_storage_limit?: BigIntFilter<"organizations"> | bigint | number
    data_storage_limit?: BigIntFilter<"organizations"> | bigint | number
    created_at?: StringFilter<"organizations"> | string
    updated_at?: StringFilter<"organizations"> | string
    currencyid?: BigIntFilter<"organizations"> | bigint | number
    users?: UsersListRelationFilter
    user_skills?: User_skillsListRelationFilter
    business_hours?: Business_hoursListRelationFilter
    holidays?: HolidaysListRelationFilter
    crew_members?: Crew_membersListRelationFilter
    equipments?: EquipmentsListRelationFilter
    companies?: CompaniesListRelationFilter
    customers?: CustomersListRelationFilter
    services?: ServicesListRelationFilter
    assets?: AssetsListRelationFilter
    parts?: PartsListRelationFilter
    maintenance_plans?: Maintenance_plansListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }, "id" | "email">

  export type organizationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    organization_name?: SortOrder
    industry_name?: SortOrder
    pincode?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    plan_type?: SortOrder
    subscription_start_date?: SortOrder
    subscription_end_date?: SortOrder
    file_storage_limit?: SortOrder
    data_storage_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currencyid?: SortOrder
    _count?: organizationsCountOrderByAggregateInput
    _avg?: organizationsAvgOrderByAggregateInput
    _max?: organizationsMaxOrderByAggregateInput
    _min?: organizationsMinOrderByAggregateInput
    _sum?: organizationsSumOrderByAggregateInput
  }

  export type organizationsScalarWhereWithAggregatesInput = {
    AND?: organizationsScalarWhereWithAggregatesInput | organizationsScalarWhereWithAggregatesInput[]
    OR?: organizationsScalarWhereWithAggregatesInput[]
    NOT?: organizationsScalarWhereWithAggregatesInput | organizationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"organizations"> | bigint | number
    name?: StringWithAggregatesFilter<"organizations"> | string
    email?: StringWithAggregatesFilter<"organizations"> | string
    address?: StringWithAggregatesFilter<"organizations"> | string
    phone?: StringWithAggregatesFilter<"organizations"> | string
    organization_name?: StringWithAggregatesFilter<"organizations"> | string
    industry_name?: StringWithAggregatesFilter<"organizations"> | string
    pincode?: StringWithAggregatesFilter<"organizations"> | string
    website?: StringWithAggregatesFilter<"organizations"> | string
    timezone?: StringWithAggregatesFilter<"organizations"> | string
    plan_type?: EnumPlanTypeWithAggregatesFilter<"organizations"> | $Enums.PlanType
    subscription_start_date?: StringWithAggregatesFilter<"organizations"> | string
    subscription_end_date?: StringWithAggregatesFilter<"organizations"> | string
    file_storage_limit?: BigIntWithAggregatesFilter<"organizations"> | bigint | number
    data_storage_limit?: BigIntWithAggregatesFilter<"organizations"> | bigint | number
    created_at?: StringWithAggregatesFilter<"organizations"> | string
    updated_at?: StringWithAggregatesFilter<"organizations"> | string
    currencyid?: BigIntWithAggregatesFilter<"organizations"> | bigint | number
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: BigIntFilter<"users"> | bigint | number
    organization_id?: BigIntFilter<"users"> | bigint | number
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    isVerified_Email?: BoolFilter<"users"> | boolean
    isVerified_PhoneNumber?: BoolFilter<"users"> | boolean
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    phone?: StringFilter<"users"> | string
    job_title?: StringFilter<"users"> | string
    user_type?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    is_active?: IntFilter<"users"> | number
    last_login_at?: StringFilter<"users"> | string
    email_verified?: BoolFilter<"users"> | boolean
    created_at?: StringFilter<"users"> | string
    updated_at?: StringFilter<"users"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    user_skills?: User_skillsListRelationFilter
    time_off_requests?: Time_off_requestsListRelationFilter
    crews?: CrewsListRelationFilter
    crew_members?: Crew_membersListRelationFilter
    notifications?: NotificationsListRelationFilter
    audit_logs?: Audit_logsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    isVerified_Email?: SortOrder
    isVerified_PhoneNumber?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    job_title?: SortOrder
    user_type?: SortOrder
    is_active?: SortOrder
    last_login_at?: SortOrder
    email_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    user_skills?: user_skillsOrderByRelationAggregateInput
    time_off_requests?: time_off_requestsOrderByRelationAggregateInput
    crews?: crewsOrderByRelationAggregateInput
    crew_members?: crew_membersOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    audit_logs?: audit_logsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    organization_id?: BigIntFilter<"users"> | bigint | number
    password_hash?: StringFilter<"users"> | string
    isVerified_Email?: BoolFilter<"users"> | boolean
    isVerified_PhoneNumber?: BoolFilter<"users"> | boolean
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    phone?: StringFilter<"users"> | string
    job_title?: StringFilter<"users"> | string
    user_type?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    is_active?: IntFilter<"users"> | number
    last_login_at?: StringFilter<"users"> | string
    email_verified?: BoolFilter<"users"> | boolean
    created_at?: StringFilter<"users"> | string
    updated_at?: StringFilter<"users"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    user_skills?: User_skillsListRelationFilter
    time_off_requests?: Time_off_requestsListRelationFilter
    crews?: CrewsListRelationFilter
    crew_members?: Crew_membersListRelationFilter
    notifications?: NotificationsListRelationFilter
    audit_logs?: Audit_logsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    isVerified_Email?: SortOrder
    isVerified_PhoneNumber?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    job_title?: SortOrder
    user_type?: SortOrder
    is_active?: SortOrder
    last_login_at?: SortOrder
    email_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringWithAggregatesFilter<"users"> | string
    isVerified_Email?: BoolWithAggregatesFilter<"users"> | boolean
    isVerified_PhoneNumber?: BoolWithAggregatesFilter<"users"> | boolean
    first_name?: StringWithAggregatesFilter<"users"> | string
    last_name?: StringWithAggregatesFilter<"users"> | string
    phone?: StringWithAggregatesFilter<"users"> | string
    job_title?: StringWithAggregatesFilter<"users"> | string
    user_type?: EnumUserRoleWithAggregatesFilter<"users"> | $Enums.UserRole
    is_active?: IntWithAggregatesFilter<"users"> | number
    last_login_at?: StringWithAggregatesFilter<"users"> | string
    email_verified?: BoolWithAggregatesFilter<"users"> | boolean
    created_at?: StringWithAggregatesFilter<"users"> | string
    updated_at?: StringWithAggregatesFilter<"users"> | string
  }

  export type user_roleWhereInput = {
    AND?: user_roleWhereInput | user_roleWhereInput[]
    OR?: user_roleWhereInput[]
    NOT?: user_roleWhereInput | user_roleWhereInput[]
    id?: BigIntFilter<"user_role"> | bigint | number
    name?: StringFilter<"user_role"> | string
    access_rights?: JsonFilter<"user_role">
    created_at?: StringFilter<"user_role"> | string
    updated_at?: StringFilter<"user_role"> | string
  }

  export type user_roleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    access_rights?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_roleWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: user_roleWhereInput | user_roleWhereInput[]
    OR?: user_roleWhereInput[]
    NOT?: user_roleWhereInput | user_roleWhereInput[]
    name?: StringFilter<"user_role"> | string
    access_rights?: JsonFilter<"user_role">
    created_at?: StringFilter<"user_role"> | string
    updated_at?: StringFilter<"user_role"> | string
  }, "id">

  export type user_roleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    access_rights?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_roleCountOrderByAggregateInput
    _avg?: user_roleAvgOrderByAggregateInput
    _max?: user_roleMaxOrderByAggregateInput
    _min?: user_roleMinOrderByAggregateInput
    _sum?: user_roleSumOrderByAggregateInput
  }

  export type user_roleScalarWhereWithAggregatesInput = {
    AND?: user_roleScalarWhereWithAggregatesInput | user_roleScalarWhereWithAggregatesInput[]
    OR?: user_roleScalarWhereWithAggregatesInput[]
    NOT?: user_roleScalarWhereWithAggregatesInput | user_roleScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"user_role"> | bigint | number
    name?: StringWithAggregatesFilter<"user_role"> | string
    access_rights?: JsonWithAggregatesFilter<"user_role">
    created_at?: StringWithAggregatesFilter<"user_role"> | string
    updated_at?: StringWithAggregatesFilter<"user_role"> | string
  }

  export type currenciesWhereInput = {
    AND?: currenciesWhereInput | currenciesWhereInput[]
    OR?: currenciesWhereInput[]
    NOT?: currenciesWhereInput | currenciesWhereInput[]
    id?: BigIntFilter<"currencies"> | bigint | number
    code?: StringFilter<"currencies"> | string
    name?: StringFilter<"currencies"> | string
    exchange_rate?: DecimalFilter<"currencies"> | Decimal | DecimalJsLike | number | string
    is_default?: BoolFilter<"currencies"> | boolean
    created_at?: StringFilter<"currencies"> | string
    updated_at?: StringFilter<"currencies"> | string
  }

  export type currenciesOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    exchange_rate?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currenciesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: currenciesWhereInput | currenciesWhereInput[]
    OR?: currenciesWhereInput[]
    NOT?: currenciesWhereInput | currenciesWhereInput[]
    code?: StringFilter<"currencies"> | string
    name?: StringFilter<"currencies"> | string
    exchange_rate?: DecimalFilter<"currencies"> | Decimal | DecimalJsLike | number | string
    is_default?: BoolFilter<"currencies"> | boolean
    created_at?: StringFilter<"currencies"> | string
    updated_at?: StringFilter<"currencies"> | string
  }, "id">

  export type currenciesOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    exchange_rate?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: currenciesCountOrderByAggregateInput
    _avg?: currenciesAvgOrderByAggregateInput
    _max?: currenciesMaxOrderByAggregateInput
    _min?: currenciesMinOrderByAggregateInput
    _sum?: currenciesSumOrderByAggregateInput
  }

  export type currenciesScalarWhereWithAggregatesInput = {
    AND?: currenciesScalarWhereWithAggregatesInput | currenciesScalarWhereWithAggregatesInput[]
    OR?: currenciesScalarWhereWithAggregatesInput[]
    NOT?: currenciesScalarWhereWithAggregatesInput | currenciesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"currencies"> | bigint | number
    code?: StringWithAggregatesFilter<"currencies"> | string
    name?: StringWithAggregatesFilter<"currencies"> | string
    exchange_rate?: DecimalWithAggregatesFilter<"currencies"> | Decimal | DecimalJsLike | number | string
    is_default?: BoolWithAggregatesFilter<"currencies"> | boolean
    created_at?: StringWithAggregatesFilter<"currencies"> | string
    updated_at?: StringWithAggregatesFilter<"currencies"> | string
  }

  export type user_role_assignmentsWhereInput = {
    AND?: user_role_assignmentsWhereInput | user_role_assignmentsWhereInput[]
    OR?: user_role_assignmentsWhereInput[]
    NOT?: user_role_assignmentsWhereInput | user_role_assignmentsWhereInput[]
    id?: BigIntFilter<"user_role_assignments"> | bigint | number
    user_id?: BigIntFilter<"user_role_assignments"> | bigint | number
    profile_id?: BigIntFilter<"user_role_assignments"> | bigint | number
    assigned_at?: StringFilter<"user_role_assignments"> | string
    created_at?: StringFilter<"user_role_assignments"> | string
    updated_at?: StringFilter<"user_role_assignments"> | string
  }

  export type user_role_assignmentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_role_assignmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: user_role_assignmentsWhereInput | user_role_assignmentsWhereInput[]
    OR?: user_role_assignmentsWhereInput[]
    NOT?: user_role_assignmentsWhereInput | user_role_assignmentsWhereInput[]
    user_id?: BigIntFilter<"user_role_assignments"> | bigint | number
    profile_id?: BigIntFilter<"user_role_assignments"> | bigint | number
    assigned_at?: StringFilter<"user_role_assignments"> | string
    created_at?: StringFilter<"user_role_assignments"> | string
    updated_at?: StringFilter<"user_role_assignments"> | string
  }, "id">

  export type user_role_assignmentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_role_assignmentsCountOrderByAggregateInput
    _avg?: user_role_assignmentsAvgOrderByAggregateInput
    _max?: user_role_assignmentsMaxOrderByAggregateInput
    _min?: user_role_assignmentsMinOrderByAggregateInput
    _sum?: user_role_assignmentsSumOrderByAggregateInput
  }

  export type user_role_assignmentsScalarWhereWithAggregatesInput = {
    AND?: user_role_assignmentsScalarWhereWithAggregatesInput | user_role_assignmentsScalarWhereWithAggregatesInput[]
    OR?: user_role_assignmentsScalarWhereWithAggregatesInput[]
    NOT?: user_role_assignmentsScalarWhereWithAggregatesInput | user_role_assignmentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"user_role_assignments"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"user_role_assignments"> | bigint | number
    profile_id?: BigIntWithAggregatesFilter<"user_role_assignments"> | bigint | number
    assigned_at?: StringWithAggregatesFilter<"user_role_assignments"> | string
    created_at?: StringWithAggregatesFilter<"user_role_assignments"> | string
    updated_at?: StringWithAggregatesFilter<"user_role_assignments"> | string
  }

  export type skillsWhereInput = {
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    id?: BigIntFilter<"skills"> | bigint | number
    name?: StringFilter<"skills"> | string
    description?: StringFilter<"skills"> | string
    created_at?: StringFilter<"skills"> | string
    updated_at?: StringFilter<"skills"> | string
    user_skills?: User_skillsListRelationFilter
  }

  export type skillsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_skills?: user_skillsOrderByRelationAggregateInput
  }

  export type skillsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    name?: StringFilter<"skills"> | string
    description?: StringFilter<"skills"> | string
    created_at?: StringFilter<"skills"> | string
    updated_at?: StringFilter<"skills"> | string
    user_skills?: User_skillsListRelationFilter
  }, "id">

  export type skillsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: skillsCountOrderByAggregateInput
    _avg?: skillsAvgOrderByAggregateInput
    _max?: skillsMaxOrderByAggregateInput
    _min?: skillsMinOrderByAggregateInput
    _sum?: skillsSumOrderByAggregateInput
  }

  export type skillsScalarWhereWithAggregatesInput = {
    AND?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    OR?: skillsScalarWhereWithAggregatesInput[]
    NOT?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"skills"> | bigint | number
    name?: StringWithAggregatesFilter<"skills"> | string
    description?: StringWithAggregatesFilter<"skills"> | string
    created_at?: StringWithAggregatesFilter<"skills"> | string
    updated_at?: StringWithAggregatesFilter<"skills"> | string
  }

  export type user_skillsWhereInput = {
    AND?: user_skillsWhereInput | user_skillsWhereInput[]
    OR?: user_skillsWhereInput[]
    NOT?: user_skillsWhereInput | user_skillsWhereInput[]
    id?: BigIntFilter<"user_skills"> | bigint | number
    user_id?: BigIntFilter<"user_skills"> | bigint | number
    skill_id?: BigIntFilter<"user_skills"> | bigint | number
    organization_id?: BigIntFilter<"user_skills"> | bigint | number
    proficiency_level?: EnumProficiencyLevelFilter<"user_skills"> | $Enums.ProficiencyLevel
    created_at?: DateTimeFilter<"user_skills"> | Date | string
    updated_at?: DateTimeFilter<"user_skills"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    skills?: XOR<SkillsScalarRelationFilter, skillsWhereInput>
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }

  export type user_skillsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_id?: SortOrder
    organization_id?: SortOrder
    proficiency_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
    skills?: skillsOrderByWithRelationInput
    organizations?: organizationsOrderByWithRelationInput
  }

  export type user_skillsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: user_skillsWhereInput | user_skillsWhereInput[]
    OR?: user_skillsWhereInput[]
    NOT?: user_skillsWhereInput | user_skillsWhereInput[]
    user_id?: BigIntFilter<"user_skills"> | bigint | number
    skill_id?: BigIntFilter<"user_skills"> | bigint | number
    organization_id?: BigIntFilter<"user_skills"> | bigint | number
    proficiency_level?: EnumProficiencyLevelFilter<"user_skills"> | $Enums.ProficiencyLevel
    created_at?: DateTimeFilter<"user_skills"> | Date | string
    updated_at?: DateTimeFilter<"user_skills"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    skills?: XOR<SkillsScalarRelationFilter, skillsWhereInput>
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }, "id">

  export type user_skillsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_id?: SortOrder
    organization_id?: SortOrder
    proficiency_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_skillsCountOrderByAggregateInput
    _avg?: user_skillsAvgOrderByAggregateInput
    _max?: user_skillsMaxOrderByAggregateInput
    _min?: user_skillsMinOrderByAggregateInput
    _sum?: user_skillsSumOrderByAggregateInput
  }

  export type user_skillsScalarWhereWithAggregatesInput = {
    AND?: user_skillsScalarWhereWithAggregatesInput | user_skillsScalarWhereWithAggregatesInput[]
    OR?: user_skillsScalarWhereWithAggregatesInput[]
    NOT?: user_skillsScalarWhereWithAggregatesInput | user_skillsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"user_skills"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"user_skills"> | bigint | number
    skill_id?: BigIntWithAggregatesFilter<"user_skills"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"user_skills"> | bigint | number
    proficiency_level?: EnumProficiencyLevelWithAggregatesFilter<"user_skills"> | $Enums.ProficiencyLevel
    created_at?: DateTimeWithAggregatesFilter<"user_skills"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user_skills"> | Date | string
  }

  export type business_hoursWhereInput = {
    AND?: business_hoursWhereInput | business_hoursWhereInput[]
    OR?: business_hoursWhereInput[]
    NOT?: business_hoursWhereInput | business_hoursWhereInput[]
    id?: BigIntFilter<"business_hours"> | bigint | number
    organization_id?: BigIntFilter<"business_hours"> | bigint | number
    day_of_week?: EnumDayOfWeekFilter<"business_hours"> | $Enums.DayOfWeek
    start_time?: StringFilter<"business_hours"> | string
    end_time?: StringFilter<"business_hours"> | string
    created_at?: StringFilter<"business_hours"> | string
    updated_at?: StringFilter<"business_hours"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }

  export type business_hoursOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
  }

  export type business_hoursWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: business_hoursWhereInput | business_hoursWhereInput[]
    OR?: business_hoursWhereInput[]
    NOT?: business_hoursWhereInput | business_hoursWhereInput[]
    organization_id?: BigIntFilter<"business_hours"> | bigint | number
    day_of_week?: EnumDayOfWeekFilter<"business_hours"> | $Enums.DayOfWeek
    start_time?: StringFilter<"business_hours"> | string
    end_time?: StringFilter<"business_hours"> | string
    created_at?: StringFilter<"business_hours"> | string
    updated_at?: StringFilter<"business_hours"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }, "id">

  export type business_hoursOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: business_hoursCountOrderByAggregateInput
    _avg?: business_hoursAvgOrderByAggregateInput
    _max?: business_hoursMaxOrderByAggregateInput
    _min?: business_hoursMinOrderByAggregateInput
    _sum?: business_hoursSumOrderByAggregateInput
  }

  export type business_hoursScalarWhereWithAggregatesInput = {
    AND?: business_hoursScalarWhereWithAggregatesInput | business_hoursScalarWhereWithAggregatesInput[]
    OR?: business_hoursScalarWhereWithAggregatesInput[]
    NOT?: business_hoursScalarWhereWithAggregatesInput | business_hoursScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"business_hours"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"business_hours"> | bigint | number
    day_of_week?: EnumDayOfWeekWithAggregatesFilter<"business_hours"> | $Enums.DayOfWeek
    start_time?: StringWithAggregatesFilter<"business_hours"> | string
    end_time?: StringWithAggregatesFilter<"business_hours"> | string
    created_at?: StringWithAggregatesFilter<"business_hours"> | string
    updated_at?: StringWithAggregatesFilter<"business_hours"> | string
  }

  export type holidaysWhereInput = {
    AND?: holidaysWhereInput | holidaysWhereInput[]
    OR?: holidaysWhereInput[]
    NOT?: holidaysWhereInput | holidaysWhereInput[]
    id?: BigIntFilter<"holidays"> | bigint | number
    organization_id?: BigIntFilter<"holidays"> | bigint | number
    name?: StringFilter<"holidays"> | string
    holiday_date?: StringFilter<"holidays"> | string
    is_recurring?: IntFilter<"holidays"> | number
    created_at?: StringFilter<"holidays"> | string
    updated_at?: StringFilter<"holidays"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }

  export type holidaysOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    holiday_date?: SortOrder
    is_recurring?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
  }

  export type holidaysWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: holidaysWhereInput | holidaysWhereInput[]
    OR?: holidaysWhereInput[]
    NOT?: holidaysWhereInput | holidaysWhereInput[]
    organization_id?: BigIntFilter<"holidays"> | bigint | number
    name?: StringFilter<"holidays"> | string
    holiday_date?: StringFilter<"holidays"> | string
    is_recurring?: IntFilter<"holidays"> | number
    created_at?: StringFilter<"holidays"> | string
    updated_at?: StringFilter<"holidays"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }, "id">

  export type holidaysOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    holiday_date?: SortOrder
    is_recurring?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: holidaysCountOrderByAggregateInput
    _avg?: holidaysAvgOrderByAggregateInput
    _max?: holidaysMaxOrderByAggregateInput
    _min?: holidaysMinOrderByAggregateInput
    _sum?: holidaysSumOrderByAggregateInput
  }

  export type holidaysScalarWhereWithAggregatesInput = {
    AND?: holidaysScalarWhereWithAggregatesInput | holidaysScalarWhereWithAggregatesInput[]
    OR?: holidaysScalarWhereWithAggregatesInput[]
    NOT?: holidaysScalarWhereWithAggregatesInput | holidaysScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"holidays"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"holidays"> | bigint | number
    name?: StringWithAggregatesFilter<"holidays"> | string
    holiday_date?: StringWithAggregatesFilter<"holidays"> | string
    is_recurring?: IntWithAggregatesFilter<"holidays"> | number
    created_at?: StringWithAggregatesFilter<"holidays"> | string
    updated_at?: StringWithAggregatesFilter<"holidays"> | string
  }

  export type time_off_requestsWhereInput = {
    AND?: time_off_requestsWhereInput | time_off_requestsWhereInput[]
    OR?: time_off_requestsWhereInput[]
    NOT?: time_off_requestsWhereInput | time_off_requestsWhereInput[]
    id?: BigIntFilter<"time_off_requests"> | bigint | number
    user_id?: BigIntFilter<"time_off_requests"> | bigint | number
    start_date?: StringFilter<"time_off_requests"> | string
    end_date?: StringFilter<"time_off_requests"> | string
    reason?: StringFilter<"time_off_requests"> | string
    status?: EnumRequestStatusFilter<"time_off_requests"> | $Enums.RequestStatus
    created_at?: StringFilter<"time_off_requests"> | string
    updated_at?: StringFilter<"time_off_requests"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type time_off_requestsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type time_off_requestsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: time_off_requestsWhereInput | time_off_requestsWhereInput[]
    OR?: time_off_requestsWhereInput[]
    NOT?: time_off_requestsWhereInput | time_off_requestsWhereInput[]
    user_id?: BigIntFilter<"time_off_requests"> | bigint | number
    start_date?: StringFilter<"time_off_requests"> | string
    end_date?: StringFilter<"time_off_requests"> | string
    reason?: StringFilter<"time_off_requests"> | string
    status?: EnumRequestStatusFilter<"time_off_requests"> | $Enums.RequestStatus
    created_at?: StringFilter<"time_off_requests"> | string
    updated_at?: StringFilter<"time_off_requests"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type time_off_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: time_off_requestsCountOrderByAggregateInput
    _avg?: time_off_requestsAvgOrderByAggregateInput
    _max?: time_off_requestsMaxOrderByAggregateInput
    _min?: time_off_requestsMinOrderByAggregateInput
    _sum?: time_off_requestsSumOrderByAggregateInput
  }

  export type time_off_requestsScalarWhereWithAggregatesInput = {
    AND?: time_off_requestsScalarWhereWithAggregatesInput | time_off_requestsScalarWhereWithAggregatesInput[]
    OR?: time_off_requestsScalarWhereWithAggregatesInput[]
    NOT?: time_off_requestsScalarWhereWithAggregatesInput | time_off_requestsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"time_off_requests"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"time_off_requests"> | bigint | number
    start_date?: StringWithAggregatesFilter<"time_off_requests"> | string
    end_date?: StringWithAggregatesFilter<"time_off_requests"> | string
    reason?: StringWithAggregatesFilter<"time_off_requests"> | string
    status?: EnumRequestStatusWithAggregatesFilter<"time_off_requests"> | $Enums.RequestStatus
    created_at?: StringWithAggregatesFilter<"time_off_requests"> | string
    updated_at?: StringWithAggregatesFilter<"time_off_requests"> | string
  }

  export type crewsWhereInput = {
    AND?: crewsWhereInput | crewsWhereInput[]
    OR?: crewsWhereInput[]
    NOT?: crewsWhereInput | crewsWhereInput[]
    id?: BigIntFilter<"crews"> | bigint | number
    organization_id?: BigIntFilter<"crews"> | bigint | number
    name?: StringFilter<"crews"> | string
    leader_id?: BigIntFilter<"crews"> | bigint | number
    created_at?: StringFilter<"crews"> | string
    updated_at?: StringFilter<"crews"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    crew_members?: Crew_membersListRelationFilter
    work_order_crew?: Work_order_crewListRelationFilter
  }

  export type crewsOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    leader_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
    crew_members?: crew_membersOrderByRelationAggregateInput
    work_order_crew?: work_order_crewOrderByRelationAggregateInput
  }

  export type crewsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: crewsWhereInput | crewsWhereInput[]
    OR?: crewsWhereInput[]
    NOT?: crewsWhereInput | crewsWhereInput[]
    organization_id?: BigIntFilter<"crews"> | bigint | number
    name?: StringFilter<"crews"> | string
    leader_id?: BigIntFilter<"crews"> | bigint | number
    created_at?: StringFilter<"crews"> | string
    updated_at?: StringFilter<"crews"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    crew_members?: Crew_membersListRelationFilter
    work_order_crew?: Work_order_crewListRelationFilter
  }, "id">

  export type crewsOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    leader_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: crewsCountOrderByAggregateInput
    _avg?: crewsAvgOrderByAggregateInput
    _max?: crewsMaxOrderByAggregateInput
    _min?: crewsMinOrderByAggregateInput
    _sum?: crewsSumOrderByAggregateInput
  }

  export type crewsScalarWhereWithAggregatesInput = {
    AND?: crewsScalarWhereWithAggregatesInput | crewsScalarWhereWithAggregatesInput[]
    OR?: crewsScalarWhereWithAggregatesInput[]
    NOT?: crewsScalarWhereWithAggregatesInput | crewsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"crews"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"crews"> | bigint | number
    name?: StringWithAggregatesFilter<"crews"> | string
    leader_id?: BigIntWithAggregatesFilter<"crews"> | bigint | number
    created_at?: StringWithAggregatesFilter<"crews"> | string
    updated_at?: StringWithAggregatesFilter<"crews"> | string
  }

  export type crew_membersWhereInput = {
    AND?: crew_membersWhereInput | crew_membersWhereInput[]
    OR?: crew_membersWhereInput[]
    NOT?: crew_membersWhereInput | crew_membersWhereInput[]
    id?: BigIntFilter<"crew_members"> | bigint | number
    organization_id?: BigIntFilter<"crew_members"> | bigint | number
    crew_id?: BigIntFilter<"crew_members"> | bigint | number
    user_id?: BigIntFilter<"crew_members"> | bigint | number
    role?: StringFilter<"crew_members"> | string
    created_at?: StringFilter<"crew_members"> | string
    updated_at?: StringFilter<"crew_members"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    crews?: XOR<CrewsScalarRelationFilter, crewsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type crew_membersOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    crew_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    crews?: crewsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type crew_membersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: crew_membersWhereInput | crew_membersWhereInput[]
    OR?: crew_membersWhereInput[]
    NOT?: crew_membersWhereInput | crew_membersWhereInput[]
    organization_id?: BigIntFilter<"crew_members"> | bigint | number
    crew_id?: BigIntFilter<"crew_members"> | bigint | number
    user_id?: BigIntFilter<"crew_members"> | bigint | number
    role?: StringFilter<"crew_members"> | string
    created_at?: StringFilter<"crew_members"> | string
    updated_at?: StringFilter<"crew_members"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    crews?: XOR<CrewsScalarRelationFilter, crewsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type crew_membersOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    crew_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: crew_membersCountOrderByAggregateInput
    _avg?: crew_membersAvgOrderByAggregateInput
    _max?: crew_membersMaxOrderByAggregateInput
    _min?: crew_membersMinOrderByAggregateInput
    _sum?: crew_membersSumOrderByAggregateInput
  }

  export type crew_membersScalarWhereWithAggregatesInput = {
    AND?: crew_membersScalarWhereWithAggregatesInput | crew_membersScalarWhereWithAggregatesInput[]
    OR?: crew_membersScalarWhereWithAggregatesInput[]
    NOT?: crew_membersScalarWhereWithAggregatesInput | crew_membersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"crew_members"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"crew_members"> | bigint | number
    crew_id?: BigIntWithAggregatesFilter<"crew_members"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"crew_members"> | bigint | number
    role?: StringWithAggregatesFilter<"crew_members"> | string
    created_at?: StringWithAggregatesFilter<"crew_members"> | string
    updated_at?: StringWithAggregatesFilter<"crew_members"> | string
  }

  export type equipmentsWhereInput = {
    AND?: equipmentsWhereInput | equipmentsWhereInput[]
    OR?: equipmentsWhereInput[]
    NOT?: equipmentsWhereInput | equipmentsWhereInput[]
    id?: BigIntFilter<"equipments"> | bigint | number
    organization_id?: BigIntFilter<"equipments"> | bigint | number
    name?: StringFilter<"equipments"> | string
    equipment_type?: StringFilter<"equipments"> | string
    status?: EnumEqupmentStatusFilter<"equipments"> | $Enums.EqupmentStatus
    location?: StringFilter<"equipments"> | string
    availability_date?: StringFilter<"equipments"> | string
    created_at?: StringFilter<"equipments"> | string
    updated_at?: StringFilter<"equipments"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }

  export type equipmentsOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    equipment_type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    availability_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
  }

  export type equipmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: equipmentsWhereInput | equipmentsWhereInput[]
    OR?: equipmentsWhereInput[]
    NOT?: equipmentsWhereInput | equipmentsWhereInput[]
    organization_id?: BigIntFilter<"equipments"> | bigint | number
    name?: StringFilter<"equipments"> | string
    equipment_type?: StringFilter<"equipments"> | string
    status?: EnumEqupmentStatusFilter<"equipments"> | $Enums.EqupmentStatus
    location?: StringFilter<"equipments"> | string
    availability_date?: StringFilter<"equipments"> | string
    created_at?: StringFilter<"equipments"> | string
    updated_at?: StringFilter<"equipments"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
  }, "id">

  export type equipmentsOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    equipment_type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    availability_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: equipmentsCountOrderByAggregateInput
    _avg?: equipmentsAvgOrderByAggregateInput
    _max?: equipmentsMaxOrderByAggregateInput
    _min?: equipmentsMinOrderByAggregateInput
    _sum?: equipmentsSumOrderByAggregateInput
  }

  export type equipmentsScalarWhereWithAggregatesInput = {
    AND?: equipmentsScalarWhereWithAggregatesInput | equipmentsScalarWhereWithAggregatesInput[]
    OR?: equipmentsScalarWhereWithAggregatesInput[]
    NOT?: equipmentsScalarWhereWithAggregatesInput | equipmentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"equipments"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"equipments"> | bigint | number
    name?: StringWithAggregatesFilter<"equipments"> | string
    equipment_type?: StringWithAggregatesFilter<"equipments"> | string
    status?: EnumEqupmentStatusWithAggregatesFilter<"equipments"> | $Enums.EqupmentStatus
    location?: StringWithAggregatesFilter<"equipments"> | string
    availability_date?: StringWithAggregatesFilter<"equipments"> | string
    created_at?: StringWithAggregatesFilter<"equipments"> | string
    updated_at?: StringWithAggregatesFilter<"equipments"> | string
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: BigIntFilter<"companies"> | bigint | number
    organization_id?: BigIntFilter<"companies"> | bigint | number
    name?: StringFilter<"companies"> | string
    industry?: StringFilter<"companies"> | string
    tax_id?: StringFilter<"companies"> | string
    address?: StringFilter<"companies"> | string
    phone?: StringFilter<"companies"> | string
    email?: StringFilter<"companies"> | string
    website?: StringFilter<"companies"> | string
    created_at?: StringFilter<"companies"> | string
    updated_at?: StringFilter<"companies"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    customers?: CustomersListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    tax_id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    customers?: customersOrderByRelationAggregateInput
    work_orders?: work_ordersOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    phone?: string
    email?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    organization_id?: BigIntFilter<"companies"> | bigint | number
    name?: StringFilter<"companies"> | string
    industry?: StringFilter<"companies"> | string
    tax_id?: StringFilter<"companies"> | string
    address?: StringFilter<"companies"> | string
    website?: StringFilter<"companies"> | string
    created_at?: StringFilter<"companies"> | string
    updated_at?: StringFilter<"companies"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    customers?: CustomersListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }, "id" | "phone" | "email">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    tax_id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"companies"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"companies"> | bigint | number
    name?: StringWithAggregatesFilter<"companies"> | string
    industry?: StringWithAggregatesFilter<"companies"> | string
    tax_id?: StringWithAggregatesFilter<"companies"> | string
    address?: StringWithAggregatesFilter<"companies"> | string
    phone?: StringWithAggregatesFilter<"companies"> | string
    email?: StringWithAggregatesFilter<"companies"> | string
    website?: StringWithAggregatesFilter<"companies"> | string
    created_at?: StringWithAggregatesFilter<"companies"> | string
    updated_at?: StringWithAggregatesFilter<"companies"> | string
  }

  export type customersWhereInput = {
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    id?: BigIntFilter<"customers"> | bigint | number
    organization_id?: BigIntFilter<"customers"> | bigint | number
    company_id?: BigIntFilter<"customers"> | bigint | number
    first_name?: StringFilter<"customers"> | string
    last_name?: StringFilter<"customers"> | string
    email?: StringFilter<"customers"> | string
    phone?: StringFilter<"customers"> | string
    address?: StringFilter<"customers"> | string
    is_active?: IntFilter<"customers"> | number
    created_at?: StringFilter<"customers"> | string
    updated_at?: StringFilter<"customers"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    assets?: AssetsListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }

  export type customersOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    company_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    assets?: assetsOrderByRelationAggregateInput
    work_orders?: work_ordersOrderByRelationAggregateInput
  }

  export type customersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    phone?: string
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    organization_id?: BigIntFilter<"customers"> | bigint | number
    company_id?: BigIntFilter<"customers"> | bigint | number
    first_name?: StringFilter<"customers"> | string
    last_name?: StringFilter<"customers"> | string
    address?: StringFilter<"customers"> | string
    is_active?: IntFilter<"customers"> | number
    created_at?: StringFilter<"customers"> | string
    updated_at?: StringFilter<"customers"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    assets?: AssetsListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }, "id" | "email" | "phone">

  export type customersOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    company_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: customersCountOrderByAggregateInput
    _avg?: customersAvgOrderByAggregateInput
    _max?: customersMaxOrderByAggregateInput
    _min?: customersMinOrderByAggregateInput
    _sum?: customersSumOrderByAggregateInput
  }

  export type customersScalarWhereWithAggregatesInput = {
    AND?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    OR?: customersScalarWhereWithAggregatesInput[]
    NOT?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"customers"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"customers"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"customers"> | bigint | number
    first_name?: StringWithAggregatesFilter<"customers"> | string
    last_name?: StringWithAggregatesFilter<"customers"> | string
    email?: StringWithAggregatesFilter<"customers"> | string
    phone?: StringWithAggregatesFilter<"customers"> | string
    address?: StringWithAggregatesFilter<"customers"> | string
    is_active?: IntWithAggregatesFilter<"customers"> | number
    created_at?: StringWithAggregatesFilter<"customers"> | string
    updated_at?: StringWithAggregatesFilter<"customers"> | string
  }

  export type servicesWhereInput = {
    AND?: servicesWhereInput | servicesWhereInput[]
    OR?: servicesWhereInput[]
    NOT?: servicesWhereInput | servicesWhereInput[]
    id?: BigIntFilter<"services"> | bigint | number
    organization_id?: BigIntFilter<"services"> | bigint | number
    description?: StringFilter<"services"> | string
    duration?: IntFilter<"services"> | number
    price?: DecimalFilter<"services"> | Decimal | DecimalJsLike | number | string
    required_skills?: JsonFilter<"services">
    created_at?: StringFilter<"services"> | string
    updated_at?: StringFilter<"services"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    work_order_services?: Work_order_servicesListRelationFilter
    invoice_items?: Invoice_itemsListRelationFilter
  }

  export type servicesOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    required_skills?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    work_order_services?: work_order_servicesOrderByRelationAggregateInput
    invoice_items?: invoice_itemsOrderByRelationAggregateInput
  }

  export type servicesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: servicesWhereInput | servicesWhereInput[]
    OR?: servicesWhereInput[]
    NOT?: servicesWhereInput | servicesWhereInput[]
    organization_id?: BigIntFilter<"services"> | bigint | number
    description?: StringFilter<"services"> | string
    duration?: IntFilter<"services"> | number
    price?: DecimalFilter<"services"> | Decimal | DecimalJsLike | number | string
    required_skills?: JsonFilter<"services">
    created_at?: StringFilter<"services"> | string
    updated_at?: StringFilter<"services"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    work_order_services?: Work_order_servicesListRelationFilter
    invoice_items?: Invoice_itemsListRelationFilter
  }, "id">

  export type servicesOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    required_skills?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: servicesCountOrderByAggregateInput
    _avg?: servicesAvgOrderByAggregateInput
    _max?: servicesMaxOrderByAggregateInput
    _min?: servicesMinOrderByAggregateInput
    _sum?: servicesSumOrderByAggregateInput
  }

  export type servicesScalarWhereWithAggregatesInput = {
    AND?: servicesScalarWhereWithAggregatesInput | servicesScalarWhereWithAggregatesInput[]
    OR?: servicesScalarWhereWithAggregatesInput[]
    NOT?: servicesScalarWhereWithAggregatesInput | servicesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"services"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"services"> | bigint | number
    description?: StringWithAggregatesFilter<"services"> | string
    duration?: IntWithAggregatesFilter<"services"> | number
    price?: DecimalWithAggregatesFilter<"services"> | Decimal | DecimalJsLike | number | string
    required_skills?: JsonWithAggregatesFilter<"services">
    created_at?: StringWithAggregatesFilter<"services"> | string
    updated_at?: StringWithAggregatesFilter<"services"> | string
  }

  export type assetsWhereInput = {
    AND?: assetsWhereInput | assetsWhereInput[]
    OR?: assetsWhereInput[]
    NOT?: assetsWhereInput | assetsWhereInput[]
    id?: BigIntFilter<"assets"> | bigint | number
    organization_id?: BigIntFilter<"assets"> | bigint | number
    customer_id?: BigIntFilter<"assets"> | bigint | number
    asset_name?: StringFilter<"assets"> | string
    serial_number?: StringFilter<"assets"> | string
    model?: StringFilter<"assets"> | string
    manufacturer?: StringFilter<"assets"> | string
    status?: EnumAssetStatusFilter<"assets"> | $Enums.AssetStatus
    location?: StringFilter<"assets"> | string
    notes?: StringFilter<"assets"> | string
    purchase_date?: StringFilter<"assets"> | string
    warranty_expiry?: StringFilter<"assets"> | string
    created_at?: StringFilter<"assets"> | string
    updated_at?: StringFilter<"assets"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    customers?: XOR<CustomersScalarRelationFilter, customersWhereInput>
    work_orders?: Work_ordersListRelationFilter
  }

  export type assetsOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    asset_name?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    purchase_date?: SortOrder
    warranty_expiry?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    customers?: customersOrderByWithRelationInput
    work_orders?: work_ordersOrderByRelationAggregateInput
  }

  export type assetsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: assetsWhereInput | assetsWhereInput[]
    OR?: assetsWhereInput[]
    NOT?: assetsWhereInput | assetsWhereInput[]
    organization_id?: BigIntFilter<"assets"> | bigint | number
    customer_id?: BigIntFilter<"assets"> | bigint | number
    asset_name?: StringFilter<"assets"> | string
    serial_number?: StringFilter<"assets"> | string
    model?: StringFilter<"assets"> | string
    manufacturer?: StringFilter<"assets"> | string
    status?: EnumAssetStatusFilter<"assets"> | $Enums.AssetStatus
    location?: StringFilter<"assets"> | string
    notes?: StringFilter<"assets"> | string
    purchase_date?: StringFilter<"assets"> | string
    warranty_expiry?: StringFilter<"assets"> | string
    created_at?: StringFilter<"assets"> | string
    updated_at?: StringFilter<"assets"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    customers?: XOR<CustomersScalarRelationFilter, customersWhereInput>
    work_orders?: Work_ordersListRelationFilter
  }, "id">

  export type assetsOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    asset_name?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    purchase_date?: SortOrder
    warranty_expiry?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: assetsCountOrderByAggregateInput
    _avg?: assetsAvgOrderByAggregateInput
    _max?: assetsMaxOrderByAggregateInput
    _min?: assetsMinOrderByAggregateInput
    _sum?: assetsSumOrderByAggregateInput
  }

  export type assetsScalarWhereWithAggregatesInput = {
    AND?: assetsScalarWhereWithAggregatesInput | assetsScalarWhereWithAggregatesInput[]
    OR?: assetsScalarWhereWithAggregatesInput[]
    NOT?: assetsScalarWhereWithAggregatesInput | assetsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"assets"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"assets"> | bigint | number
    customer_id?: BigIntWithAggregatesFilter<"assets"> | bigint | number
    asset_name?: StringWithAggregatesFilter<"assets"> | string
    serial_number?: StringWithAggregatesFilter<"assets"> | string
    model?: StringWithAggregatesFilter<"assets"> | string
    manufacturer?: StringWithAggregatesFilter<"assets"> | string
    status?: EnumAssetStatusWithAggregatesFilter<"assets"> | $Enums.AssetStatus
    location?: StringWithAggregatesFilter<"assets"> | string
    notes?: StringWithAggregatesFilter<"assets"> | string
    purchase_date?: StringWithAggregatesFilter<"assets"> | string
    warranty_expiry?: StringWithAggregatesFilter<"assets"> | string
    created_at?: StringWithAggregatesFilter<"assets"> | string
    updated_at?: StringWithAggregatesFilter<"assets"> | string
  }

  export type partsWhereInput = {
    AND?: partsWhereInput | partsWhereInput[]
    OR?: partsWhereInput[]
    NOT?: partsWhereInput | partsWhereInput[]
    id?: BigIntFilter<"parts"> | bigint | number
    organization_id?: BigIntFilter<"parts"> | bigint | number
    name?: StringFilter<"parts"> | string
    description?: StringFilter<"parts"> | string
    price?: DecimalFilter<"parts"> | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFilter<"parts"> | number
    reorder_level?: IntFilter<"parts"> | number
    created_at?: StringFilter<"parts"> | string
    updated_at?: StringFilter<"parts"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    invoice_items?: Invoice_itemsListRelationFilter
  }

  export type partsOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    inventory_count?: SortOrder
    reorder_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    invoice_items?: invoice_itemsOrderByRelationAggregateInput
  }

  export type partsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: partsWhereInput | partsWhereInput[]
    OR?: partsWhereInput[]
    NOT?: partsWhereInput | partsWhereInput[]
    organization_id?: BigIntFilter<"parts"> | bigint | number
    name?: StringFilter<"parts"> | string
    description?: StringFilter<"parts"> | string
    price?: DecimalFilter<"parts"> | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFilter<"parts"> | number
    reorder_level?: IntFilter<"parts"> | number
    created_at?: StringFilter<"parts"> | string
    updated_at?: StringFilter<"parts"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    invoice_items?: Invoice_itemsListRelationFilter
  }, "id">

  export type partsOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    inventory_count?: SortOrder
    reorder_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: partsCountOrderByAggregateInput
    _avg?: partsAvgOrderByAggregateInput
    _max?: partsMaxOrderByAggregateInput
    _min?: partsMinOrderByAggregateInput
    _sum?: partsSumOrderByAggregateInput
  }

  export type partsScalarWhereWithAggregatesInput = {
    AND?: partsScalarWhereWithAggregatesInput | partsScalarWhereWithAggregatesInput[]
    OR?: partsScalarWhereWithAggregatesInput[]
    NOT?: partsScalarWhereWithAggregatesInput | partsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"parts"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"parts"> | bigint | number
    name?: StringWithAggregatesFilter<"parts"> | string
    description?: StringWithAggregatesFilter<"parts"> | string
    price?: DecimalWithAggregatesFilter<"parts"> | Decimal | DecimalJsLike | number | string
    inventory_count?: IntWithAggregatesFilter<"parts"> | number
    reorder_level?: IntWithAggregatesFilter<"parts"> | number
    created_at?: StringWithAggregatesFilter<"parts"> | string
    updated_at?: StringWithAggregatesFilter<"parts"> | string
  }

  export type maintenance_plansWhereInput = {
    AND?: maintenance_plansWhereInput | maintenance_plansWhereInput[]
    OR?: maintenance_plansWhereInput[]
    NOT?: maintenance_plansWhereInput | maintenance_plansWhereInput[]
    id?: BigIntFilter<"maintenance_plans"> | bigint | number
    organization_id?: BigIntFilter<"maintenance_plans"> | bigint | number
    name?: StringFilter<"maintenance_plans"> | string
    description?: StringFilter<"maintenance_plans"> | string
    start_date?: StringFilter<"maintenance_plans"> | string
    end_date?: StringFilter<"maintenance_plans"> | string
    frequency?: EnumFrequencyFilter<"maintenance_plans"> | $Enums.Frequency
    frequency_unit?: IntFilter<"maintenance_plans"> | number
    frequency_unit_type?: EnumFrequencyUnitTypeFilter<"maintenance_plans"> | $Enums.FrequencyUnitType
    is_active?: IntFilter<"maintenance_plans"> | number
    created_at?: StringFilter<"maintenance_plans"> | string
    updated_at?: StringFilter<"maintenance_plans"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    maintenance_plan_assets?: Maintenance_plan_assetsListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }

  export type maintenance_plansOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    frequency?: SortOrder
    frequency_unit?: SortOrder
    frequency_unit_type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    maintenance_plan_assets?: maintenance_plan_assetsOrderByRelationAggregateInput
    work_orders?: work_ordersOrderByRelationAggregateInput
  }

  export type maintenance_plansWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: maintenance_plansWhereInput | maintenance_plansWhereInput[]
    OR?: maintenance_plansWhereInput[]
    NOT?: maintenance_plansWhereInput | maintenance_plansWhereInput[]
    organization_id?: BigIntFilter<"maintenance_plans"> | bigint | number
    name?: StringFilter<"maintenance_plans"> | string
    description?: StringFilter<"maintenance_plans"> | string
    start_date?: StringFilter<"maintenance_plans"> | string
    end_date?: StringFilter<"maintenance_plans"> | string
    frequency?: EnumFrequencyFilter<"maintenance_plans"> | $Enums.Frequency
    frequency_unit?: IntFilter<"maintenance_plans"> | number
    frequency_unit_type?: EnumFrequencyUnitTypeFilter<"maintenance_plans"> | $Enums.FrequencyUnitType
    is_active?: IntFilter<"maintenance_plans"> | number
    created_at?: StringFilter<"maintenance_plans"> | string
    updated_at?: StringFilter<"maintenance_plans"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    maintenance_plan_assets?: Maintenance_plan_assetsListRelationFilter
    work_orders?: Work_ordersListRelationFilter
  }, "id">

  export type maintenance_plansOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    frequency?: SortOrder
    frequency_unit?: SortOrder
    frequency_unit_type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: maintenance_plansCountOrderByAggregateInput
    _avg?: maintenance_plansAvgOrderByAggregateInput
    _max?: maintenance_plansMaxOrderByAggregateInput
    _min?: maintenance_plansMinOrderByAggregateInput
    _sum?: maintenance_plansSumOrderByAggregateInput
  }

  export type maintenance_plansScalarWhereWithAggregatesInput = {
    AND?: maintenance_plansScalarWhereWithAggregatesInput | maintenance_plansScalarWhereWithAggregatesInput[]
    OR?: maintenance_plansScalarWhereWithAggregatesInput[]
    NOT?: maintenance_plansScalarWhereWithAggregatesInput | maintenance_plansScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"maintenance_plans"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"maintenance_plans"> | bigint | number
    name?: StringWithAggregatesFilter<"maintenance_plans"> | string
    description?: StringWithAggregatesFilter<"maintenance_plans"> | string
    start_date?: StringWithAggregatesFilter<"maintenance_plans"> | string
    end_date?: StringWithAggregatesFilter<"maintenance_plans"> | string
    frequency?: EnumFrequencyWithAggregatesFilter<"maintenance_plans"> | $Enums.Frequency
    frequency_unit?: IntWithAggregatesFilter<"maintenance_plans"> | number
    frequency_unit_type?: EnumFrequencyUnitTypeWithAggregatesFilter<"maintenance_plans"> | $Enums.FrequencyUnitType
    is_active?: IntWithAggregatesFilter<"maintenance_plans"> | number
    created_at?: StringWithAggregatesFilter<"maintenance_plans"> | string
    updated_at?: StringWithAggregatesFilter<"maintenance_plans"> | string
  }

  export type maintenance_plan_assetsWhereInput = {
    AND?: maintenance_plan_assetsWhereInput | maintenance_plan_assetsWhereInput[]
    OR?: maintenance_plan_assetsWhereInput[]
    NOT?: maintenance_plan_assetsWhereInput | maintenance_plan_assetsWhereInput[]
    id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    maintenance_plan_id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    asset_id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    assigned_at?: StringFilter<"maintenance_plan_assets"> | string
    created_at?: StringFilter<"maintenance_plan_assets"> | string
    updated_at?: StringFilter<"maintenance_plan_assets"> | string
    maintenance_plans?: XOR<Maintenance_plansScalarRelationFilter, maintenance_plansWhereInput>
  }

  export type maintenance_plan_assetsOrderByWithRelationInput = {
    id?: SortOrder
    maintenance_plan_id?: SortOrder
    asset_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    maintenance_plans?: maintenance_plansOrderByWithRelationInput
  }

  export type maintenance_plan_assetsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: maintenance_plan_assetsWhereInput | maintenance_plan_assetsWhereInput[]
    OR?: maintenance_plan_assetsWhereInput[]
    NOT?: maintenance_plan_assetsWhereInput | maintenance_plan_assetsWhereInput[]
    maintenance_plan_id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    asset_id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    assigned_at?: StringFilter<"maintenance_plan_assets"> | string
    created_at?: StringFilter<"maintenance_plan_assets"> | string
    updated_at?: StringFilter<"maintenance_plan_assets"> | string
    maintenance_plans?: XOR<Maintenance_plansScalarRelationFilter, maintenance_plansWhereInput>
  }, "id">

  export type maintenance_plan_assetsOrderByWithAggregationInput = {
    id?: SortOrder
    maintenance_plan_id?: SortOrder
    asset_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: maintenance_plan_assetsCountOrderByAggregateInput
    _avg?: maintenance_plan_assetsAvgOrderByAggregateInput
    _max?: maintenance_plan_assetsMaxOrderByAggregateInput
    _min?: maintenance_plan_assetsMinOrderByAggregateInput
    _sum?: maintenance_plan_assetsSumOrderByAggregateInput
  }

  export type maintenance_plan_assetsScalarWhereWithAggregatesInput = {
    AND?: maintenance_plan_assetsScalarWhereWithAggregatesInput | maintenance_plan_assetsScalarWhereWithAggregatesInput[]
    OR?: maintenance_plan_assetsScalarWhereWithAggregatesInput[]
    NOT?: maintenance_plan_assetsScalarWhereWithAggregatesInput | maintenance_plan_assetsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"maintenance_plan_assets"> | bigint | number
    maintenance_plan_id?: BigIntWithAggregatesFilter<"maintenance_plan_assets"> | bigint | number
    asset_id?: BigIntWithAggregatesFilter<"maintenance_plan_assets"> | bigint | number
    assigned_at?: StringWithAggregatesFilter<"maintenance_plan_assets"> | string
    created_at?: StringWithAggregatesFilter<"maintenance_plan_assets"> | string
    updated_at?: StringWithAggregatesFilter<"maintenance_plan_assets"> | string
  }

  export type work_ordersWhereInput = {
    AND?: work_ordersWhereInput | work_ordersWhereInput[]
    OR?: work_ordersWhereInput[]
    NOT?: work_ordersWhereInput | work_ordersWhereInput[]
    id?: BigIntFilter<"work_orders"> | bigint | number
    organization_id?: BigIntFilter<"work_orders"> | bigint | number
    customer_id?: BigIntFilter<"work_orders"> | bigint | number
    company_id?: BigIntFilter<"work_orders"> | bigint | number
    asset_id?: BigIntFilter<"work_orders"> | bigint | number
    maintenance_plan_id?: BigIntFilter<"work_orders"> | bigint | number
    title?: StringFilter<"work_orders"> | string
    description?: StringFilter<"work_orders"> | string
    priority?: EnumPrioirtyFilter<"work_orders"> | $Enums.Prioirty
    status?: EnumWorkOrderStatusFilter<"work_orders"> | $Enums.WorkOrderStatus
    assigned_to?: StringFilter<"work_orders"> | string
    assigned_crew_id?: IntFilter<"work_orders"> | number
    scheduled_start_date?: StringFilter<"work_orders"> | string
    scheduled_end_date?: StringFilter<"work_orders"> | string
    actual_start_date?: StringFilter<"work_orders"> | string
    actual_end_date?: StringFilter<"work_orders"> | string
    currency_id?: IntFilter<"work_orders"> | number
    estimated_cost?: DecimalFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    address?: StringFilter<"work_orders"> | string
    city?: StringFilter<"work_orders"> | string
    state?: StringFilter<"work_orders"> | string
    postal_code?: StringFilter<"work_orders"> | string
    country?: StringFilter<"work_orders"> | string
    is_multi_day?: IntFilter<"work_orders"> | number
    created_at?: StringFilter<"work_orders"> | string
    updated_at?: StringFilter<"work_orders"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    customers?: XOR<CustomersScalarRelationFilter, customersWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    assets?: XOR<AssetsScalarRelationFilter, assetsWhereInput>
    maintenance_plans?: XOR<Maintenance_plansScalarRelationFilter, maintenance_plansWhereInput>
    work_order_services?: Work_order_servicesListRelationFilter
    work_order_tasks?: Work_order_tasksListRelationFilter
    work_order_assets?: Work_order_assetsListRelationFilter
    work_order_crew?: Work_order_crewListRelationFilter
    work_order_approvals?: Work_order_approvalsListRelationFilter
    invoices?: InvoicesListRelationFilter
  }

  export type work_ordersOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    asset_id?: SortOrder
    maintenance_plan_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    assigned_crew_id?: SortOrder
    scheduled_start_date?: SortOrder
    scheduled_end_date?: SortOrder
    actual_start_date?: SortOrder
    actual_end_date?: SortOrder
    currency_id?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_multi_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organizations?: organizationsOrderByWithRelationInput
    customers?: customersOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    assets?: assetsOrderByWithRelationInput
    maintenance_plans?: maintenance_plansOrderByWithRelationInput
    work_order_services?: work_order_servicesOrderByRelationAggregateInput
    work_order_tasks?: work_order_tasksOrderByRelationAggregateInput
    work_order_assets?: work_order_assetsOrderByRelationAggregateInput
    work_order_crew?: work_order_crewOrderByRelationAggregateInput
    work_order_approvals?: work_order_approvalsOrderByRelationAggregateInput
    invoices?: invoicesOrderByRelationAggregateInput
  }

  export type work_ordersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: work_ordersWhereInput | work_ordersWhereInput[]
    OR?: work_ordersWhereInput[]
    NOT?: work_ordersWhereInput | work_ordersWhereInput[]
    organization_id?: BigIntFilter<"work_orders"> | bigint | number
    customer_id?: BigIntFilter<"work_orders"> | bigint | number
    company_id?: BigIntFilter<"work_orders"> | bigint | number
    asset_id?: BigIntFilter<"work_orders"> | bigint | number
    maintenance_plan_id?: BigIntFilter<"work_orders"> | bigint | number
    title?: StringFilter<"work_orders"> | string
    description?: StringFilter<"work_orders"> | string
    priority?: EnumPrioirtyFilter<"work_orders"> | $Enums.Prioirty
    status?: EnumWorkOrderStatusFilter<"work_orders"> | $Enums.WorkOrderStatus
    assigned_to?: StringFilter<"work_orders"> | string
    assigned_crew_id?: IntFilter<"work_orders"> | number
    scheduled_start_date?: StringFilter<"work_orders"> | string
    scheduled_end_date?: StringFilter<"work_orders"> | string
    actual_start_date?: StringFilter<"work_orders"> | string
    actual_end_date?: StringFilter<"work_orders"> | string
    currency_id?: IntFilter<"work_orders"> | number
    estimated_cost?: DecimalFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    address?: StringFilter<"work_orders"> | string
    city?: StringFilter<"work_orders"> | string
    state?: StringFilter<"work_orders"> | string
    postal_code?: StringFilter<"work_orders"> | string
    country?: StringFilter<"work_orders"> | string
    is_multi_day?: IntFilter<"work_orders"> | number
    created_at?: StringFilter<"work_orders"> | string
    updated_at?: StringFilter<"work_orders"> | string
    organizations?: XOR<OrganizationsScalarRelationFilter, organizationsWhereInput>
    customers?: XOR<CustomersScalarRelationFilter, customersWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    assets?: XOR<AssetsScalarRelationFilter, assetsWhereInput>
    maintenance_plans?: XOR<Maintenance_plansScalarRelationFilter, maintenance_plansWhereInput>
    work_order_services?: Work_order_servicesListRelationFilter
    work_order_tasks?: Work_order_tasksListRelationFilter
    work_order_assets?: Work_order_assetsListRelationFilter
    work_order_crew?: Work_order_crewListRelationFilter
    work_order_approvals?: Work_order_approvalsListRelationFilter
    invoices?: InvoicesListRelationFilter
  }, "id">

  export type work_ordersOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    asset_id?: SortOrder
    maintenance_plan_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    assigned_crew_id?: SortOrder
    scheduled_start_date?: SortOrder
    scheduled_end_date?: SortOrder
    actual_start_date?: SortOrder
    actual_end_date?: SortOrder
    currency_id?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_multi_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: work_ordersCountOrderByAggregateInput
    _avg?: work_ordersAvgOrderByAggregateInput
    _max?: work_ordersMaxOrderByAggregateInput
    _min?: work_ordersMinOrderByAggregateInput
    _sum?: work_ordersSumOrderByAggregateInput
  }

  export type work_ordersScalarWhereWithAggregatesInput = {
    AND?: work_ordersScalarWhereWithAggregatesInput | work_ordersScalarWhereWithAggregatesInput[]
    OR?: work_ordersScalarWhereWithAggregatesInput[]
    NOT?: work_ordersScalarWhereWithAggregatesInput | work_ordersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"work_orders"> | bigint | number
    organization_id?: BigIntWithAggregatesFilter<"work_orders"> | bigint | number
    customer_id?: BigIntWithAggregatesFilter<"work_orders"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"work_orders"> | bigint | number
    asset_id?: BigIntWithAggregatesFilter<"work_orders"> | bigint | number
    maintenance_plan_id?: BigIntWithAggregatesFilter<"work_orders"> | bigint | number
    title?: StringWithAggregatesFilter<"work_orders"> | string
    description?: StringWithAggregatesFilter<"work_orders"> | string
    priority?: EnumPrioirtyWithAggregatesFilter<"work_orders"> | $Enums.Prioirty
    status?: EnumWorkOrderStatusWithAggregatesFilter<"work_orders"> | $Enums.WorkOrderStatus
    assigned_to?: StringWithAggregatesFilter<"work_orders"> | string
    assigned_crew_id?: IntWithAggregatesFilter<"work_orders"> | number
    scheduled_start_date?: StringWithAggregatesFilter<"work_orders"> | string
    scheduled_end_date?: StringWithAggregatesFilter<"work_orders"> | string
    actual_start_date?: StringWithAggregatesFilter<"work_orders"> | string
    actual_end_date?: StringWithAggregatesFilter<"work_orders"> | string
    currency_id?: IntWithAggregatesFilter<"work_orders"> | number
    estimated_cost?: DecimalWithAggregatesFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalWithAggregatesFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    address?: StringWithAggregatesFilter<"work_orders"> | string
    city?: StringWithAggregatesFilter<"work_orders"> | string
    state?: StringWithAggregatesFilter<"work_orders"> | string
    postal_code?: StringWithAggregatesFilter<"work_orders"> | string
    country?: StringWithAggregatesFilter<"work_orders"> | string
    is_multi_day?: IntWithAggregatesFilter<"work_orders"> | number
    created_at?: StringWithAggregatesFilter<"work_orders"> | string
    updated_at?: StringWithAggregatesFilter<"work_orders"> | string
  }

  export type work_order_servicesWhereInput = {
    AND?: work_order_servicesWhereInput | work_order_servicesWhereInput[]
    OR?: work_order_servicesWhereInput[]
    NOT?: work_order_servicesWhereInput | work_order_servicesWhereInput[]
    id?: BigIntFilter<"work_order_services"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_services"> | bigint | number
    service_id?: BigIntFilter<"work_order_services"> | bigint | number
    quantity?: IntFilter<"work_order_services"> | number
    service_cost?: DecimalFilter<"work_order_services"> | Decimal | DecimalJsLike | number | string
    created_at?: StringFilter<"work_order_services"> | string
    updated_at?: StringFilter<"work_order_services"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
    services?: XOR<ServicesScalarRelationFilter, servicesWhereInput>
  }

  export type work_order_servicesOrderByWithRelationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    work_orders?: work_ordersOrderByWithRelationInput
    services?: servicesOrderByWithRelationInput
  }

  export type work_order_servicesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: work_order_servicesWhereInput | work_order_servicesWhereInput[]
    OR?: work_order_servicesWhereInput[]
    NOT?: work_order_servicesWhereInput | work_order_servicesWhereInput[]
    work_order_id?: BigIntFilter<"work_order_services"> | bigint | number
    service_id?: BigIntFilter<"work_order_services"> | bigint | number
    quantity?: IntFilter<"work_order_services"> | number
    service_cost?: DecimalFilter<"work_order_services"> | Decimal | DecimalJsLike | number | string
    created_at?: StringFilter<"work_order_services"> | string
    updated_at?: StringFilter<"work_order_services"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
    services?: XOR<ServicesScalarRelationFilter, servicesWhereInput>
  }, "id">

  export type work_order_servicesOrderByWithAggregationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: work_order_servicesCountOrderByAggregateInput
    _avg?: work_order_servicesAvgOrderByAggregateInput
    _max?: work_order_servicesMaxOrderByAggregateInput
    _min?: work_order_servicesMinOrderByAggregateInput
    _sum?: work_order_servicesSumOrderByAggregateInput
  }

  export type work_order_servicesScalarWhereWithAggregatesInput = {
    AND?: work_order_servicesScalarWhereWithAggregatesInput | work_order_servicesScalarWhereWithAggregatesInput[]
    OR?: work_order_servicesScalarWhereWithAggregatesInput[]
    NOT?: work_order_servicesScalarWhereWithAggregatesInput | work_order_servicesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"work_order_services"> | bigint | number
    work_order_id?: BigIntWithAggregatesFilter<"work_order_services"> | bigint | number
    service_id?: BigIntWithAggregatesFilter<"work_order_services"> | bigint | number
    quantity?: IntWithAggregatesFilter<"work_order_services"> | number
    service_cost?: DecimalWithAggregatesFilter<"work_order_services"> | Decimal | DecimalJsLike | number | string
    created_at?: StringWithAggregatesFilter<"work_order_services"> | string
    updated_at?: StringWithAggregatesFilter<"work_order_services"> | string
  }

  export type work_order_tasksWhereInput = {
    AND?: work_order_tasksWhereInput | work_order_tasksWhereInput[]
    OR?: work_order_tasksWhereInput[]
    NOT?: work_order_tasksWhereInput | work_order_tasksWhereInput[]
    id?: BigIntFilter<"work_order_tasks"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_tasks"> | bigint | number
    task_name?: StringFilter<"work_order_tasks"> | string
    task_description?: StringFilter<"work_order_tasks"> | string
    assigned_to?: BigIntFilter<"work_order_tasks"> | bigint | number
    status?: EnumWorkOrderTaskStatusFilter<"work_order_tasks"> | $Enums.WorkOrderTaskStatus
    due_date?: StringFilter<"work_order_tasks"> | string
    created_at?: StringFilter<"work_order_tasks"> | string
    updated_at?: StringFilter<"work_order_tasks"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
  }

  export type work_order_tasksOrderByWithRelationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    task_name?: SortOrder
    task_description?: SortOrder
    assigned_to?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    work_orders?: work_ordersOrderByWithRelationInput
  }

  export type work_order_tasksWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: work_order_tasksWhereInput | work_order_tasksWhereInput[]
    OR?: work_order_tasksWhereInput[]
    NOT?: work_order_tasksWhereInput | work_order_tasksWhereInput[]
    work_order_id?: BigIntFilter<"work_order_tasks"> | bigint | number
    task_name?: StringFilter<"work_order_tasks"> | string
    task_description?: StringFilter<"work_order_tasks"> | string
    assigned_to?: BigIntFilter<"work_order_tasks"> | bigint | number
    status?: EnumWorkOrderTaskStatusFilter<"work_order_tasks"> | $Enums.WorkOrderTaskStatus
    due_date?: StringFilter<"work_order_tasks"> | string
    created_at?: StringFilter<"work_order_tasks"> | string
    updated_at?: StringFilter<"work_order_tasks"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
  }, "id">

  export type work_order_tasksOrderByWithAggregationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    task_name?: SortOrder
    task_description?: SortOrder
    assigned_to?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: work_order_tasksCountOrderByAggregateInput
    _avg?: work_order_tasksAvgOrderByAggregateInput
    _max?: work_order_tasksMaxOrderByAggregateInput
    _min?: work_order_tasksMinOrderByAggregateInput
    _sum?: work_order_tasksSumOrderByAggregateInput
  }

  export type work_order_tasksScalarWhereWithAggregatesInput = {
    AND?: work_order_tasksScalarWhereWithAggregatesInput | work_order_tasksScalarWhereWithAggregatesInput[]
    OR?: work_order_tasksScalarWhereWithAggregatesInput[]
    NOT?: work_order_tasksScalarWhereWithAggregatesInput | work_order_tasksScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"work_order_tasks"> | bigint | number
    work_order_id?: BigIntWithAggregatesFilter<"work_order_tasks"> | bigint | number
    task_name?: StringWithAggregatesFilter<"work_order_tasks"> | string
    task_description?: StringWithAggregatesFilter<"work_order_tasks"> | string
    assigned_to?: BigIntWithAggregatesFilter<"work_order_tasks"> | bigint | number
    status?: EnumWorkOrderTaskStatusWithAggregatesFilter<"work_order_tasks"> | $Enums.WorkOrderTaskStatus
    due_date?: StringWithAggregatesFilter<"work_order_tasks"> | string
    created_at?: StringWithAggregatesFilter<"work_order_tasks"> | string
    updated_at?: StringWithAggregatesFilter<"work_order_tasks"> | string
  }

  export type work_order_assetsWhereInput = {
    AND?: work_order_assetsWhereInput | work_order_assetsWhereInput[]
    OR?: work_order_assetsWhereInput[]
    NOT?: work_order_assetsWhereInput | work_order_assetsWhereInput[]
    id?: BigIntFilter<"work_order_assets"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_assets"> | bigint | number
    asset_id?: BigIntFilter<"work_order_assets"> | bigint | number
    quantity?: IntFilter<"work_order_assets"> | number
    created_at?: StringFilter<"work_order_assets"> | string
    updated_at?: StringFilter<"work_order_assets"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
  }

  export type work_order_assetsOrderByWithRelationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    asset_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    work_orders?: work_ordersOrderByWithRelationInput
  }

  export type work_order_assetsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: work_order_assetsWhereInput | work_order_assetsWhereInput[]
    OR?: work_order_assetsWhereInput[]
    NOT?: work_order_assetsWhereInput | work_order_assetsWhereInput[]
    work_order_id?: BigIntFilter<"work_order_assets"> | bigint | number
    asset_id?: BigIntFilter<"work_order_assets"> | bigint | number
    quantity?: IntFilter<"work_order_assets"> | number
    created_at?: StringFilter<"work_order_assets"> | string
    updated_at?: StringFilter<"work_order_assets"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
  }, "id">

  export type work_order_assetsOrderByWithAggregationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    asset_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: work_order_assetsCountOrderByAggregateInput
    _avg?: work_order_assetsAvgOrderByAggregateInput
    _max?: work_order_assetsMaxOrderByAggregateInput
    _min?: work_order_assetsMinOrderByAggregateInput
    _sum?: work_order_assetsSumOrderByAggregateInput
  }

  export type work_order_assetsScalarWhereWithAggregatesInput = {
    AND?: work_order_assetsScalarWhereWithAggregatesInput | work_order_assetsScalarWhereWithAggregatesInput[]
    OR?: work_order_assetsScalarWhereWithAggregatesInput[]
    NOT?: work_order_assetsScalarWhereWithAggregatesInput | work_order_assetsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"work_order_assets"> | bigint | number
    work_order_id?: BigIntWithAggregatesFilter<"work_order_assets"> | bigint | number
    asset_id?: BigIntWithAggregatesFilter<"work_order_assets"> | bigint | number
    quantity?: IntWithAggregatesFilter<"work_order_assets"> | number
    created_at?: StringWithAggregatesFilter<"work_order_assets"> | string
    updated_at?: StringWithAggregatesFilter<"work_order_assets"> | string
  }

  export type work_order_crewWhereInput = {
    AND?: work_order_crewWhereInput | work_order_crewWhereInput[]
    OR?: work_order_crewWhereInput[]
    NOT?: work_order_crewWhereInput | work_order_crewWhereInput[]
    id?: BigIntFilter<"work_order_crew"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_crew"> | bigint | number
    crew_id?: BigIntFilter<"work_order_crew"> | bigint | number
    assigned_at?: StringFilter<"work_order_crew"> | string
    created_at?: StringFilter<"work_order_crew"> | string
    updated_at?: StringFilter<"work_order_crew"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
    crews?: XOR<CrewsScalarRelationFilter, crewsWhereInput>
  }

  export type work_order_crewOrderByWithRelationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    crew_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    work_orders?: work_ordersOrderByWithRelationInput
    crews?: crewsOrderByWithRelationInput
  }

  export type work_order_crewWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: work_order_crewWhereInput | work_order_crewWhereInput[]
    OR?: work_order_crewWhereInput[]
    NOT?: work_order_crewWhereInput | work_order_crewWhereInput[]
    work_order_id?: BigIntFilter<"work_order_crew"> | bigint | number
    crew_id?: BigIntFilter<"work_order_crew"> | bigint | number
    assigned_at?: StringFilter<"work_order_crew"> | string
    created_at?: StringFilter<"work_order_crew"> | string
    updated_at?: StringFilter<"work_order_crew"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
    crews?: XOR<CrewsScalarRelationFilter, crewsWhereInput>
  }, "id">

  export type work_order_crewOrderByWithAggregationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    crew_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: work_order_crewCountOrderByAggregateInput
    _avg?: work_order_crewAvgOrderByAggregateInput
    _max?: work_order_crewMaxOrderByAggregateInput
    _min?: work_order_crewMinOrderByAggregateInput
    _sum?: work_order_crewSumOrderByAggregateInput
  }

  export type work_order_crewScalarWhereWithAggregatesInput = {
    AND?: work_order_crewScalarWhereWithAggregatesInput | work_order_crewScalarWhereWithAggregatesInput[]
    OR?: work_order_crewScalarWhereWithAggregatesInput[]
    NOT?: work_order_crewScalarWhereWithAggregatesInput | work_order_crewScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"work_order_crew"> | bigint | number
    work_order_id?: BigIntWithAggregatesFilter<"work_order_crew"> | bigint | number
    crew_id?: BigIntWithAggregatesFilter<"work_order_crew"> | bigint | number
    assigned_at?: StringWithAggregatesFilter<"work_order_crew"> | string
    created_at?: StringWithAggregatesFilter<"work_order_crew"> | string
    updated_at?: StringWithAggregatesFilter<"work_order_crew"> | string
  }

  export type work_order_approvalsWhereInput = {
    AND?: work_order_approvalsWhereInput | work_order_approvalsWhereInput[]
    OR?: work_order_approvalsWhereInput[]
    NOT?: work_order_approvalsWhereInput | work_order_approvalsWhereInput[]
    id?: BigIntFilter<"work_order_approvals"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_approvals"> | bigint | number
    approved_by?: BigIntFilter<"work_order_approvals"> | bigint | number
    approval_status?: EnumApprovalStatusFilter<"work_order_approvals"> | $Enums.ApprovalStatus
    approved_at?: StringFilter<"work_order_approvals"> | string
    created_at?: StringFilter<"work_order_approvals"> | string
    updated_at?: StringFilter<"work_order_approvals"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
  }

  export type work_order_approvalsOrderByWithRelationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    approved_by?: SortOrder
    approval_status?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    work_orders?: work_ordersOrderByWithRelationInput
  }

  export type work_order_approvalsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: work_order_approvalsWhereInput | work_order_approvalsWhereInput[]
    OR?: work_order_approvalsWhereInput[]
    NOT?: work_order_approvalsWhereInput | work_order_approvalsWhereInput[]
    work_order_id?: BigIntFilter<"work_order_approvals"> | bigint | number
    approved_by?: BigIntFilter<"work_order_approvals"> | bigint | number
    approval_status?: EnumApprovalStatusFilter<"work_order_approvals"> | $Enums.ApprovalStatus
    approved_at?: StringFilter<"work_order_approvals"> | string
    created_at?: StringFilter<"work_order_approvals"> | string
    updated_at?: StringFilter<"work_order_approvals"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
  }, "id">

  export type work_order_approvalsOrderByWithAggregationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    approved_by?: SortOrder
    approval_status?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: work_order_approvalsCountOrderByAggregateInput
    _avg?: work_order_approvalsAvgOrderByAggregateInput
    _max?: work_order_approvalsMaxOrderByAggregateInput
    _min?: work_order_approvalsMinOrderByAggregateInput
    _sum?: work_order_approvalsSumOrderByAggregateInput
  }

  export type work_order_approvalsScalarWhereWithAggregatesInput = {
    AND?: work_order_approvalsScalarWhereWithAggregatesInput | work_order_approvalsScalarWhereWithAggregatesInput[]
    OR?: work_order_approvalsScalarWhereWithAggregatesInput[]
    NOT?: work_order_approvalsScalarWhereWithAggregatesInput | work_order_approvalsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"work_order_approvals"> | bigint | number
    work_order_id?: BigIntWithAggregatesFilter<"work_order_approvals"> | bigint | number
    approved_by?: BigIntWithAggregatesFilter<"work_order_approvals"> | bigint | number
    approval_status?: EnumApprovalStatusWithAggregatesFilter<"work_order_approvals"> | $Enums.ApprovalStatus
    approved_at?: StringWithAggregatesFilter<"work_order_approvals"> | string
    created_at?: StringWithAggregatesFilter<"work_order_approvals"> | string
    updated_at?: StringWithAggregatesFilter<"work_order_approvals"> | string
  }

  export type invoicesWhereInput = {
    AND?: invoicesWhereInput | invoicesWhereInput[]
    OR?: invoicesWhereInput[]
    NOT?: invoicesWhereInput | invoicesWhereInput[]
    id?: BigIntFilter<"invoices"> | bigint | number
    work_order_id?: BigIntFilter<"invoices"> | bigint | number
    invoice_number?: StringFilter<"invoices"> | string
    invoice_date?: StringFilter<"invoices"> | string
    due_date?: StringFilter<"invoices"> | string
    total_amount?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"invoices"> | $Enums.InvoiceStatus
    currency_id?: IntFilter<"invoices"> | number
    created_at?: StringFilter<"invoices"> | string
    updated_at?: StringFilter<"invoices"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
    invoice_items?: Invoice_itemsListRelationFilter
    payments?: PaymentsListRelationFilter
  }

  export type invoicesOrderByWithRelationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    invoice_number?: SortOrder
    invoice_date?: SortOrder
    due_date?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    currency_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    work_orders?: work_ordersOrderByWithRelationInput
    invoice_items?: invoice_itemsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
  }

  export type invoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: invoicesWhereInput | invoicesWhereInput[]
    OR?: invoicesWhereInput[]
    NOT?: invoicesWhereInput | invoicesWhereInput[]
    work_order_id?: BigIntFilter<"invoices"> | bigint | number
    invoice_number?: StringFilter<"invoices"> | string
    invoice_date?: StringFilter<"invoices"> | string
    due_date?: StringFilter<"invoices"> | string
    total_amount?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"invoices"> | $Enums.InvoiceStatus
    currency_id?: IntFilter<"invoices"> | number
    created_at?: StringFilter<"invoices"> | string
    updated_at?: StringFilter<"invoices"> | string
    work_orders?: XOR<Work_ordersScalarRelationFilter, work_ordersWhereInput>
    invoice_items?: Invoice_itemsListRelationFilter
    payments?: PaymentsListRelationFilter
  }, "id">

  export type invoicesOrderByWithAggregationInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    invoice_number?: SortOrder
    invoice_date?: SortOrder
    due_date?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    currency_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: invoicesCountOrderByAggregateInput
    _avg?: invoicesAvgOrderByAggregateInput
    _max?: invoicesMaxOrderByAggregateInput
    _min?: invoicesMinOrderByAggregateInput
    _sum?: invoicesSumOrderByAggregateInput
  }

  export type invoicesScalarWhereWithAggregatesInput = {
    AND?: invoicesScalarWhereWithAggregatesInput | invoicesScalarWhereWithAggregatesInput[]
    OR?: invoicesScalarWhereWithAggregatesInput[]
    NOT?: invoicesScalarWhereWithAggregatesInput | invoicesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"invoices"> | bigint | number
    work_order_id?: BigIntWithAggregatesFilter<"invoices"> | bigint | number
    invoice_number?: StringWithAggregatesFilter<"invoices"> | string
    invoice_date?: StringWithAggregatesFilter<"invoices"> | string
    due_date?: StringWithAggregatesFilter<"invoices"> | string
    total_amount?: DecimalWithAggregatesFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"invoices"> | $Enums.InvoiceStatus
    currency_id?: IntWithAggregatesFilter<"invoices"> | number
    created_at?: StringWithAggregatesFilter<"invoices"> | string
    updated_at?: StringWithAggregatesFilter<"invoices"> | string
  }

  export type invoice_itemsWhereInput = {
    AND?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    OR?: invoice_itemsWhereInput[]
    NOT?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    id?: BigIntFilter<"invoice_items"> | bigint | number
    invoice_id?: BigIntFilter<"invoice_items"> | bigint | number
    service_id?: BigIntFilter<"invoice_items"> | bigint | number
    part_id?: BigIntFilter<"invoice_items"> | bigint | number
    quantity?: IntFilter<"invoice_items"> | number
    unit_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"invoice_items"> | string
    created_at?: StringFilter<"invoice_items"> | string
    updated_at?: StringFilter<"invoice_items"> | string
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    services?: XOR<ServicesScalarRelationFilter, servicesWhereInput>
    parts?: XOR<PartsScalarRelationFilter, partsWhereInput>
  }

  export type invoice_itemsOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    part_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoices?: invoicesOrderByWithRelationInput
    services?: servicesOrderByWithRelationInput
    parts?: partsOrderByWithRelationInput
  }

  export type invoice_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    OR?: invoice_itemsWhereInput[]
    NOT?: invoice_itemsWhereInput | invoice_itemsWhereInput[]
    invoice_id?: BigIntFilter<"invoice_items"> | bigint | number
    service_id?: BigIntFilter<"invoice_items"> | bigint | number
    part_id?: BigIntFilter<"invoice_items"> | bigint | number
    quantity?: IntFilter<"invoice_items"> | number
    unit_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"invoice_items"> | string
    created_at?: StringFilter<"invoice_items"> | string
    updated_at?: StringFilter<"invoice_items"> | string
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    services?: XOR<ServicesScalarRelationFilter, servicesWhereInput>
    parts?: XOR<PartsScalarRelationFilter, partsWhereInput>
  }, "id">

  export type invoice_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    part_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: invoice_itemsCountOrderByAggregateInput
    _avg?: invoice_itemsAvgOrderByAggregateInput
    _max?: invoice_itemsMaxOrderByAggregateInput
    _min?: invoice_itemsMinOrderByAggregateInput
    _sum?: invoice_itemsSumOrderByAggregateInput
  }

  export type invoice_itemsScalarWhereWithAggregatesInput = {
    AND?: invoice_itemsScalarWhereWithAggregatesInput | invoice_itemsScalarWhereWithAggregatesInput[]
    OR?: invoice_itemsScalarWhereWithAggregatesInput[]
    NOT?: invoice_itemsScalarWhereWithAggregatesInput | invoice_itemsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"invoice_items"> | bigint | number
    invoice_id?: BigIntWithAggregatesFilter<"invoice_items"> | bigint | number
    service_id?: BigIntWithAggregatesFilter<"invoice_items"> | bigint | number
    part_id?: BigIntWithAggregatesFilter<"invoice_items"> | bigint | number
    quantity?: IntWithAggregatesFilter<"invoice_items"> | number
    unit_price?: DecimalWithAggregatesFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalWithAggregatesFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"invoice_items"> | string
    created_at?: StringWithAggregatesFilter<"invoice_items"> | string
    updated_at?: StringWithAggregatesFilter<"invoice_items"> | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: BigIntFilter<"payments"> | bigint | number
    invoice_id?: BigIntFilter<"payments"> | bigint | number
    payment_date?: StringFilter<"payments"> | string
    payment_amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    transaction_id?: StringFilter<"payments"> | string
    created_at?: StringFilter<"payments"> | string
    updated_at?: StringFilter<"payments"> | string
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    payment_date?: SortOrder
    payment_amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoices?: invoicesOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    invoice_id?: BigIntFilter<"payments"> | bigint | number
    payment_date?: StringFilter<"payments"> | string
    payment_amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    transaction_id?: StringFilter<"payments"> | string
    created_at?: StringFilter<"payments"> | string
    updated_at?: StringFilter<"payments"> | string
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    payment_date?: SortOrder
    payment_amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"payments"> | bigint | number
    invoice_id?: BigIntWithAggregatesFilter<"payments"> | bigint | number
    payment_date?: StringWithAggregatesFilter<"payments"> | string
    payment_amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusWithAggregatesFilter<"payments"> | $Enums.PaymentStatus
    transaction_id?: StringWithAggregatesFilter<"payments"> | string
    created_at?: StringWithAggregatesFilter<"payments"> | string
    updated_at?: StringWithAggregatesFilter<"payments"> | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: BigIntFilter<"notifications"> | bigint | number
    user_id?: BigIntFilter<"notifications"> | bigint | number
    notification_type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    message?: StringFilter<"notifications"> | string
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    created_at?: StringFilter<"notifications"> | string
    updated_at?: StringFilter<"notifications"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    user_id?: BigIntFilter<"notifications"> | bigint | number
    notification_type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    message?: StringFilter<"notifications"> | string
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    created_at?: StringFilter<"notifications"> | string
    updated_at?: StringFilter<"notifications"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"notifications"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"notifications"> | bigint | number
    notification_type?: EnumNotificationTypeWithAggregatesFilter<"notifications"> | $Enums.NotificationType
    message?: StringWithAggregatesFilter<"notifications"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"notifications"> | $Enums.NotificationStatus
    created_at?: StringWithAggregatesFilter<"notifications"> | string
    updated_at?: StringWithAggregatesFilter<"notifications"> | string
  }

  export type email_templatesWhereInput = {
    AND?: email_templatesWhereInput | email_templatesWhereInput[]
    OR?: email_templatesWhereInput[]
    NOT?: email_templatesWhereInput | email_templatesWhereInput[]
    id?: BigIntFilter<"email_templates"> | bigint | number
    name?: StringFilter<"email_templates"> | string
    subject?: StringFilter<"email_templates"> | string
    body?: StringFilter<"email_templates"> | string
    created_at?: StringFilter<"email_templates"> | string
    updated_at?: StringFilter<"email_templates"> | string
  }

  export type email_templatesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type email_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: email_templatesWhereInput | email_templatesWhereInput[]
    OR?: email_templatesWhereInput[]
    NOT?: email_templatesWhereInput | email_templatesWhereInput[]
    name?: StringFilter<"email_templates"> | string
    subject?: StringFilter<"email_templates"> | string
    body?: StringFilter<"email_templates"> | string
    created_at?: StringFilter<"email_templates"> | string
    updated_at?: StringFilter<"email_templates"> | string
  }, "id">

  export type email_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: email_templatesCountOrderByAggregateInput
    _avg?: email_templatesAvgOrderByAggregateInput
    _max?: email_templatesMaxOrderByAggregateInput
    _min?: email_templatesMinOrderByAggregateInput
    _sum?: email_templatesSumOrderByAggregateInput
  }

  export type email_templatesScalarWhereWithAggregatesInput = {
    AND?: email_templatesScalarWhereWithAggregatesInput | email_templatesScalarWhereWithAggregatesInput[]
    OR?: email_templatesScalarWhereWithAggregatesInput[]
    NOT?: email_templatesScalarWhereWithAggregatesInput | email_templatesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"email_templates"> | bigint | number
    name?: StringWithAggregatesFilter<"email_templates"> | string
    subject?: StringWithAggregatesFilter<"email_templates"> | string
    body?: StringWithAggregatesFilter<"email_templates"> | string
    created_at?: StringWithAggregatesFilter<"email_templates"> | string
    updated_at?: StringWithAggregatesFilter<"email_templates"> | string
  }

  export type audit_logsWhereInput = {
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    id?: BigIntFilter<"audit_logs"> | bigint | number
    user_id?: BigIntFilter<"audit_logs"> | bigint | number
    action?: StringFilter<"audit_logs"> | string
    entity_type?: EnumLogTypeFilter<"audit_logs"> | $Enums.LogType
    entity_id?: BigIntFilter<"audit_logs"> | bigint | number
    changes?: StringFilter<"audit_logs"> | string
    created_at?: StringFilter<"audit_logs"> | string
    updated_at?: StringFilter<"audit_logs"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    user_id?: BigIntFilter<"audit_logs"> | bigint | number
    action?: StringFilter<"audit_logs"> | string
    entity_type?: EnumLogTypeFilter<"audit_logs"> | $Enums.LogType
    entity_id?: BigIntFilter<"audit_logs"> | bigint | number
    changes?: StringFilter<"audit_logs"> | string
    created_at?: StringFilter<"audit_logs"> | string
    updated_at?: StringFilter<"audit_logs"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: audit_logsCountOrderByAggregateInput
    _avg?: audit_logsAvgOrderByAggregateInput
    _max?: audit_logsMaxOrderByAggregateInput
    _min?: audit_logsMinOrderByAggregateInput
    _sum?: audit_logsSumOrderByAggregateInput
  }

  export type audit_logsScalarWhereWithAggregatesInput = {
    AND?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    OR?: audit_logsScalarWhereWithAggregatesInput[]
    NOT?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"audit_logs"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"audit_logs"> | bigint | number
    action?: StringWithAggregatesFilter<"audit_logs"> | string
    entity_type?: EnumLogTypeWithAggregatesFilter<"audit_logs"> | $Enums.LogType
    entity_id?: BigIntWithAggregatesFilter<"audit_logs"> | bigint | number
    changes?: StringWithAggregatesFilter<"audit_logs"> | string
    created_at?: StringWithAggregatesFilter<"audit_logs"> | string
    updated_at?: StringWithAggregatesFilter<"audit_logs"> | string
  }

  export type tokensWhereInput = {
    AND?: tokensWhereInput | tokensWhereInput[]
    OR?: tokensWhereInput[]
    NOT?: tokensWhereInput | tokensWhereInput[]
    id?: IntFilter<"tokens"> | number
    user_id?: IntFilter<"tokens"> | number
    token?: StringFilter<"tokens"> | string
    type?: StringFilter<"tokens"> | string
    expires?: DateTimeFilter<"tokens"> | Date | string
    blacklisted?: BoolFilter<"tokens"> | boolean
    createdAt?: DateTimeFilter<"tokens"> | Date | string
    updatedAt?: DateTimeFilter<"tokens"> | Date | string
  }

  export type tokensOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: tokensWhereInput | tokensWhereInput[]
    OR?: tokensWhereInput[]
    NOT?: tokensWhereInput | tokensWhereInput[]
    user_id?: IntFilter<"tokens"> | number
    type?: StringFilter<"tokens"> | string
    expires?: DateTimeFilter<"tokens"> | Date | string
    blacklisted?: BoolFilter<"tokens"> | boolean
    createdAt?: DateTimeFilter<"tokens"> | Date | string
    updatedAt?: DateTimeFilter<"tokens"> | Date | string
  }, "id" | "token">

  export type tokensOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tokensCountOrderByAggregateInput
    _avg?: tokensAvgOrderByAggregateInput
    _max?: tokensMaxOrderByAggregateInput
    _min?: tokensMinOrderByAggregateInput
    _sum?: tokensSumOrderByAggregateInput
  }

  export type tokensScalarWhereWithAggregatesInput = {
    AND?: tokensScalarWhereWithAggregatesInput | tokensScalarWhereWithAggregatesInput[]
    OR?: tokensScalarWhereWithAggregatesInput[]
    NOT?: tokensScalarWhereWithAggregatesInput | tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tokens"> | number
    user_id?: IntWithAggregatesFilter<"tokens"> | number
    token?: StringWithAggregatesFilter<"tokens"> | string
    type?: StringWithAggregatesFilter<"tokens"> | string
    expires?: DateTimeWithAggregatesFilter<"tokens"> | Date | string
    blacklisted?: BoolWithAggregatesFilter<"tokens"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tokens"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tokens"> | Date | string
  }

  export type organizationsCreateInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsCreateManyInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
  }

  export type organizationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type organizationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type usersCreateInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    organizations: organizationsCreateNestedOneWithoutUsersInput
    user_skills?: user_skillsCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsCreateNestedManyWithoutUsersInput
    crews?: crewsCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsUncheckedCreateNestedManyWithoutUsersInput
    crews?: crewsUncheckedCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    user_skills?: user_skillsUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUpdateManyWithoutUsersNestedInput
    crews?: crewsUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput
    crews?: crewsUncheckedUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
  }

  export type usersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_roleCreateInput = {
    id?: bigint | number
    name: string
    access_rights: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
  }

  export type user_roleUncheckedCreateInput = {
    id?: bigint | number
    name: string
    access_rights: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
  }

  export type user_roleUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    access_rights?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_roleUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    access_rights?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_roleCreateManyInput = {
    id?: bigint | number
    name: string
    access_rights: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
  }

  export type user_roleUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    access_rights?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_roleUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    access_rights?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type currenciesCreateInput = {
    id?: bigint | number
    code: string
    name: string
    exchange_rate: Decimal | DecimalJsLike | number | string
    is_default: boolean
    created_at: string
    updated_at: string
  }

  export type currenciesUncheckedCreateInput = {
    id?: bigint | number
    code: string
    name: string
    exchange_rate: Decimal | DecimalJsLike | number | string
    is_default: boolean
    created_at: string
    updated_at: string
  }

  export type currenciesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type currenciesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type currenciesCreateManyInput = {
    id?: bigint | number
    code: string
    name: string
    exchange_rate: Decimal | DecimalJsLike | number | string
    is_default: boolean
    created_at: string
    updated_at: string
  }

  export type currenciesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type currenciesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    exchange_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_role_assignmentsCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    profile_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type user_role_assignmentsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    profile_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type user_role_assignmentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    profile_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_role_assignmentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    profile_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_role_assignmentsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    profile_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type user_role_assignmentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    profile_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_role_assignmentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    profile_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type skillsCreateInput = {
    id?: bigint | number
    name: string
    description: string
    created_at: string
    updated_at: string
    user_skills?: user_skillsCreateNestedManyWithoutSkillsInput
  }

  export type skillsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    description: string
    created_at: string
    updated_at: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type skillsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUpdateManyWithoutSkillsNestedInput
  }

  export type skillsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type skillsCreateManyInput = {
    id?: bigint | number
    name: string
    description: string
    created_at: string
    updated_at: string
  }

  export type skillsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type skillsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_skillsCreateInput = {
    id?: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutUser_skillsInput
    skills: skillsCreateNestedOneWithoutUser_skillsInput
    organizations: organizationsCreateNestedOneWithoutUser_skillsInput
  }

  export type user_skillsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    skill_id: bigint | number
    organization_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_skillsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_skillsNestedInput
    skills?: skillsUpdateOneRequiredWithoutUser_skillsNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUser_skillsNestedInput
  }

  export type user_skillsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_skillsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    skill_id: bigint | number
    organization_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_skillsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_skillsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type business_hoursCreateInput = {
    id?: bigint | number
    day_of_week?: $Enums.DayOfWeek
    start_time: string
    end_time: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutBusiness_hoursInput
  }

  export type business_hoursUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    day_of_week?: $Enums.DayOfWeek
    start_time: string
    end_time: string
    created_at: string
    updated_at: string
  }

  export type business_hoursUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    day_of_week?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutBusiness_hoursNestedInput
  }

  export type business_hoursUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    day_of_week?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type business_hoursCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    day_of_week?: $Enums.DayOfWeek
    start_time: string
    end_time: string
    created_at: string
    updated_at: string
  }

  export type business_hoursUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    day_of_week?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type business_hoursUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    day_of_week?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type holidaysCreateInput = {
    id?: bigint | number
    name: string
    holiday_date: string
    is_recurring?: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutHolidaysInput
  }

  export type holidaysUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    holiday_date: string
    is_recurring?: number
    created_at: string
    updated_at: string
  }

  export type holidaysUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    holiday_date?: StringFieldUpdateOperationsInput | string
    is_recurring?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutHolidaysNestedInput
  }

  export type holidaysUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    holiday_date?: StringFieldUpdateOperationsInput | string
    is_recurring?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type holidaysCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    holiday_date: string
    is_recurring?: number
    created_at: string
    updated_at: string
  }

  export type holidaysUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    holiday_date?: StringFieldUpdateOperationsInput | string
    is_recurring?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type holidaysUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    holiday_date?: StringFieldUpdateOperationsInput | string
    is_recurring?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type time_off_requestsCreateInput = {
    id?: bigint | number
    start_date: string
    end_date: string
    reason: string
    status?: $Enums.RequestStatus
    created_at: string
    updated_at: string
    users: usersCreateNestedOneWithoutTime_off_requestsInput
  }

  export type time_off_requestsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    start_date: string
    end_date: string
    reason: string
    status?: $Enums.RequestStatus
    created_at: string
    updated_at: string
  }

  export type time_off_requestsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutTime_off_requestsNestedInput
  }

  export type time_off_requestsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type time_off_requestsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    start_date: string
    end_date: string
    reason: string
    status?: $Enums.RequestStatus
    created_at: string
    updated_at: string
  }

  export type time_off_requestsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type time_off_requestsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crewsCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    created_at: string
    updated_at: string
    users: usersCreateNestedOneWithoutCrewsInput
    crew_members?: crew_membersCreateNestedManyWithoutCrewsInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutCrewsInput
  }

  export type crewsUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    leader_id: bigint | number
    created_at: string
    updated_at: string
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutCrewsInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type crewsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutCrewsNestedInput
    crew_members?: crew_membersUpdateManyWithoutCrewsNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutCrewsNestedInput
  }

  export type crewsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    crew_members?: crew_membersUncheckedUpdateManyWithoutCrewsNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type crewsCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    leader_id: bigint | number
    created_at: string
    updated_at: string
  }

  export type crewsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crewsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersCreateInput = {
    id?: bigint | number
    role: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCrew_membersInput
    crews: crewsCreateNestedOneWithoutCrew_membersInput
    users: usersCreateNestedOneWithoutCrew_membersInput
  }

  export type crew_membersUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    crew_id: bigint | number
    user_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type crew_membersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCrew_membersNestedInput
    crews?: crewsUpdateOneRequiredWithoutCrew_membersNestedInput
    users?: usersUpdateOneRequiredWithoutCrew_membersNestedInput
  }

  export type crew_membersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    crew_id: bigint | number
    user_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type crew_membersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type equipmentsCreateInput = {
    id?: bigint | number
    name: string
    equipment_type: string
    status: $Enums.EqupmentStatus
    location: string
    availability_date: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutEquipmentsInput
  }

  export type equipmentsUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    equipment_type: string
    status: $Enums.EqupmentStatus
    location: string
    availability_date: string
    created_at: string
    updated_at: string
  }

  export type equipmentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    status?: EnumEqupmentStatusFieldUpdateOperationsInput | $Enums.EqupmentStatus
    location?: StringFieldUpdateOperationsInput | string
    availability_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutEquipmentsNestedInput
  }

  export type equipmentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    status?: EnumEqupmentStatusFieldUpdateOperationsInput | $Enums.EqupmentStatus
    location?: StringFieldUpdateOperationsInput | string
    availability_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type equipmentsCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    equipment_type: string
    status: $Enums.EqupmentStatus
    location: string
    availability_date: string
    created_at: string
    updated_at: string
  }

  export type equipmentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    status?: EnumEqupmentStatusFieldUpdateOperationsInput | $Enums.EqupmentStatus
    location?: StringFieldUpdateOperationsInput | string
    availability_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type equipmentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    status?: EnumEqupmentStatusFieldUpdateOperationsInput | $Enums.EqupmentStatus
    location?: StringFieldUpdateOperationsInput | string
    availability_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type companiesCreateInput = {
    id?: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCompaniesInput
    customers?: customersCreateNestedManyWithoutCompaniesInput
    work_orders?: work_ordersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    customers?: customersUncheckedCreateNestedManyWithoutCompaniesInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCompaniesNestedInput
    customers?: customersUpdateManyWithoutCompaniesNestedInput
    work_orders?: work_ordersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    customers?: customersUncheckedUpdateManyWithoutCompaniesNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
  }

  export type companiesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type customersCreateInput = {
    id?: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCustomersInput
    companies: companiesCreateNestedOneWithoutCustomersInput
    assets?: assetsCreateNestedManyWithoutCustomersInput
    work_orders?: work_ordersCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    company_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    assets?: assetsUncheckedCreateNestedManyWithoutCustomersInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCustomersNestedInput
    companies?: companiesUpdateOneRequiredWithoutCustomersNestedInput
    assets?: assetsUpdateManyWithoutCustomersNestedInput
    work_orders?: work_ordersUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    assets?: assetsUncheckedUpdateManyWithoutCustomersNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    company_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
  }

  export type customersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type customersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type servicesCreateInput = {
    id?: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutServicesInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutServicesInput
    invoice_items?: invoice_itemsCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutServicesInput
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutServicesNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutServicesNestedInput
    invoice_items?: invoice_itemsUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutServicesNestedInput
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
  }

  export type servicesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type servicesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type assetsCreateInput = {
    id?: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutAssetsInput
    customers: customersCreateNestedOneWithoutAssetsInput
    work_orders?: work_ordersCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutAssetsNestedInput
    customers?: customersUpdateOneRequiredWithoutAssetsNestedInput
    work_orders?: work_ordersUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type assetsCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
  }

  export type assetsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type assetsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type partsCreateInput = {
    id?: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutPartsInput
    invoice_items?: invoice_itemsCreateNestedManyWithoutPartsInput
  }

  export type partsUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutPartsInput
  }

  export type partsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutPartsNestedInput
    invoice_items?: invoice_itemsUpdateManyWithoutPartsNestedInput
  }

  export type partsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutPartsNestedInput
  }

  export type partsCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
  }

  export type partsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type partsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plansCreateInput = {
    id?: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutMaintenance_plansInput
    maintenance_plan_assets?: maintenance_plan_assetsCreateNestedManyWithoutMaintenance_plansInput
    work_orders?: work_ordersCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    maintenance_plan_assets?: maintenance_plan_assetsUncheckedCreateNestedManyWithoutMaintenance_plansInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutMaintenance_plansNestedInput
    maintenance_plan_assets?: maintenance_plan_assetsUpdateManyWithoutMaintenance_plansNestedInput
    work_orders?: work_ordersUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type maintenance_plansUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    maintenance_plan_assets?: maintenance_plan_assetsUncheckedUpdateManyWithoutMaintenance_plansNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type maintenance_plansCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
  }

  export type maintenance_plansUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plansUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plan_assetsCreateInput = {
    id?: bigint | number
    asset_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
    maintenance_plans: maintenance_plansCreateNestedOneWithoutMaintenance_plan_assetsInput
  }

  export type maintenance_plan_assetsUncheckedCreateInput = {
    id?: bigint | number
    maintenance_plan_id: bigint | number
    asset_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type maintenance_plan_assetsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutMaintenance_plan_assetsNestedInput
  }

  export type maintenance_plan_assetsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plan_assetsCreateManyInput = {
    id?: bigint | number
    maintenance_plan_id: bigint | number
    asset_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type maintenance_plan_assetsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plan_assetsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_ordersCreateInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersCreateManyInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
  }

  export type work_ordersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_ordersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_servicesCreateInput = {
    id?: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutWork_order_servicesInput
    services: servicesCreateNestedOneWithoutWork_order_servicesInput
  }

  export type work_order_servicesUncheckedCreateInput = {
    id?: bigint | number
    work_order_id: bigint | number
    service_id: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
  }

  export type work_order_servicesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutWork_order_servicesNestedInput
    services?: servicesUpdateOneRequiredWithoutWork_order_servicesNestedInput
  }

  export type work_order_servicesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_servicesCreateManyInput = {
    id?: bigint | number
    work_order_id: bigint | number
    service_id: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
  }

  export type work_order_servicesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_servicesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_tasksCreateInput = {
    id?: bigint | number
    task_name: string
    task_description: string
    assigned_to: bigint | number
    status?: $Enums.WorkOrderTaskStatus
    due_date: string
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutWork_order_tasksInput
  }

  export type work_order_tasksUncheckedCreateInput = {
    id?: bigint | number
    work_order_id: bigint | number
    task_name: string
    task_description: string
    assigned_to: bigint | number
    status?: $Enums.WorkOrderTaskStatus
    due_date: string
    created_at: string
    updated_at: string
  }

  export type work_order_tasksUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_name?: StringFieldUpdateOperationsInput | string
    task_description?: StringFieldUpdateOperationsInput | string
    assigned_to?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWorkOrderTaskStatusFieldUpdateOperationsInput | $Enums.WorkOrderTaskStatus
    due_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutWork_order_tasksNestedInput
  }

  export type work_order_tasksUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_name?: StringFieldUpdateOperationsInput | string
    task_description?: StringFieldUpdateOperationsInput | string
    assigned_to?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWorkOrderTaskStatusFieldUpdateOperationsInput | $Enums.WorkOrderTaskStatus
    due_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_tasksCreateManyInput = {
    id?: bigint | number
    work_order_id: bigint | number
    task_name: string
    task_description: string
    assigned_to: bigint | number
    status?: $Enums.WorkOrderTaskStatus
    due_date: string
    created_at: string
    updated_at: string
  }

  export type work_order_tasksUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_name?: StringFieldUpdateOperationsInput | string
    task_description?: StringFieldUpdateOperationsInput | string
    assigned_to?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWorkOrderTaskStatusFieldUpdateOperationsInput | $Enums.WorkOrderTaskStatus
    due_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_tasksUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_name?: StringFieldUpdateOperationsInput | string
    task_description?: StringFieldUpdateOperationsInput | string
    assigned_to?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWorkOrderTaskStatusFieldUpdateOperationsInput | $Enums.WorkOrderTaskStatus
    due_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_assetsCreateInput = {
    id?: bigint | number
    asset_id: bigint | number
    quantity: number
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutWork_order_assetsInput
  }

  export type work_order_assetsUncheckedCreateInput = {
    id?: bigint | number
    work_order_id: bigint | number
    asset_id: bigint | number
    quantity: number
    created_at: string
    updated_at: string
  }

  export type work_order_assetsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutWork_order_assetsNestedInput
  }

  export type work_order_assetsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_assetsCreateManyInput = {
    id?: bigint | number
    work_order_id: bigint | number
    asset_id: bigint | number
    quantity: number
    created_at: string
    updated_at: string
  }

  export type work_order_assetsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_assetsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_crewCreateInput = {
    id?: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutWork_order_crewInput
    crews: crewsCreateNestedOneWithoutWork_order_crewInput
  }

  export type work_order_crewUncheckedCreateInput = {
    id?: bigint | number
    work_order_id: bigint | number
    crew_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_crewUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutWork_order_crewNestedInput
    crews?: crewsUpdateOneRequiredWithoutWork_order_crewNestedInput
  }

  export type work_order_crewUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_crewCreateManyInput = {
    id?: bigint | number
    work_order_id: bigint | number
    crew_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_crewUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_crewUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_approvalsCreateInput = {
    id?: bigint | number
    approved_by: bigint | number
    approval_status: $Enums.ApprovalStatus
    approved_at: string
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutWork_order_approvalsInput
  }

  export type work_order_approvalsUncheckedCreateInput = {
    id?: bigint | number
    work_order_id: bigint | number
    approved_by: bigint | number
    approval_status: $Enums.ApprovalStatus
    approved_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_approvalsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    approved_by?: BigIntFieldUpdateOperationsInput | bigint | number
    approval_status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approved_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutWork_order_approvalsNestedInput
  }

  export type work_order_approvalsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    approved_by?: BigIntFieldUpdateOperationsInput | bigint | number
    approval_status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approved_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_approvalsCreateManyInput = {
    id?: bigint | number
    work_order_id: bigint | number
    approved_by: bigint | number
    approval_status: $Enums.ApprovalStatus
    approved_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_approvalsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    approved_by?: BigIntFieldUpdateOperationsInput | bigint | number
    approval_status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approved_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_approvalsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    approved_by?: BigIntFieldUpdateOperationsInput | bigint | number
    approval_status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approved_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesCreateInput = {
    id?: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutInvoicesInput
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateInput = {
    id?: bigint | number
    work_order_id: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutInvoicesNestedInput
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesCreateManyInput = {
    id?: bigint | number
    work_order_id: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
  }

  export type invoicesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsCreateInput = {
    id?: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
    invoices: invoicesCreateNestedOneWithoutInvoice_itemsInput
    services: servicesCreateNestedOneWithoutInvoice_itemsInput
    parts: partsCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateInput = {
    id?: bigint | number
    invoice_id: bigint | number
    service_id: bigint | number
    part_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    services?: servicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    parts?: partsUpdateOneRequiredWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    part_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsCreateManyInput = {
    id?: bigint | number
    invoice_id: bigint | number
    service_id: bigint | number
    part_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    part_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsCreateInput = {
    id?: bigint | number
    payment_date: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_method: $Enums.PaymentMethod
    payment_status: $Enums.PaymentStatus
    transaction_id: string
    created_at: string
    updated_at: string
    invoices: invoicesCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: bigint | number
    invoice_id: bigint | number
    payment_date: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_method: $Enums.PaymentMethod
    payment_status: $Enums.PaymentStatus
    transaction_id: string
    created_at: string
    updated_at: string
  }

  export type paymentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_date?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoices?: invoicesUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_date?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsCreateManyInput = {
    id?: bigint | number
    invoice_id: bigint | number
    payment_date: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_method: $Enums.PaymentMethod
    payment_status: $Enums.PaymentStatus
    transaction_id: string
    created_at: string
    updated_at: string
  }

  export type paymentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_date?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_date?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsCreateInput = {
    id?: bigint | number
    notification_type: $Enums.NotificationType
    message: string
    status: $Enums.NotificationStatus
    created_at: string
    updated_at: string
    users: usersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    notification_type: $Enums.NotificationType
    message: string
    status: $Enums.NotificationStatus
    created_at: string
    updated_at: string
  }

  export type notificationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification_type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification_type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    notification_type: $Enums.NotificationType
    message: string
    status: $Enums.NotificationStatus
    created_at: string
    updated_at: string
  }

  export type notificationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification_type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification_type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type email_templatesCreateInput = {
    id?: bigint | number
    name: string
    subject: string
    body: string
    created_at: string
    updated_at: string
  }

  export type email_templatesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    subject: string
    body: string
    created_at: string
    updated_at: string
  }

  export type email_templatesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type email_templatesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type email_templatesCreateManyInput = {
    id?: bigint | number
    name: string
    subject: string
    body: string
    created_at: string
    updated_at: string
  }

  export type email_templatesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type email_templatesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type audit_logsCreateInput = {
    id?: bigint | number
    action: string
    entity_type: $Enums.LogType
    entity_id: bigint | number
    changes: string
    created_at: string
    updated_at: string
    users: usersCreateNestedOneWithoutAudit_logsInput
  }

  export type audit_logsUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    action: string
    entity_type: $Enums.LogType
    entity_id: bigint | number
    changes: string
    created_at: string
    updated_at: string
  }

  export type audit_logsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    entity_type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    entity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutAudit_logsNestedInput
  }

  export type audit_logsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    entity_type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    entity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type audit_logsCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    action: string
    entity_type: $Enums.LogType
    entity_id: bigint | number
    changes: string
    created_at: string
    updated_at: string
  }

  export type audit_logsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    entity_type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    entity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type audit_logsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    entity_type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    entity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type tokensCreateInput = {
    user_id: number
    token: string
    type: string
    expires: Date | string
    blacklisted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tokensUncheckedCreateInput = {
    id?: number
    user_id: number
    token: string
    type: string
    expires: Date | string
    blacklisted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tokensUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensCreateManyInput = {
    id?: number
    user_id: number
    token: string
    type: string
    expires: Date | string
    blacklisted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tokensUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type User_skillsListRelationFilter = {
    every?: user_skillsWhereInput
    some?: user_skillsWhereInput
    none?: user_skillsWhereInput
  }

  export type Business_hoursListRelationFilter = {
    every?: business_hoursWhereInput
    some?: business_hoursWhereInput
    none?: business_hoursWhereInput
  }

  export type HolidaysListRelationFilter = {
    every?: holidaysWhereInput
    some?: holidaysWhereInput
    none?: holidaysWhereInput
  }

  export type Crew_membersListRelationFilter = {
    every?: crew_membersWhereInput
    some?: crew_membersWhereInput
    none?: crew_membersWhereInput
  }

  export type EquipmentsListRelationFilter = {
    every?: equipmentsWhereInput
    some?: equipmentsWhereInput
    none?: equipmentsWhereInput
  }

  export type CompaniesListRelationFilter = {
    every?: companiesWhereInput
    some?: companiesWhereInput
    none?: companiesWhereInput
  }

  export type CustomersListRelationFilter = {
    every?: customersWhereInput
    some?: customersWhereInput
    none?: customersWhereInput
  }

  export type ServicesListRelationFilter = {
    every?: servicesWhereInput
    some?: servicesWhereInput
    none?: servicesWhereInput
  }

  export type AssetsListRelationFilter = {
    every?: assetsWhereInput
    some?: assetsWhereInput
    none?: assetsWhereInput
  }

  export type PartsListRelationFilter = {
    every?: partsWhereInput
    some?: partsWhereInput
    none?: partsWhereInput
  }

  export type Maintenance_plansListRelationFilter = {
    every?: maintenance_plansWhereInput
    some?: maintenance_plansWhereInput
    none?: maintenance_plansWhereInput
  }

  export type Work_ordersListRelationFilter = {
    every?: work_ordersWhereInput
    some?: work_ordersWhereInput
    none?: work_ordersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_skillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type business_hoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type holidaysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type crew_membersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type equipmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type assetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type partsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type maintenance_plansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type work_ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    organization_name?: SortOrder
    industry_name?: SortOrder
    pincode?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    plan_type?: SortOrder
    subscription_start_date?: SortOrder
    subscription_end_date?: SortOrder
    file_storage_limit?: SortOrder
    data_storage_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currencyid?: SortOrder
  }

  export type organizationsAvgOrderByAggregateInput = {
    id?: SortOrder
    file_storage_limit?: SortOrder
    data_storage_limit?: SortOrder
    currencyid?: SortOrder
  }

  export type organizationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    organization_name?: SortOrder
    industry_name?: SortOrder
    pincode?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    plan_type?: SortOrder
    subscription_start_date?: SortOrder
    subscription_end_date?: SortOrder
    file_storage_limit?: SortOrder
    data_storage_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currencyid?: SortOrder
  }

  export type organizationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    organization_name?: SortOrder
    industry_name?: SortOrder
    pincode?: SortOrder
    website?: SortOrder
    timezone?: SortOrder
    plan_type?: SortOrder
    subscription_start_date?: SortOrder
    subscription_end_date?: SortOrder
    file_storage_limit?: SortOrder
    data_storage_limit?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currencyid?: SortOrder
  }

  export type organizationsSumOrderByAggregateInput = {
    id?: SortOrder
    file_storage_limit?: SortOrder
    data_storage_limit?: SortOrder
    currencyid?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OrganizationsScalarRelationFilter = {
    is?: organizationsWhereInput
    isNot?: organizationsWhereInput
  }

  export type Time_off_requestsListRelationFilter = {
    every?: time_off_requestsWhereInput
    some?: time_off_requestsWhereInput
    none?: time_off_requestsWhereInput
  }

  export type CrewsListRelationFilter = {
    every?: crewsWhereInput
    some?: crewsWhereInput
    none?: crewsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type Audit_logsListRelationFilter = {
    every?: audit_logsWhereInput
    some?: audit_logsWhereInput
    none?: audit_logsWhereInput
  }

  export type time_off_requestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type crewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type audit_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    isVerified_Email?: SortOrder
    isVerified_PhoneNumber?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    job_title?: SortOrder
    user_type?: SortOrder
    is_active?: SortOrder
    last_login_at?: SortOrder
    email_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    is_active?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    isVerified_Email?: SortOrder
    isVerified_PhoneNumber?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    job_title?: SortOrder
    user_type?: SortOrder
    is_active?: SortOrder
    last_login_at?: SortOrder
    email_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    isVerified_Email?: SortOrder
    isVerified_PhoneNumber?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    job_title?: SortOrder
    user_type?: SortOrder
    is_active?: SortOrder
    last_login_at?: SortOrder
    email_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    is_active?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type user_roleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    access_rights?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_roleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_roleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_roleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_roleSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type currenciesCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    exchange_rate?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currenciesAvgOrderByAggregateInput = {
    id?: SortOrder
    exchange_rate?: SortOrder
  }

  export type currenciesMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    exchange_rate?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currenciesMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    exchange_rate?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type currenciesSumOrderByAggregateInput = {
    id?: SortOrder
    exchange_rate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type user_role_assignmentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_role_assignmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
  }

  export type user_role_assignmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_role_assignmentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_role_assignmentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    profile_id?: SortOrder
  }

  export type skillsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type skillsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type skillsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type skillsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type skillsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumProficiencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ProficiencyLevel | EnumProficiencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyLevelFilter<$PrismaModel> | $Enums.ProficiencyLevel
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type SkillsScalarRelationFilter = {
    is?: skillsWhereInput
    isNot?: skillsWhereInput
  }

  export type user_skillsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_id?: SortOrder
    organization_id?: SortOrder
    proficiency_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_skillsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_id?: SortOrder
    organization_id?: SortOrder
  }

  export type user_skillsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_id?: SortOrder
    organization_id?: SortOrder
    proficiency_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_skillsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_id?: SortOrder
    organization_id?: SortOrder
    proficiency_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_skillsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    skill_id?: SortOrder
    organization_id?: SortOrder
  }

  export type EnumProficiencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProficiencyLevel | EnumProficiencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.ProficiencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProficiencyLevelFilter<$PrismaModel>
    _max?: NestedEnumProficiencyLevelFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type business_hoursCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type business_hoursAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type business_hoursMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type business_hoursMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type business_hoursSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type EnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type holidaysCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    holiday_date?: SortOrder
    is_recurring?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type holidaysAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    is_recurring?: SortOrder
  }

  export type holidaysMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    holiday_date?: SortOrder
    is_recurring?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type holidaysMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    holiday_date?: SortOrder
    is_recurring?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type holidaysSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    is_recurring?: SortOrder
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type time_off_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type time_off_requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type time_off_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type time_off_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type time_off_requestsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type Work_order_crewListRelationFilter = {
    every?: work_order_crewWhereInput
    some?: work_order_crewWhereInput
    none?: work_order_crewWhereInput
  }

  export type work_order_crewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type crewsCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    leader_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crewsAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    leader_id?: SortOrder
  }

  export type crewsMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    leader_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crewsMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    leader_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crewsSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    leader_id?: SortOrder
  }

  export type CrewsScalarRelationFilter = {
    is?: crewsWhereInput
    isNot?: crewsWhereInput
  }

  export type crew_membersCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    crew_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crew_membersAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    crew_id?: SortOrder
    user_id?: SortOrder
  }

  export type crew_membersMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    crew_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crew_membersMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    crew_id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type crew_membersSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    crew_id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumEqupmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EqupmentStatus | EnumEqupmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEqupmentStatusFilter<$PrismaModel> | $Enums.EqupmentStatus
  }

  export type equipmentsCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    equipment_type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    availability_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type equipmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type equipmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    equipment_type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    availability_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type equipmentsMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    equipment_type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    availability_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type equipmentsSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type EnumEqupmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EqupmentStatus | EnumEqupmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEqupmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EqupmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEqupmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEqupmentStatusFilter<$PrismaModel>
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    tax_id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    tax_id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    industry?: SortOrder
    tax_id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type customersCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    company_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type customersAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    company_id?: SortOrder
    is_active?: SortOrder
  }

  export type customersMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    company_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type customersMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    company_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type customersSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    company_id?: SortOrder
    is_active?: SortOrder
  }

  export type Work_order_servicesListRelationFilter = {
    every?: work_order_servicesWhereInput
    some?: work_order_servicesWhereInput
    none?: work_order_servicesWhereInput
  }

  export type Invoice_itemsListRelationFilter = {
    every?: invoice_itemsWhereInput
    some?: invoice_itemsWhereInput
    none?: invoice_itemsWhereInput
  }

  export type work_order_servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoice_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type servicesCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    required_skills?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type servicesAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
  }

  export type servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type servicesMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type servicesSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    duration?: SortOrder
    price?: SortOrder
  }

  export type EnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type CustomersScalarRelationFilter = {
    is?: customersWhereInput
    isNot?: customersWhereInput
  }

  export type assetsCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    asset_name?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    purchase_date?: SortOrder
    warranty_expiry?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type assetsAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
  }

  export type assetsMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    asset_name?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    purchase_date?: SortOrder
    warranty_expiry?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type assetsMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    asset_name?: SortOrder
    serial_number?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    purchase_date?: SortOrder
    warranty_expiry?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type assetsSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
  }

  export type EnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type partsCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    inventory_count?: SortOrder
    reorder_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type partsAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    price?: SortOrder
    inventory_count?: SortOrder
    reorder_level?: SortOrder
  }

  export type partsMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    inventory_count?: SortOrder
    reorder_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type partsMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    inventory_count?: SortOrder
    reorder_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type partsSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    price?: SortOrder
    inventory_count?: SortOrder
    reorder_level?: SortOrder
  }

  export type EnumFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyFilter<$PrismaModel> | $Enums.Frequency
  }

  export type EnumFrequencyUnitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyUnitType | EnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyUnitTypeFilter<$PrismaModel> | $Enums.FrequencyUnitType
  }

  export type Maintenance_plan_assetsListRelationFilter = {
    every?: maintenance_plan_assetsWhereInput
    some?: maintenance_plan_assetsWhereInput
    none?: maintenance_plan_assetsWhereInput
  }

  export type maintenance_plan_assetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type maintenance_plansCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    frequency?: SortOrder
    frequency_unit?: SortOrder
    frequency_unit_type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type maintenance_plansAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    frequency_unit?: SortOrder
    is_active?: SortOrder
  }

  export type maintenance_plansMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    frequency?: SortOrder
    frequency_unit?: SortOrder
    frequency_unit_type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type maintenance_plansMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    frequency?: SortOrder
    frequency_unit?: SortOrder
    frequency_unit_type?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type maintenance_plansSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    frequency_unit?: SortOrder
    is_active?: SortOrder
  }

  export type EnumFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.Frequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFrequencyFilter<$PrismaModel>
    _max?: NestedEnumFrequencyFilter<$PrismaModel>
  }

  export type EnumFrequencyUnitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyUnitType | EnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyUnitTypeWithAggregatesFilter<$PrismaModel> | $Enums.FrequencyUnitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFrequencyUnitTypeFilter<$PrismaModel>
    _max?: NestedEnumFrequencyUnitTypeFilter<$PrismaModel>
  }

  export type Maintenance_plansScalarRelationFilter = {
    is?: maintenance_plansWhereInput
    isNot?: maintenance_plansWhereInput
  }

  export type maintenance_plan_assetsCountOrderByAggregateInput = {
    id?: SortOrder
    maintenance_plan_id?: SortOrder
    asset_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type maintenance_plan_assetsAvgOrderByAggregateInput = {
    id?: SortOrder
    maintenance_plan_id?: SortOrder
    asset_id?: SortOrder
  }

  export type maintenance_plan_assetsMaxOrderByAggregateInput = {
    id?: SortOrder
    maintenance_plan_id?: SortOrder
    asset_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type maintenance_plan_assetsMinOrderByAggregateInput = {
    id?: SortOrder
    maintenance_plan_id?: SortOrder
    asset_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type maintenance_plan_assetsSumOrderByAggregateInput = {
    id?: SortOrder
    maintenance_plan_id?: SortOrder
    asset_id?: SortOrder
  }

  export type EnumPrioirtyFilter<$PrismaModel = never> = {
    equals?: $Enums.Prioirty | EnumPrioirtyFieldRefInput<$PrismaModel>
    in?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioirtyFilter<$PrismaModel> | $Enums.Prioirty
  }

  export type EnumWorkOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusFilter<$PrismaModel> | $Enums.WorkOrderStatus
  }

  export type AssetsScalarRelationFilter = {
    is?: assetsWhereInput
    isNot?: assetsWhereInput
  }

  export type Work_order_tasksListRelationFilter = {
    every?: work_order_tasksWhereInput
    some?: work_order_tasksWhereInput
    none?: work_order_tasksWhereInput
  }

  export type Work_order_assetsListRelationFilter = {
    every?: work_order_assetsWhereInput
    some?: work_order_assetsWhereInput
    none?: work_order_assetsWhereInput
  }

  export type Work_order_approvalsListRelationFilter = {
    every?: work_order_approvalsWhereInput
    some?: work_order_approvalsWhereInput
    none?: work_order_approvalsWhereInput
  }

  export type InvoicesListRelationFilter = {
    every?: invoicesWhereInput
    some?: invoicesWhereInput
    none?: invoicesWhereInput
  }

  export type work_order_tasksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type work_order_assetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type work_order_approvalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type work_ordersCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    asset_id?: SortOrder
    maintenance_plan_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    assigned_crew_id?: SortOrder
    scheduled_start_date?: SortOrder
    scheduled_end_date?: SortOrder
    actual_start_date?: SortOrder
    actual_end_date?: SortOrder
    currency_id?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_multi_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_ordersAvgOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    asset_id?: SortOrder
    maintenance_plan_id?: SortOrder
    assigned_crew_id?: SortOrder
    currency_id?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    is_multi_day?: SortOrder
  }

  export type work_ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    asset_id?: SortOrder
    maintenance_plan_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    assigned_crew_id?: SortOrder
    scheduled_start_date?: SortOrder
    scheduled_end_date?: SortOrder
    actual_start_date?: SortOrder
    actual_end_date?: SortOrder
    currency_id?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_multi_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_ordersMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    asset_id?: SortOrder
    maintenance_plan_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assigned_to?: SortOrder
    assigned_crew_id?: SortOrder
    scheduled_start_date?: SortOrder
    scheduled_end_date?: SortOrder
    actual_start_date?: SortOrder
    actual_end_date?: SortOrder
    currency_id?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_multi_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_ordersSumOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    customer_id?: SortOrder
    company_id?: SortOrder
    asset_id?: SortOrder
    maintenance_plan_id?: SortOrder
    assigned_crew_id?: SortOrder
    currency_id?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    is_multi_day?: SortOrder
  }

  export type EnumPrioirtyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Prioirty | EnumPrioirtyFieldRefInput<$PrismaModel>
    in?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioirtyWithAggregatesFilter<$PrismaModel> | $Enums.Prioirty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrioirtyFilter<$PrismaModel>
    _max?: NestedEnumPrioirtyFilter<$PrismaModel>
  }

  export type EnumWorkOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
  }

  export type Work_ordersScalarRelationFilter = {
    is?: work_ordersWhereInput
    isNot?: work_ordersWhereInput
  }

  export type ServicesScalarRelationFilter = {
    is?: servicesWhereInput
    isNot?: servicesWhereInput
  }

  export type work_order_servicesCountOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_servicesAvgOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    service_cost?: SortOrder
  }

  export type work_order_servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_servicesMinOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_servicesSumOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    service_id?: SortOrder
    quantity?: SortOrder
    service_cost?: SortOrder
  }

  export type EnumWorkOrderTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderTaskStatus | EnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderTaskStatusFilter<$PrismaModel> | $Enums.WorkOrderTaskStatus
  }

  export type work_order_tasksCountOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    task_name?: SortOrder
    task_description?: SortOrder
    assigned_to?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_tasksAvgOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    assigned_to?: SortOrder
  }

  export type work_order_tasksMaxOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    task_name?: SortOrder
    task_description?: SortOrder
    assigned_to?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_tasksMinOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    task_name?: SortOrder
    task_description?: SortOrder
    assigned_to?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_tasksSumOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    assigned_to?: SortOrder
  }

  export type EnumWorkOrderTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderTaskStatus | EnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderTaskStatusFilter<$PrismaModel>
  }

  export type work_order_assetsCountOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    asset_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_assetsAvgOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    asset_id?: SortOrder
    quantity?: SortOrder
  }

  export type work_order_assetsMaxOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    asset_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_assetsMinOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    asset_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_assetsSumOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    asset_id?: SortOrder
    quantity?: SortOrder
  }

  export type work_order_crewCountOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    crew_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_crewAvgOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    crew_id?: SortOrder
  }

  export type work_order_crewMaxOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    crew_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_crewMinOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    crew_id?: SortOrder
    assigned_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_crewSumOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    crew_id?: SortOrder
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type work_order_approvalsCountOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    approved_by?: SortOrder
    approval_status?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_approvalsAvgOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    approved_by?: SortOrder
  }

  export type work_order_approvalsMaxOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    approved_by?: SortOrder
    approval_status?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_approvalsMinOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    approved_by?: SortOrder
    approval_status?: SortOrder
    approved_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type work_order_approvalsSumOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    approved_by?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoicesCountOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    invoice_number?: SortOrder
    invoice_date?: SortOrder
    due_date?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    currency_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    total_amount?: SortOrder
    currency_id?: SortOrder
  }

  export type invoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    invoice_number?: SortOrder
    invoice_date?: SortOrder
    due_date?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    currency_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invoicesMinOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    invoice_number?: SortOrder
    invoice_date?: SortOrder
    due_date?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    currency_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invoicesSumOrderByAggregateInput = {
    id?: SortOrder
    work_order_id?: SortOrder
    total_amount?: SortOrder
    currency_id?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoicesScalarRelationFilter = {
    is?: invoicesWhereInput
    isNot?: invoicesWhereInput
  }

  export type PartsScalarRelationFilter = {
    is?: partsWhereInput
    isNot?: partsWhereInput
  }

  export type invoice_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    part_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invoice_itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    part_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
  }

  export type invoice_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    part_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invoice_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    part_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invoice_itemsSumOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    service_id?: SortOrder
    part_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    payment_date?: SortOrder
    payment_amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    payment_amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    payment_date?: SortOrder
    payment_amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    payment_date?: SortOrder
    payment_amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    payment_amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_type?: SortOrder
    message?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type email_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type email_templatesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type email_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type email_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type email_templatesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeFilter<$PrismaModel> | $Enums.LogType
  }

  export type audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type audit_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    entity_id?: SortOrder
  }

  export type audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type audit_logsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    entity_id?: SortOrder
  }

  export type EnumLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.LogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogTypeFilter<$PrismaModel>
    _max?: NestedEnumLogTypeFilter<$PrismaModel>
  }

  export type tokensCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokensMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokensSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type usersCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput> | usersCreateWithoutOrganizationsInput[] | usersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutOrganizationsInput | usersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: usersCreateManyOrganizationsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type user_skillsCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<user_skillsCreateWithoutOrganizationsInput, user_skillsUncheckedCreateWithoutOrganizationsInput> | user_skillsCreateWithoutOrganizationsInput[] | user_skillsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutOrganizationsInput | user_skillsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: user_skillsCreateManyOrganizationsInputEnvelope
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
  }

  export type business_hoursCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<business_hoursCreateWithoutOrganizationsInput, business_hoursUncheckedCreateWithoutOrganizationsInput> | business_hoursCreateWithoutOrganizationsInput[] | business_hoursUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: business_hoursCreateOrConnectWithoutOrganizationsInput | business_hoursCreateOrConnectWithoutOrganizationsInput[]
    createMany?: business_hoursCreateManyOrganizationsInputEnvelope
    connect?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
  }

  export type holidaysCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<holidaysCreateWithoutOrganizationsInput, holidaysUncheckedCreateWithoutOrganizationsInput> | holidaysCreateWithoutOrganizationsInput[] | holidaysUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: holidaysCreateOrConnectWithoutOrganizationsInput | holidaysCreateOrConnectWithoutOrganizationsInput[]
    createMany?: holidaysCreateManyOrganizationsInputEnvelope
    connect?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
  }

  export type crew_membersCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<crew_membersCreateWithoutOrganizationsInput, crew_membersUncheckedCreateWithoutOrganizationsInput> | crew_membersCreateWithoutOrganizationsInput[] | crew_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutOrganizationsInput | crew_membersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: crew_membersCreateManyOrganizationsInputEnvelope
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
  }

  export type equipmentsCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<equipmentsCreateWithoutOrganizationsInput, equipmentsUncheckedCreateWithoutOrganizationsInput> | equipmentsCreateWithoutOrganizationsInput[] | equipmentsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: equipmentsCreateOrConnectWithoutOrganizationsInput | equipmentsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: equipmentsCreateManyOrganizationsInputEnvelope
    connect?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
  }

  export type companiesCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<companiesCreateWithoutOrganizationsInput, companiesUncheckedCreateWithoutOrganizationsInput> | companiesCreateWithoutOrganizationsInput[] | companiesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutOrganizationsInput | companiesCreateOrConnectWithoutOrganizationsInput[]
    createMany?: companiesCreateManyOrganizationsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type customersCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<customersCreateWithoutOrganizationsInput, customersUncheckedCreateWithoutOrganizationsInput> | customersCreateWithoutOrganizationsInput[] | customersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutOrganizationsInput | customersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: customersCreateManyOrganizationsInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type servicesCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<servicesCreateWithoutOrganizationsInput, servicesUncheckedCreateWithoutOrganizationsInput> | servicesCreateWithoutOrganizationsInput[] | servicesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutOrganizationsInput | servicesCreateOrConnectWithoutOrganizationsInput[]
    createMany?: servicesCreateManyOrganizationsInputEnvelope
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type assetsCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<assetsCreateWithoutOrganizationsInput, assetsUncheckedCreateWithoutOrganizationsInput> | assetsCreateWithoutOrganizationsInput[] | assetsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutOrganizationsInput | assetsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: assetsCreateManyOrganizationsInputEnvelope
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
  }

  export type partsCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<partsCreateWithoutOrganizationsInput, partsUncheckedCreateWithoutOrganizationsInput> | partsCreateWithoutOrganizationsInput[] | partsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: partsCreateOrConnectWithoutOrganizationsInput | partsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: partsCreateManyOrganizationsInputEnvelope
    connect?: partsWhereUniqueInput | partsWhereUniqueInput[]
  }

  export type maintenance_plansCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<maintenance_plansCreateWithoutOrganizationsInput, maintenance_plansUncheckedCreateWithoutOrganizationsInput> | maintenance_plansCreateWithoutOrganizationsInput[] | maintenance_plansUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutOrganizationsInput | maintenance_plansCreateOrConnectWithoutOrganizationsInput[]
    createMany?: maintenance_plansCreateManyOrganizationsInputEnvelope
    connect?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
  }

  export type work_ordersCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<work_ordersCreateWithoutOrganizationsInput, work_ordersUncheckedCreateWithoutOrganizationsInput> | work_ordersCreateWithoutOrganizationsInput[] | work_ordersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutOrganizationsInput | work_ordersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: work_ordersCreateManyOrganizationsInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput> | usersCreateWithoutOrganizationsInput[] | usersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutOrganizationsInput | usersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: usersCreateManyOrganizationsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<user_skillsCreateWithoutOrganizationsInput, user_skillsUncheckedCreateWithoutOrganizationsInput> | user_skillsCreateWithoutOrganizationsInput[] | user_skillsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutOrganizationsInput | user_skillsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: user_skillsCreateManyOrganizationsInputEnvelope
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
  }

  export type business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<business_hoursCreateWithoutOrganizationsInput, business_hoursUncheckedCreateWithoutOrganizationsInput> | business_hoursCreateWithoutOrganizationsInput[] | business_hoursUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: business_hoursCreateOrConnectWithoutOrganizationsInput | business_hoursCreateOrConnectWithoutOrganizationsInput[]
    createMany?: business_hoursCreateManyOrganizationsInputEnvelope
    connect?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
  }

  export type holidaysUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<holidaysCreateWithoutOrganizationsInput, holidaysUncheckedCreateWithoutOrganizationsInput> | holidaysCreateWithoutOrganizationsInput[] | holidaysUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: holidaysCreateOrConnectWithoutOrganizationsInput | holidaysCreateOrConnectWithoutOrganizationsInput[]
    createMany?: holidaysCreateManyOrganizationsInputEnvelope
    connect?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
  }

  export type crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<crew_membersCreateWithoutOrganizationsInput, crew_membersUncheckedCreateWithoutOrganizationsInput> | crew_membersCreateWithoutOrganizationsInput[] | crew_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutOrganizationsInput | crew_membersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: crew_membersCreateManyOrganizationsInputEnvelope
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
  }

  export type equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<equipmentsCreateWithoutOrganizationsInput, equipmentsUncheckedCreateWithoutOrganizationsInput> | equipmentsCreateWithoutOrganizationsInput[] | equipmentsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: equipmentsCreateOrConnectWithoutOrganizationsInput | equipmentsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: equipmentsCreateManyOrganizationsInputEnvelope
    connect?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
  }

  export type companiesUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<companiesCreateWithoutOrganizationsInput, companiesUncheckedCreateWithoutOrganizationsInput> | companiesCreateWithoutOrganizationsInput[] | companiesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutOrganizationsInput | companiesCreateOrConnectWithoutOrganizationsInput[]
    createMany?: companiesCreateManyOrganizationsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type customersUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<customersCreateWithoutOrganizationsInput, customersUncheckedCreateWithoutOrganizationsInput> | customersCreateWithoutOrganizationsInput[] | customersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutOrganizationsInput | customersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: customersCreateManyOrganizationsInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type servicesUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<servicesCreateWithoutOrganizationsInput, servicesUncheckedCreateWithoutOrganizationsInput> | servicesCreateWithoutOrganizationsInput[] | servicesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutOrganizationsInput | servicesCreateOrConnectWithoutOrganizationsInput[]
    createMany?: servicesCreateManyOrganizationsInputEnvelope
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
  }

  export type assetsUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<assetsCreateWithoutOrganizationsInput, assetsUncheckedCreateWithoutOrganizationsInput> | assetsCreateWithoutOrganizationsInput[] | assetsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutOrganizationsInput | assetsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: assetsCreateManyOrganizationsInputEnvelope
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
  }

  export type partsUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<partsCreateWithoutOrganizationsInput, partsUncheckedCreateWithoutOrganizationsInput> | partsCreateWithoutOrganizationsInput[] | partsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: partsCreateOrConnectWithoutOrganizationsInput | partsCreateOrConnectWithoutOrganizationsInput[]
    createMany?: partsCreateManyOrganizationsInputEnvelope
    connect?: partsWhereUniqueInput | partsWhereUniqueInput[]
  }

  export type maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<maintenance_plansCreateWithoutOrganizationsInput, maintenance_plansUncheckedCreateWithoutOrganizationsInput> | maintenance_plansCreateWithoutOrganizationsInput[] | maintenance_plansUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutOrganizationsInput | maintenance_plansCreateOrConnectWithoutOrganizationsInput[]
    createMany?: maintenance_plansCreateManyOrganizationsInputEnvelope
    connect?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
  }

  export type work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<work_ordersCreateWithoutOrganizationsInput, work_ordersUncheckedCreateWithoutOrganizationsInput> | work_ordersCreateWithoutOrganizationsInput[] | work_ordersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutOrganizationsInput | work_ordersCreateOrConnectWithoutOrganizationsInput[]
    createMany?: work_ordersCreateManyOrganizationsInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type usersUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput> | usersCreateWithoutOrganizationsInput[] | usersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutOrganizationsInput | usersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutOrganizationsInput | usersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: usersCreateManyOrganizationsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutOrganizationsInput | usersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutOrganizationsInput | usersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type user_skillsUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<user_skillsCreateWithoutOrganizationsInput, user_skillsUncheckedCreateWithoutOrganizationsInput> | user_skillsCreateWithoutOrganizationsInput[] | user_skillsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutOrganizationsInput | user_skillsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: user_skillsUpsertWithWhereUniqueWithoutOrganizationsInput | user_skillsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: user_skillsCreateManyOrganizationsInputEnvelope
    set?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    disconnect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    delete?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    update?: user_skillsUpdateWithWhereUniqueWithoutOrganizationsInput | user_skillsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: user_skillsUpdateManyWithWhereWithoutOrganizationsInput | user_skillsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
  }

  export type business_hoursUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<business_hoursCreateWithoutOrganizationsInput, business_hoursUncheckedCreateWithoutOrganizationsInput> | business_hoursCreateWithoutOrganizationsInput[] | business_hoursUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: business_hoursCreateOrConnectWithoutOrganizationsInput | business_hoursCreateOrConnectWithoutOrganizationsInput[]
    upsert?: business_hoursUpsertWithWhereUniqueWithoutOrganizationsInput | business_hoursUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: business_hoursCreateManyOrganizationsInputEnvelope
    set?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    disconnect?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    delete?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    connect?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    update?: business_hoursUpdateWithWhereUniqueWithoutOrganizationsInput | business_hoursUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: business_hoursUpdateManyWithWhereWithoutOrganizationsInput | business_hoursUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: business_hoursScalarWhereInput | business_hoursScalarWhereInput[]
  }

  export type holidaysUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<holidaysCreateWithoutOrganizationsInput, holidaysUncheckedCreateWithoutOrganizationsInput> | holidaysCreateWithoutOrganizationsInput[] | holidaysUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: holidaysCreateOrConnectWithoutOrganizationsInput | holidaysCreateOrConnectWithoutOrganizationsInput[]
    upsert?: holidaysUpsertWithWhereUniqueWithoutOrganizationsInput | holidaysUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: holidaysCreateManyOrganizationsInputEnvelope
    set?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    disconnect?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    delete?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    connect?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    update?: holidaysUpdateWithWhereUniqueWithoutOrganizationsInput | holidaysUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: holidaysUpdateManyWithWhereWithoutOrganizationsInput | holidaysUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: holidaysScalarWhereInput | holidaysScalarWhereInput[]
  }

  export type crew_membersUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<crew_membersCreateWithoutOrganizationsInput, crew_membersUncheckedCreateWithoutOrganizationsInput> | crew_membersCreateWithoutOrganizationsInput[] | crew_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutOrganizationsInput | crew_membersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: crew_membersUpsertWithWhereUniqueWithoutOrganizationsInput | crew_membersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: crew_membersCreateManyOrganizationsInputEnvelope
    set?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    disconnect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    delete?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    update?: crew_membersUpdateWithWhereUniqueWithoutOrganizationsInput | crew_membersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: crew_membersUpdateManyWithWhereWithoutOrganizationsInput | crew_membersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
  }

  export type equipmentsUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<equipmentsCreateWithoutOrganizationsInput, equipmentsUncheckedCreateWithoutOrganizationsInput> | equipmentsCreateWithoutOrganizationsInput[] | equipmentsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: equipmentsCreateOrConnectWithoutOrganizationsInput | equipmentsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: equipmentsUpsertWithWhereUniqueWithoutOrganizationsInput | equipmentsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: equipmentsCreateManyOrganizationsInputEnvelope
    set?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    disconnect?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    delete?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    connect?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    update?: equipmentsUpdateWithWhereUniqueWithoutOrganizationsInput | equipmentsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: equipmentsUpdateManyWithWhereWithoutOrganizationsInput | equipmentsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: equipmentsScalarWhereInput | equipmentsScalarWhereInput[]
  }

  export type companiesUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<companiesCreateWithoutOrganizationsInput, companiesUncheckedCreateWithoutOrganizationsInput> | companiesCreateWithoutOrganizationsInput[] | companiesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutOrganizationsInput | companiesCreateOrConnectWithoutOrganizationsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutOrganizationsInput | companiesUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: companiesCreateManyOrganizationsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutOrganizationsInput | companiesUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutOrganizationsInput | companiesUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type customersUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<customersCreateWithoutOrganizationsInput, customersUncheckedCreateWithoutOrganizationsInput> | customersCreateWithoutOrganizationsInput[] | customersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutOrganizationsInput | customersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutOrganizationsInput | customersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: customersCreateManyOrganizationsInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutOrganizationsInput | customersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: customersUpdateManyWithWhereWithoutOrganizationsInput | customersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type servicesUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<servicesCreateWithoutOrganizationsInput, servicesUncheckedCreateWithoutOrganizationsInput> | servicesCreateWithoutOrganizationsInput[] | servicesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutOrganizationsInput | servicesCreateOrConnectWithoutOrganizationsInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutOrganizationsInput | servicesUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: servicesCreateManyOrganizationsInputEnvelope
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutOrganizationsInput | servicesUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutOrganizationsInput | servicesUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type assetsUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<assetsCreateWithoutOrganizationsInput, assetsUncheckedCreateWithoutOrganizationsInput> | assetsCreateWithoutOrganizationsInput[] | assetsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutOrganizationsInput | assetsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: assetsUpsertWithWhereUniqueWithoutOrganizationsInput | assetsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: assetsCreateManyOrganizationsInputEnvelope
    set?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    disconnect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    delete?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    update?: assetsUpdateWithWhereUniqueWithoutOrganizationsInput | assetsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: assetsUpdateManyWithWhereWithoutOrganizationsInput | assetsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: assetsScalarWhereInput | assetsScalarWhereInput[]
  }

  export type partsUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<partsCreateWithoutOrganizationsInput, partsUncheckedCreateWithoutOrganizationsInput> | partsCreateWithoutOrganizationsInput[] | partsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: partsCreateOrConnectWithoutOrganizationsInput | partsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: partsUpsertWithWhereUniqueWithoutOrganizationsInput | partsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: partsCreateManyOrganizationsInputEnvelope
    set?: partsWhereUniqueInput | partsWhereUniqueInput[]
    disconnect?: partsWhereUniqueInput | partsWhereUniqueInput[]
    delete?: partsWhereUniqueInput | partsWhereUniqueInput[]
    connect?: partsWhereUniqueInput | partsWhereUniqueInput[]
    update?: partsUpdateWithWhereUniqueWithoutOrganizationsInput | partsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: partsUpdateManyWithWhereWithoutOrganizationsInput | partsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: partsScalarWhereInput | partsScalarWhereInput[]
  }

  export type maintenance_plansUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<maintenance_plansCreateWithoutOrganizationsInput, maintenance_plansUncheckedCreateWithoutOrganizationsInput> | maintenance_plansCreateWithoutOrganizationsInput[] | maintenance_plansUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutOrganizationsInput | maintenance_plansCreateOrConnectWithoutOrganizationsInput[]
    upsert?: maintenance_plansUpsertWithWhereUniqueWithoutOrganizationsInput | maintenance_plansUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: maintenance_plansCreateManyOrganizationsInputEnvelope
    set?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    disconnect?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    delete?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    connect?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    update?: maintenance_plansUpdateWithWhereUniqueWithoutOrganizationsInput | maintenance_plansUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: maintenance_plansUpdateManyWithWhereWithoutOrganizationsInput | maintenance_plansUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: maintenance_plansScalarWhereInput | maintenance_plansScalarWhereInput[]
  }

  export type work_ordersUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<work_ordersCreateWithoutOrganizationsInput, work_ordersUncheckedCreateWithoutOrganizationsInput> | work_ordersCreateWithoutOrganizationsInput[] | work_ordersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutOrganizationsInput | work_ordersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutOrganizationsInput | work_ordersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: work_ordersCreateManyOrganizationsInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutOrganizationsInput | work_ordersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutOrganizationsInput | work_ordersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput> | usersCreateWithoutOrganizationsInput[] | usersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutOrganizationsInput | usersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutOrganizationsInput | usersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: usersCreateManyOrganizationsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutOrganizationsInput | usersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutOrganizationsInput | usersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<user_skillsCreateWithoutOrganizationsInput, user_skillsUncheckedCreateWithoutOrganizationsInput> | user_skillsCreateWithoutOrganizationsInput[] | user_skillsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutOrganizationsInput | user_skillsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: user_skillsUpsertWithWhereUniqueWithoutOrganizationsInput | user_skillsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: user_skillsCreateManyOrganizationsInputEnvelope
    set?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    disconnect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    delete?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    update?: user_skillsUpdateWithWhereUniqueWithoutOrganizationsInput | user_skillsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: user_skillsUpdateManyWithWhereWithoutOrganizationsInput | user_skillsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
  }

  export type business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<business_hoursCreateWithoutOrganizationsInput, business_hoursUncheckedCreateWithoutOrganizationsInput> | business_hoursCreateWithoutOrganizationsInput[] | business_hoursUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: business_hoursCreateOrConnectWithoutOrganizationsInput | business_hoursCreateOrConnectWithoutOrganizationsInput[]
    upsert?: business_hoursUpsertWithWhereUniqueWithoutOrganizationsInput | business_hoursUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: business_hoursCreateManyOrganizationsInputEnvelope
    set?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    disconnect?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    delete?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    connect?: business_hoursWhereUniqueInput | business_hoursWhereUniqueInput[]
    update?: business_hoursUpdateWithWhereUniqueWithoutOrganizationsInput | business_hoursUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: business_hoursUpdateManyWithWhereWithoutOrganizationsInput | business_hoursUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: business_hoursScalarWhereInput | business_hoursScalarWhereInput[]
  }

  export type holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<holidaysCreateWithoutOrganizationsInput, holidaysUncheckedCreateWithoutOrganizationsInput> | holidaysCreateWithoutOrganizationsInput[] | holidaysUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: holidaysCreateOrConnectWithoutOrganizationsInput | holidaysCreateOrConnectWithoutOrganizationsInput[]
    upsert?: holidaysUpsertWithWhereUniqueWithoutOrganizationsInput | holidaysUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: holidaysCreateManyOrganizationsInputEnvelope
    set?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    disconnect?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    delete?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    connect?: holidaysWhereUniqueInput | holidaysWhereUniqueInput[]
    update?: holidaysUpdateWithWhereUniqueWithoutOrganizationsInput | holidaysUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: holidaysUpdateManyWithWhereWithoutOrganizationsInput | holidaysUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: holidaysScalarWhereInput | holidaysScalarWhereInput[]
  }

  export type crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<crew_membersCreateWithoutOrganizationsInput, crew_membersUncheckedCreateWithoutOrganizationsInput> | crew_membersCreateWithoutOrganizationsInput[] | crew_membersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutOrganizationsInput | crew_membersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: crew_membersUpsertWithWhereUniqueWithoutOrganizationsInput | crew_membersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: crew_membersCreateManyOrganizationsInputEnvelope
    set?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    disconnect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    delete?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    update?: crew_membersUpdateWithWhereUniqueWithoutOrganizationsInput | crew_membersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: crew_membersUpdateManyWithWhereWithoutOrganizationsInput | crew_membersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
  }

  export type equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<equipmentsCreateWithoutOrganizationsInput, equipmentsUncheckedCreateWithoutOrganizationsInput> | equipmentsCreateWithoutOrganizationsInput[] | equipmentsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: equipmentsCreateOrConnectWithoutOrganizationsInput | equipmentsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: equipmentsUpsertWithWhereUniqueWithoutOrganizationsInput | equipmentsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: equipmentsCreateManyOrganizationsInputEnvelope
    set?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    disconnect?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    delete?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    connect?: equipmentsWhereUniqueInput | equipmentsWhereUniqueInput[]
    update?: equipmentsUpdateWithWhereUniqueWithoutOrganizationsInput | equipmentsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: equipmentsUpdateManyWithWhereWithoutOrganizationsInput | equipmentsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: equipmentsScalarWhereInput | equipmentsScalarWhereInput[]
  }

  export type companiesUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<companiesCreateWithoutOrganizationsInput, companiesUncheckedCreateWithoutOrganizationsInput> | companiesCreateWithoutOrganizationsInput[] | companiesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutOrganizationsInput | companiesCreateOrConnectWithoutOrganizationsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutOrganizationsInput | companiesUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: companiesCreateManyOrganizationsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutOrganizationsInput | companiesUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutOrganizationsInput | companiesUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type customersUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<customersCreateWithoutOrganizationsInput, customersUncheckedCreateWithoutOrganizationsInput> | customersCreateWithoutOrganizationsInput[] | customersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: customersCreateOrConnectWithoutOrganizationsInput | customersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutOrganizationsInput | customersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: customersCreateManyOrganizationsInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutOrganizationsInput | customersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: customersUpdateManyWithWhereWithoutOrganizationsInput | customersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type servicesUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<servicesCreateWithoutOrganizationsInput, servicesUncheckedCreateWithoutOrganizationsInput> | servicesCreateWithoutOrganizationsInput[] | servicesUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: servicesCreateOrConnectWithoutOrganizationsInput | servicesCreateOrConnectWithoutOrganizationsInput[]
    upsert?: servicesUpsertWithWhereUniqueWithoutOrganizationsInput | servicesUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: servicesCreateManyOrganizationsInputEnvelope
    set?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    disconnect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    delete?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    connect?: servicesWhereUniqueInput | servicesWhereUniqueInput[]
    update?: servicesUpdateWithWhereUniqueWithoutOrganizationsInput | servicesUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: servicesUpdateManyWithWhereWithoutOrganizationsInput | servicesUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: servicesScalarWhereInput | servicesScalarWhereInput[]
  }

  export type assetsUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<assetsCreateWithoutOrganizationsInput, assetsUncheckedCreateWithoutOrganizationsInput> | assetsCreateWithoutOrganizationsInput[] | assetsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutOrganizationsInput | assetsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: assetsUpsertWithWhereUniqueWithoutOrganizationsInput | assetsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: assetsCreateManyOrganizationsInputEnvelope
    set?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    disconnect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    delete?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    update?: assetsUpdateWithWhereUniqueWithoutOrganizationsInput | assetsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: assetsUpdateManyWithWhereWithoutOrganizationsInput | assetsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: assetsScalarWhereInput | assetsScalarWhereInput[]
  }

  export type partsUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<partsCreateWithoutOrganizationsInput, partsUncheckedCreateWithoutOrganizationsInput> | partsCreateWithoutOrganizationsInput[] | partsUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: partsCreateOrConnectWithoutOrganizationsInput | partsCreateOrConnectWithoutOrganizationsInput[]
    upsert?: partsUpsertWithWhereUniqueWithoutOrganizationsInput | partsUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: partsCreateManyOrganizationsInputEnvelope
    set?: partsWhereUniqueInput | partsWhereUniqueInput[]
    disconnect?: partsWhereUniqueInput | partsWhereUniqueInput[]
    delete?: partsWhereUniqueInput | partsWhereUniqueInput[]
    connect?: partsWhereUniqueInput | partsWhereUniqueInput[]
    update?: partsUpdateWithWhereUniqueWithoutOrganizationsInput | partsUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: partsUpdateManyWithWhereWithoutOrganizationsInput | partsUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: partsScalarWhereInput | partsScalarWhereInput[]
  }

  export type maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<maintenance_plansCreateWithoutOrganizationsInput, maintenance_plansUncheckedCreateWithoutOrganizationsInput> | maintenance_plansCreateWithoutOrganizationsInput[] | maintenance_plansUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutOrganizationsInput | maintenance_plansCreateOrConnectWithoutOrganizationsInput[]
    upsert?: maintenance_plansUpsertWithWhereUniqueWithoutOrganizationsInput | maintenance_plansUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: maintenance_plansCreateManyOrganizationsInputEnvelope
    set?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    disconnect?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    delete?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    connect?: maintenance_plansWhereUniqueInput | maintenance_plansWhereUniqueInput[]
    update?: maintenance_plansUpdateWithWhereUniqueWithoutOrganizationsInput | maintenance_plansUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: maintenance_plansUpdateManyWithWhereWithoutOrganizationsInput | maintenance_plansUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: maintenance_plansScalarWhereInput | maintenance_plansScalarWhereInput[]
  }

  export type work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<work_ordersCreateWithoutOrganizationsInput, work_ordersUncheckedCreateWithoutOrganizationsInput> | work_ordersCreateWithoutOrganizationsInput[] | work_ordersUncheckedCreateWithoutOrganizationsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutOrganizationsInput | work_ordersCreateOrConnectWithoutOrganizationsInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutOrganizationsInput | work_ordersUpsertWithWhereUniqueWithoutOrganizationsInput[]
    createMany?: work_ordersCreateManyOrganizationsInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutOrganizationsInput | work_ordersUpdateWithWhereUniqueWithoutOrganizationsInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutOrganizationsInput | work_ordersUpdateManyWithWhereWithoutOrganizationsInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type organizationsCreateNestedOneWithoutUsersInput = {
    create?: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutUsersInput
    connect?: organizationsWhereUniqueInput
  }

  export type user_skillsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_skillsCreateWithoutUsersInput, user_skillsUncheckedCreateWithoutUsersInput> | user_skillsCreateWithoutUsersInput[] | user_skillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutUsersInput | user_skillsCreateOrConnectWithoutUsersInput[]
    createMany?: user_skillsCreateManyUsersInputEnvelope
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
  }

  export type time_off_requestsCreateNestedManyWithoutUsersInput = {
    create?: XOR<time_off_requestsCreateWithoutUsersInput, time_off_requestsUncheckedCreateWithoutUsersInput> | time_off_requestsCreateWithoutUsersInput[] | time_off_requestsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: time_off_requestsCreateOrConnectWithoutUsersInput | time_off_requestsCreateOrConnectWithoutUsersInput[]
    createMany?: time_off_requestsCreateManyUsersInputEnvelope
    connect?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
  }

  export type crewsCreateNestedManyWithoutUsersInput = {
    create?: XOR<crewsCreateWithoutUsersInput, crewsUncheckedCreateWithoutUsersInput> | crewsCreateWithoutUsersInput[] | crewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crewsCreateOrConnectWithoutUsersInput | crewsCreateOrConnectWithoutUsersInput[]
    createMany?: crewsCreateManyUsersInputEnvelope
    connect?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
  }

  export type crew_membersCreateNestedManyWithoutUsersInput = {
    create?: XOR<crew_membersCreateWithoutUsersInput, crew_membersUncheckedCreateWithoutUsersInput> | crew_membersCreateWithoutUsersInput[] | crew_membersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutUsersInput | crew_membersCreateOrConnectWithoutUsersInput[]
    createMany?: crew_membersCreateManyUsersInputEnvelope
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type audit_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type user_skillsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_skillsCreateWithoutUsersInput, user_skillsUncheckedCreateWithoutUsersInput> | user_skillsCreateWithoutUsersInput[] | user_skillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutUsersInput | user_skillsCreateOrConnectWithoutUsersInput[]
    createMany?: user_skillsCreateManyUsersInputEnvelope
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
  }

  export type time_off_requestsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<time_off_requestsCreateWithoutUsersInput, time_off_requestsUncheckedCreateWithoutUsersInput> | time_off_requestsCreateWithoutUsersInput[] | time_off_requestsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: time_off_requestsCreateOrConnectWithoutUsersInput | time_off_requestsCreateOrConnectWithoutUsersInput[]
    createMany?: time_off_requestsCreateManyUsersInputEnvelope
    connect?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
  }

  export type crewsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<crewsCreateWithoutUsersInput, crewsUncheckedCreateWithoutUsersInput> | crewsCreateWithoutUsersInput[] | crewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crewsCreateOrConnectWithoutUsersInput | crewsCreateOrConnectWithoutUsersInput[]
    createMany?: crewsCreateManyUsersInputEnvelope
    connect?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
  }

  export type crew_membersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<crew_membersCreateWithoutUsersInput, crew_membersUncheckedCreateWithoutUsersInput> | crew_membersCreateWithoutUsersInput[] | crew_membersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutUsersInput | crew_membersCreateOrConnectWithoutUsersInput[]
    createMany?: crew_membersCreateManyUsersInputEnvelope
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type audit_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type organizationsUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutUsersInput
    upsert?: organizationsUpsertWithoutUsersInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutUsersInput, organizationsUpdateWithoutUsersInput>, organizationsUncheckedUpdateWithoutUsersInput>
  }

  export type user_skillsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_skillsCreateWithoutUsersInput, user_skillsUncheckedCreateWithoutUsersInput> | user_skillsCreateWithoutUsersInput[] | user_skillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutUsersInput | user_skillsCreateOrConnectWithoutUsersInput[]
    upsert?: user_skillsUpsertWithWhereUniqueWithoutUsersInput | user_skillsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_skillsCreateManyUsersInputEnvelope
    set?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    disconnect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    delete?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    update?: user_skillsUpdateWithWhereUniqueWithoutUsersInput | user_skillsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_skillsUpdateManyWithWhereWithoutUsersInput | user_skillsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
  }

  export type time_off_requestsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<time_off_requestsCreateWithoutUsersInput, time_off_requestsUncheckedCreateWithoutUsersInput> | time_off_requestsCreateWithoutUsersInput[] | time_off_requestsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: time_off_requestsCreateOrConnectWithoutUsersInput | time_off_requestsCreateOrConnectWithoutUsersInput[]
    upsert?: time_off_requestsUpsertWithWhereUniqueWithoutUsersInput | time_off_requestsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: time_off_requestsCreateManyUsersInputEnvelope
    set?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    disconnect?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    delete?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    connect?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    update?: time_off_requestsUpdateWithWhereUniqueWithoutUsersInput | time_off_requestsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: time_off_requestsUpdateManyWithWhereWithoutUsersInput | time_off_requestsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: time_off_requestsScalarWhereInput | time_off_requestsScalarWhereInput[]
  }

  export type crewsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<crewsCreateWithoutUsersInput, crewsUncheckedCreateWithoutUsersInput> | crewsCreateWithoutUsersInput[] | crewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crewsCreateOrConnectWithoutUsersInput | crewsCreateOrConnectWithoutUsersInput[]
    upsert?: crewsUpsertWithWhereUniqueWithoutUsersInput | crewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: crewsCreateManyUsersInputEnvelope
    set?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    disconnect?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    delete?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    connect?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    update?: crewsUpdateWithWhereUniqueWithoutUsersInput | crewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: crewsUpdateManyWithWhereWithoutUsersInput | crewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: crewsScalarWhereInput | crewsScalarWhereInput[]
  }

  export type crew_membersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<crew_membersCreateWithoutUsersInput, crew_membersUncheckedCreateWithoutUsersInput> | crew_membersCreateWithoutUsersInput[] | crew_membersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutUsersInput | crew_membersCreateOrConnectWithoutUsersInput[]
    upsert?: crew_membersUpsertWithWhereUniqueWithoutUsersInput | crew_membersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: crew_membersCreateManyUsersInputEnvelope
    set?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    disconnect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    delete?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    update?: crew_membersUpdateWithWhereUniqueWithoutUsersInput | crew_membersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: crew_membersUpdateManyWithWhereWithoutUsersInput | crew_membersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type audit_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type user_skillsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_skillsCreateWithoutUsersInput, user_skillsUncheckedCreateWithoutUsersInput> | user_skillsCreateWithoutUsersInput[] | user_skillsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutUsersInput | user_skillsCreateOrConnectWithoutUsersInput[]
    upsert?: user_skillsUpsertWithWhereUniqueWithoutUsersInput | user_skillsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_skillsCreateManyUsersInputEnvelope
    set?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    disconnect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    delete?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    update?: user_skillsUpdateWithWhereUniqueWithoutUsersInput | user_skillsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_skillsUpdateManyWithWhereWithoutUsersInput | user_skillsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
  }

  export type time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<time_off_requestsCreateWithoutUsersInput, time_off_requestsUncheckedCreateWithoutUsersInput> | time_off_requestsCreateWithoutUsersInput[] | time_off_requestsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: time_off_requestsCreateOrConnectWithoutUsersInput | time_off_requestsCreateOrConnectWithoutUsersInput[]
    upsert?: time_off_requestsUpsertWithWhereUniqueWithoutUsersInput | time_off_requestsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: time_off_requestsCreateManyUsersInputEnvelope
    set?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    disconnect?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    delete?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    connect?: time_off_requestsWhereUniqueInput | time_off_requestsWhereUniqueInput[]
    update?: time_off_requestsUpdateWithWhereUniqueWithoutUsersInput | time_off_requestsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: time_off_requestsUpdateManyWithWhereWithoutUsersInput | time_off_requestsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: time_off_requestsScalarWhereInput | time_off_requestsScalarWhereInput[]
  }

  export type crewsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<crewsCreateWithoutUsersInput, crewsUncheckedCreateWithoutUsersInput> | crewsCreateWithoutUsersInput[] | crewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crewsCreateOrConnectWithoutUsersInput | crewsCreateOrConnectWithoutUsersInput[]
    upsert?: crewsUpsertWithWhereUniqueWithoutUsersInput | crewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: crewsCreateManyUsersInputEnvelope
    set?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    disconnect?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    delete?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    connect?: crewsWhereUniqueInput | crewsWhereUniqueInput[]
    update?: crewsUpdateWithWhereUniqueWithoutUsersInput | crewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: crewsUpdateManyWithWhereWithoutUsersInput | crewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: crewsScalarWhereInput | crewsScalarWhereInput[]
  }

  export type crew_membersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<crew_membersCreateWithoutUsersInput, crew_membersUncheckedCreateWithoutUsersInput> | crew_membersCreateWithoutUsersInput[] | crew_membersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutUsersInput | crew_membersCreateOrConnectWithoutUsersInput[]
    upsert?: crew_membersUpsertWithWhereUniqueWithoutUsersInput | crew_membersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: crew_membersCreateManyUsersInputEnvelope
    set?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    disconnect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    delete?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    update?: crew_membersUpdateWithWhereUniqueWithoutUsersInput | crew_membersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: crew_membersUpdateManyWithWhereWithoutUsersInput | crew_membersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type user_skillsCreateNestedManyWithoutSkillsInput = {
    create?: XOR<user_skillsCreateWithoutSkillsInput, user_skillsUncheckedCreateWithoutSkillsInput> | user_skillsCreateWithoutSkillsInput[] | user_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutSkillsInput | user_skillsCreateOrConnectWithoutSkillsInput[]
    createMany?: user_skillsCreateManySkillsInputEnvelope
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
  }

  export type user_skillsUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<user_skillsCreateWithoutSkillsInput, user_skillsUncheckedCreateWithoutSkillsInput> | user_skillsCreateWithoutSkillsInput[] | user_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutSkillsInput | user_skillsCreateOrConnectWithoutSkillsInput[]
    createMany?: user_skillsCreateManySkillsInputEnvelope
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
  }

  export type user_skillsUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<user_skillsCreateWithoutSkillsInput, user_skillsUncheckedCreateWithoutSkillsInput> | user_skillsCreateWithoutSkillsInput[] | user_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutSkillsInput | user_skillsCreateOrConnectWithoutSkillsInput[]
    upsert?: user_skillsUpsertWithWhereUniqueWithoutSkillsInput | user_skillsUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: user_skillsCreateManySkillsInputEnvelope
    set?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    disconnect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    delete?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    update?: user_skillsUpdateWithWhereUniqueWithoutSkillsInput | user_skillsUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: user_skillsUpdateManyWithWhereWithoutSkillsInput | user_skillsUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
  }

  export type user_skillsUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<user_skillsCreateWithoutSkillsInput, user_skillsUncheckedCreateWithoutSkillsInput> | user_skillsCreateWithoutSkillsInput[] | user_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: user_skillsCreateOrConnectWithoutSkillsInput | user_skillsCreateOrConnectWithoutSkillsInput[]
    upsert?: user_skillsUpsertWithWhereUniqueWithoutSkillsInput | user_skillsUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: user_skillsCreateManySkillsInputEnvelope
    set?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    disconnect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    delete?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    connect?: user_skillsWhereUniqueInput | user_skillsWhereUniqueInput[]
    update?: user_skillsUpdateWithWhereUniqueWithoutSkillsInput | user_skillsUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: user_skillsUpdateManyWithWhereWithoutSkillsInput | user_skillsUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUser_skillsInput = {
    create?: XOR<usersCreateWithoutUser_skillsInput, usersUncheckedCreateWithoutUser_skillsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_skillsInput
    connect?: usersWhereUniqueInput
  }

  export type skillsCreateNestedOneWithoutUser_skillsInput = {
    create?: XOR<skillsCreateWithoutUser_skillsInput, skillsUncheckedCreateWithoutUser_skillsInput>
    connectOrCreate?: skillsCreateOrConnectWithoutUser_skillsInput
    connect?: skillsWhereUniqueInput
  }

  export type organizationsCreateNestedOneWithoutUser_skillsInput = {
    create?: XOR<organizationsCreateWithoutUser_skillsInput, organizationsUncheckedCreateWithoutUser_skillsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutUser_skillsInput
    connect?: organizationsWhereUniqueInput
  }

  export type EnumProficiencyLevelFieldUpdateOperationsInput = {
    set?: $Enums.ProficiencyLevel
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersUpdateOneRequiredWithoutUser_skillsNestedInput = {
    create?: XOR<usersCreateWithoutUser_skillsInput, usersUncheckedCreateWithoutUser_skillsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_skillsInput
    upsert?: usersUpsertWithoutUser_skillsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_skillsInput, usersUpdateWithoutUser_skillsInput>, usersUncheckedUpdateWithoutUser_skillsInput>
  }

  export type skillsUpdateOneRequiredWithoutUser_skillsNestedInput = {
    create?: XOR<skillsCreateWithoutUser_skillsInput, skillsUncheckedCreateWithoutUser_skillsInput>
    connectOrCreate?: skillsCreateOrConnectWithoutUser_skillsInput
    upsert?: skillsUpsertWithoutUser_skillsInput
    connect?: skillsWhereUniqueInput
    update?: XOR<XOR<skillsUpdateToOneWithWhereWithoutUser_skillsInput, skillsUpdateWithoutUser_skillsInput>, skillsUncheckedUpdateWithoutUser_skillsInput>
  }

  export type organizationsUpdateOneRequiredWithoutUser_skillsNestedInput = {
    create?: XOR<organizationsCreateWithoutUser_skillsInput, organizationsUncheckedCreateWithoutUser_skillsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutUser_skillsInput
    upsert?: organizationsUpsertWithoutUser_skillsInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutUser_skillsInput, organizationsUpdateWithoutUser_skillsInput>, organizationsUncheckedUpdateWithoutUser_skillsInput>
  }

  export type organizationsCreateNestedOneWithoutBusiness_hoursInput = {
    create?: XOR<organizationsCreateWithoutBusiness_hoursInput, organizationsUncheckedCreateWithoutBusiness_hoursInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutBusiness_hoursInput
    connect?: organizationsWhereUniqueInput
  }

  export type EnumDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.DayOfWeek
  }

  export type organizationsUpdateOneRequiredWithoutBusiness_hoursNestedInput = {
    create?: XOR<organizationsCreateWithoutBusiness_hoursInput, organizationsUncheckedCreateWithoutBusiness_hoursInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutBusiness_hoursInput
    upsert?: organizationsUpsertWithoutBusiness_hoursInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutBusiness_hoursInput, organizationsUpdateWithoutBusiness_hoursInput>, organizationsUncheckedUpdateWithoutBusiness_hoursInput>
  }

  export type organizationsCreateNestedOneWithoutHolidaysInput = {
    create?: XOR<organizationsCreateWithoutHolidaysInput, organizationsUncheckedCreateWithoutHolidaysInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutHolidaysInput
    connect?: organizationsWhereUniqueInput
  }

  export type organizationsUpdateOneRequiredWithoutHolidaysNestedInput = {
    create?: XOR<organizationsCreateWithoutHolidaysInput, organizationsUncheckedCreateWithoutHolidaysInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutHolidaysInput
    upsert?: organizationsUpsertWithoutHolidaysInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutHolidaysInput, organizationsUpdateWithoutHolidaysInput>, organizationsUncheckedUpdateWithoutHolidaysInput>
  }

  export type usersCreateNestedOneWithoutTime_off_requestsInput = {
    create?: XOR<usersCreateWithoutTime_off_requestsInput, usersUncheckedCreateWithoutTime_off_requestsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTime_off_requestsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type usersUpdateOneRequiredWithoutTime_off_requestsNestedInput = {
    create?: XOR<usersCreateWithoutTime_off_requestsInput, usersUncheckedCreateWithoutTime_off_requestsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTime_off_requestsInput
    upsert?: usersUpsertWithoutTime_off_requestsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTime_off_requestsInput, usersUpdateWithoutTime_off_requestsInput>, usersUncheckedUpdateWithoutTime_off_requestsInput>
  }

  export type usersCreateNestedOneWithoutCrewsInput = {
    create?: XOR<usersCreateWithoutCrewsInput, usersUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCrewsInput
    connect?: usersWhereUniqueInput
  }

  export type crew_membersCreateNestedManyWithoutCrewsInput = {
    create?: XOR<crew_membersCreateWithoutCrewsInput, crew_membersUncheckedCreateWithoutCrewsInput> | crew_membersCreateWithoutCrewsInput[] | crew_membersUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutCrewsInput | crew_membersCreateOrConnectWithoutCrewsInput[]
    createMany?: crew_membersCreateManyCrewsInputEnvelope
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
  }

  export type work_order_crewCreateNestedManyWithoutCrewsInput = {
    create?: XOR<work_order_crewCreateWithoutCrewsInput, work_order_crewUncheckedCreateWithoutCrewsInput> | work_order_crewCreateWithoutCrewsInput[] | work_order_crewUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutCrewsInput | work_order_crewCreateOrConnectWithoutCrewsInput[]
    createMany?: work_order_crewCreateManyCrewsInputEnvelope
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
  }

  export type crew_membersUncheckedCreateNestedManyWithoutCrewsInput = {
    create?: XOR<crew_membersCreateWithoutCrewsInput, crew_membersUncheckedCreateWithoutCrewsInput> | crew_membersCreateWithoutCrewsInput[] | crew_membersUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutCrewsInput | crew_membersCreateOrConnectWithoutCrewsInput[]
    createMany?: crew_membersCreateManyCrewsInputEnvelope
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
  }

  export type work_order_crewUncheckedCreateNestedManyWithoutCrewsInput = {
    create?: XOR<work_order_crewCreateWithoutCrewsInput, work_order_crewUncheckedCreateWithoutCrewsInput> | work_order_crewCreateWithoutCrewsInput[] | work_order_crewUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutCrewsInput | work_order_crewCreateOrConnectWithoutCrewsInput[]
    createMany?: work_order_crewCreateManyCrewsInputEnvelope
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutCrewsNestedInput = {
    create?: XOR<usersCreateWithoutCrewsInput, usersUncheckedCreateWithoutCrewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCrewsInput
    upsert?: usersUpsertWithoutCrewsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCrewsInput, usersUpdateWithoutCrewsInput>, usersUncheckedUpdateWithoutCrewsInput>
  }

  export type crew_membersUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<crew_membersCreateWithoutCrewsInput, crew_membersUncheckedCreateWithoutCrewsInput> | crew_membersCreateWithoutCrewsInput[] | crew_membersUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutCrewsInput | crew_membersCreateOrConnectWithoutCrewsInput[]
    upsert?: crew_membersUpsertWithWhereUniqueWithoutCrewsInput | crew_membersUpsertWithWhereUniqueWithoutCrewsInput[]
    createMany?: crew_membersCreateManyCrewsInputEnvelope
    set?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    disconnect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    delete?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    update?: crew_membersUpdateWithWhereUniqueWithoutCrewsInput | crew_membersUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: crew_membersUpdateManyWithWhereWithoutCrewsInput | crew_membersUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
  }

  export type work_order_crewUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<work_order_crewCreateWithoutCrewsInput, work_order_crewUncheckedCreateWithoutCrewsInput> | work_order_crewCreateWithoutCrewsInput[] | work_order_crewUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutCrewsInput | work_order_crewCreateOrConnectWithoutCrewsInput[]
    upsert?: work_order_crewUpsertWithWhereUniqueWithoutCrewsInput | work_order_crewUpsertWithWhereUniqueWithoutCrewsInput[]
    createMany?: work_order_crewCreateManyCrewsInputEnvelope
    set?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    disconnect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    delete?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    update?: work_order_crewUpdateWithWhereUniqueWithoutCrewsInput | work_order_crewUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: work_order_crewUpdateManyWithWhereWithoutCrewsInput | work_order_crewUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: work_order_crewScalarWhereInput | work_order_crewScalarWhereInput[]
  }

  export type crew_membersUncheckedUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<crew_membersCreateWithoutCrewsInput, crew_membersUncheckedCreateWithoutCrewsInput> | crew_membersCreateWithoutCrewsInput[] | crew_membersUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: crew_membersCreateOrConnectWithoutCrewsInput | crew_membersCreateOrConnectWithoutCrewsInput[]
    upsert?: crew_membersUpsertWithWhereUniqueWithoutCrewsInput | crew_membersUpsertWithWhereUniqueWithoutCrewsInput[]
    createMany?: crew_membersCreateManyCrewsInputEnvelope
    set?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    disconnect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    delete?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    connect?: crew_membersWhereUniqueInput | crew_membersWhereUniqueInput[]
    update?: crew_membersUpdateWithWhereUniqueWithoutCrewsInput | crew_membersUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: crew_membersUpdateManyWithWhereWithoutCrewsInput | crew_membersUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
  }

  export type work_order_crewUncheckedUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<work_order_crewCreateWithoutCrewsInput, work_order_crewUncheckedCreateWithoutCrewsInput> | work_order_crewCreateWithoutCrewsInput[] | work_order_crewUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutCrewsInput | work_order_crewCreateOrConnectWithoutCrewsInput[]
    upsert?: work_order_crewUpsertWithWhereUniqueWithoutCrewsInput | work_order_crewUpsertWithWhereUniqueWithoutCrewsInput[]
    createMany?: work_order_crewCreateManyCrewsInputEnvelope
    set?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    disconnect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    delete?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    update?: work_order_crewUpdateWithWhereUniqueWithoutCrewsInput | work_order_crewUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: work_order_crewUpdateManyWithWhereWithoutCrewsInput | work_order_crewUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: work_order_crewScalarWhereInput | work_order_crewScalarWhereInput[]
  }

  export type organizationsCreateNestedOneWithoutCrew_membersInput = {
    create?: XOR<organizationsCreateWithoutCrew_membersInput, organizationsUncheckedCreateWithoutCrew_membersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCrew_membersInput
    connect?: organizationsWhereUniqueInput
  }

  export type crewsCreateNestedOneWithoutCrew_membersInput = {
    create?: XOR<crewsCreateWithoutCrew_membersInput, crewsUncheckedCreateWithoutCrew_membersInput>
    connectOrCreate?: crewsCreateOrConnectWithoutCrew_membersInput
    connect?: crewsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCrew_membersInput = {
    create?: XOR<usersCreateWithoutCrew_membersInput, usersUncheckedCreateWithoutCrew_membersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCrew_membersInput
    connect?: usersWhereUniqueInput
  }

  export type organizationsUpdateOneRequiredWithoutCrew_membersNestedInput = {
    create?: XOR<organizationsCreateWithoutCrew_membersInput, organizationsUncheckedCreateWithoutCrew_membersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCrew_membersInput
    upsert?: organizationsUpsertWithoutCrew_membersInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutCrew_membersInput, organizationsUpdateWithoutCrew_membersInput>, organizationsUncheckedUpdateWithoutCrew_membersInput>
  }

  export type crewsUpdateOneRequiredWithoutCrew_membersNestedInput = {
    create?: XOR<crewsCreateWithoutCrew_membersInput, crewsUncheckedCreateWithoutCrew_membersInput>
    connectOrCreate?: crewsCreateOrConnectWithoutCrew_membersInput
    upsert?: crewsUpsertWithoutCrew_membersInput
    connect?: crewsWhereUniqueInput
    update?: XOR<XOR<crewsUpdateToOneWithWhereWithoutCrew_membersInput, crewsUpdateWithoutCrew_membersInput>, crewsUncheckedUpdateWithoutCrew_membersInput>
  }

  export type usersUpdateOneRequiredWithoutCrew_membersNestedInput = {
    create?: XOR<usersCreateWithoutCrew_membersInput, usersUncheckedCreateWithoutCrew_membersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCrew_membersInput
    upsert?: usersUpsertWithoutCrew_membersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCrew_membersInput, usersUpdateWithoutCrew_membersInput>, usersUncheckedUpdateWithoutCrew_membersInput>
  }

  export type organizationsCreateNestedOneWithoutEquipmentsInput = {
    create?: XOR<organizationsCreateWithoutEquipmentsInput, organizationsUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutEquipmentsInput
    connect?: organizationsWhereUniqueInput
  }

  export type EnumEqupmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EqupmentStatus
  }

  export type organizationsUpdateOneRequiredWithoutEquipmentsNestedInput = {
    create?: XOR<organizationsCreateWithoutEquipmentsInput, organizationsUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutEquipmentsInput
    upsert?: organizationsUpsertWithoutEquipmentsInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutEquipmentsInput, organizationsUpdateWithoutEquipmentsInput>, organizationsUncheckedUpdateWithoutEquipmentsInput>
  }

  export type organizationsCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<organizationsCreateWithoutCompaniesInput, organizationsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCompaniesInput
    connect?: organizationsWhereUniqueInput
  }

  export type customersCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<customersCreateWithoutCompaniesInput, customersUncheckedCreateWithoutCompaniesInput> | customersCreateWithoutCompaniesInput[] | customersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: customersCreateOrConnectWithoutCompaniesInput | customersCreateOrConnectWithoutCompaniesInput[]
    createMany?: customersCreateManyCompaniesInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type work_ordersCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<work_ordersCreateWithoutCompaniesInput, work_ordersUncheckedCreateWithoutCompaniesInput> | work_ordersCreateWithoutCompaniesInput[] | work_ordersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCompaniesInput | work_ordersCreateOrConnectWithoutCompaniesInput[]
    createMany?: work_ordersCreateManyCompaniesInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type customersUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<customersCreateWithoutCompaniesInput, customersUncheckedCreateWithoutCompaniesInput> | customersCreateWithoutCompaniesInput[] | customersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: customersCreateOrConnectWithoutCompaniesInput | customersCreateOrConnectWithoutCompaniesInput[]
    createMany?: customersCreateManyCompaniesInputEnvelope
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
  }

  export type work_ordersUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<work_ordersCreateWithoutCompaniesInput, work_ordersUncheckedCreateWithoutCompaniesInput> | work_ordersCreateWithoutCompaniesInput[] | work_ordersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCompaniesInput | work_ordersCreateOrConnectWithoutCompaniesInput[]
    createMany?: work_ordersCreateManyCompaniesInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type organizationsUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<organizationsCreateWithoutCompaniesInput, organizationsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCompaniesInput
    upsert?: organizationsUpsertWithoutCompaniesInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutCompaniesInput, organizationsUpdateWithoutCompaniesInput>, organizationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type customersUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<customersCreateWithoutCompaniesInput, customersUncheckedCreateWithoutCompaniesInput> | customersCreateWithoutCompaniesInput[] | customersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: customersCreateOrConnectWithoutCompaniesInput | customersCreateOrConnectWithoutCompaniesInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutCompaniesInput | customersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: customersCreateManyCompaniesInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutCompaniesInput | customersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: customersUpdateManyWithWhereWithoutCompaniesInput | customersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type work_ordersUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<work_ordersCreateWithoutCompaniesInput, work_ordersUncheckedCreateWithoutCompaniesInput> | work_ordersCreateWithoutCompaniesInput[] | work_ordersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCompaniesInput | work_ordersCreateOrConnectWithoutCompaniesInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutCompaniesInput | work_ordersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: work_ordersCreateManyCompaniesInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutCompaniesInput | work_ordersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutCompaniesInput | work_ordersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type customersUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<customersCreateWithoutCompaniesInput, customersUncheckedCreateWithoutCompaniesInput> | customersCreateWithoutCompaniesInput[] | customersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: customersCreateOrConnectWithoutCompaniesInput | customersCreateOrConnectWithoutCompaniesInput[]
    upsert?: customersUpsertWithWhereUniqueWithoutCompaniesInput | customersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: customersCreateManyCompaniesInputEnvelope
    set?: customersWhereUniqueInput | customersWhereUniqueInput[]
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[]
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[]
    update?: customersUpdateWithWhereUniqueWithoutCompaniesInput | customersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: customersUpdateManyWithWhereWithoutCompaniesInput | customersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[]
  }

  export type work_ordersUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<work_ordersCreateWithoutCompaniesInput, work_ordersUncheckedCreateWithoutCompaniesInput> | work_ordersCreateWithoutCompaniesInput[] | work_ordersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCompaniesInput | work_ordersCreateOrConnectWithoutCompaniesInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutCompaniesInput | work_ordersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: work_ordersCreateManyCompaniesInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutCompaniesInput | work_ordersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutCompaniesInput | work_ordersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type organizationsCreateNestedOneWithoutCustomersInput = {
    create?: XOR<organizationsCreateWithoutCustomersInput, organizationsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCustomersInput
    connect?: organizationsWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutCustomersInput = {
    create?: XOR<companiesCreateWithoutCustomersInput, companiesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCustomersInput
    connect?: companiesWhereUniqueInput
  }

  export type assetsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<assetsCreateWithoutCustomersInput, assetsUncheckedCreateWithoutCustomersInput> | assetsCreateWithoutCustomersInput[] | assetsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutCustomersInput | assetsCreateOrConnectWithoutCustomersInput[]
    createMany?: assetsCreateManyCustomersInputEnvelope
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
  }

  export type work_ordersCreateNestedManyWithoutCustomersInput = {
    create?: XOR<work_ordersCreateWithoutCustomersInput, work_ordersUncheckedCreateWithoutCustomersInput> | work_ordersCreateWithoutCustomersInput[] | work_ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCustomersInput | work_ordersCreateOrConnectWithoutCustomersInput[]
    createMany?: work_ordersCreateManyCustomersInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type assetsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<assetsCreateWithoutCustomersInput, assetsUncheckedCreateWithoutCustomersInput> | assetsCreateWithoutCustomersInput[] | assetsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutCustomersInput | assetsCreateOrConnectWithoutCustomersInput[]
    createMany?: assetsCreateManyCustomersInputEnvelope
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
  }

  export type work_ordersUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<work_ordersCreateWithoutCustomersInput, work_ordersUncheckedCreateWithoutCustomersInput> | work_ordersCreateWithoutCustomersInput[] | work_ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCustomersInput | work_ordersCreateOrConnectWithoutCustomersInput[]
    createMany?: work_ordersCreateManyCustomersInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type organizationsUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<organizationsCreateWithoutCustomersInput, organizationsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCustomersInput
    upsert?: organizationsUpsertWithoutCustomersInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutCustomersInput, organizationsUpdateWithoutCustomersInput>, organizationsUncheckedUpdateWithoutCustomersInput>
  }

  export type companiesUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<companiesCreateWithoutCustomersInput, companiesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCustomersInput
    upsert?: companiesUpsertWithoutCustomersInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCustomersInput, companiesUpdateWithoutCustomersInput>, companiesUncheckedUpdateWithoutCustomersInput>
  }

  export type assetsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<assetsCreateWithoutCustomersInput, assetsUncheckedCreateWithoutCustomersInput> | assetsCreateWithoutCustomersInput[] | assetsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutCustomersInput | assetsCreateOrConnectWithoutCustomersInput[]
    upsert?: assetsUpsertWithWhereUniqueWithoutCustomersInput | assetsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: assetsCreateManyCustomersInputEnvelope
    set?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    disconnect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    delete?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    update?: assetsUpdateWithWhereUniqueWithoutCustomersInput | assetsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: assetsUpdateManyWithWhereWithoutCustomersInput | assetsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: assetsScalarWhereInput | assetsScalarWhereInput[]
  }

  export type work_ordersUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<work_ordersCreateWithoutCustomersInput, work_ordersUncheckedCreateWithoutCustomersInput> | work_ordersCreateWithoutCustomersInput[] | work_ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCustomersInput | work_ordersCreateOrConnectWithoutCustomersInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutCustomersInput | work_ordersUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: work_ordersCreateManyCustomersInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutCustomersInput | work_ordersUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutCustomersInput | work_ordersUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type assetsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<assetsCreateWithoutCustomersInput, assetsUncheckedCreateWithoutCustomersInput> | assetsCreateWithoutCustomersInput[] | assetsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: assetsCreateOrConnectWithoutCustomersInput | assetsCreateOrConnectWithoutCustomersInput[]
    upsert?: assetsUpsertWithWhereUniqueWithoutCustomersInput | assetsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: assetsCreateManyCustomersInputEnvelope
    set?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    disconnect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    delete?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    connect?: assetsWhereUniqueInput | assetsWhereUniqueInput[]
    update?: assetsUpdateWithWhereUniqueWithoutCustomersInput | assetsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: assetsUpdateManyWithWhereWithoutCustomersInput | assetsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: assetsScalarWhereInput | assetsScalarWhereInput[]
  }

  export type work_ordersUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<work_ordersCreateWithoutCustomersInput, work_ordersUncheckedCreateWithoutCustomersInput> | work_ordersCreateWithoutCustomersInput[] | work_ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutCustomersInput | work_ordersCreateOrConnectWithoutCustomersInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutCustomersInput | work_ordersUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: work_ordersCreateManyCustomersInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutCustomersInput | work_ordersUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutCustomersInput | work_ordersUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type organizationsCreateNestedOneWithoutServicesInput = {
    create?: XOR<organizationsCreateWithoutServicesInput, organizationsUncheckedCreateWithoutServicesInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutServicesInput
    connect?: organizationsWhereUniqueInput
  }

  export type work_order_servicesCreateNestedManyWithoutServicesInput = {
    create?: XOR<work_order_servicesCreateWithoutServicesInput, work_order_servicesUncheckedCreateWithoutServicesInput> | work_order_servicesCreateWithoutServicesInput[] | work_order_servicesUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutServicesInput | work_order_servicesCreateOrConnectWithoutServicesInput[]
    createMany?: work_order_servicesCreateManyServicesInputEnvelope
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
  }

  export type invoice_itemsCreateNestedManyWithoutServicesInput = {
    create?: XOR<invoice_itemsCreateWithoutServicesInput, invoice_itemsUncheckedCreateWithoutServicesInput> | invoice_itemsCreateWithoutServicesInput[] | invoice_itemsUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutServicesInput | invoice_itemsCreateOrConnectWithoutServicesInput[]
    createMany?: invoice_itemsCreateManyServicesInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type work_order_servicesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<work_order_servicesCreateWithoutServicesInput, work_order_servicesUncheckedCreateWithoutServicesInput> | work_order_servicesCreateWithoutServicesInput[] | work_order_servicesUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutServicesInput | work_order_servicesCreateOrConnectWithoutServicesInput[]
    createMany?: work_order_servicesCreateManyServicesInputEnvelope
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
  }

  export type invoice_itemsUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<invoice_itemsCreateWithoutServicesInput, invoice_itemsUncheckedCreateWithoutServicesInput> | invoice_itemsCreateWithoutServicesInput[] | invoice_itemsUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutServicesInput | invoice_itemsCreateOrConnectWithoutServicesInput[]
    createMany?: invoice_itemsCreateManyServicesInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type organizationsUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<organizationsCreateWithoutServicesInput, organizationsUncheckedCreateWithoutServicesInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutServicesInput
    upsert?: organizationsUpsertWithoutServicesInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutServicesInput, organizationsUpdateWithoutServicesInput>, organizationsUncheckedUpdateWithoutServicesInput>
  }

  export type work_order_servicesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<work_order_servicesCreateWithoutServicesInput, work_order_servicesUncheckedCreateWithoutServicesInput> | work_order_servicesCreateWithoutServicesInput[] | work_order_servicesUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutServicesInput | work_order_servicesCreateOrConnectWithoutServicesInput[]
    upsert?: work_order_servicesUpsertWithWhereUniqueWithoutServicesInput | work_order_servicesUpsertWithWhereUniqueWithoutServicesInput[]
    createMany?: work_order_servicesCreateManyServicesInputEnvelope
    set?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    disconnect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    delete?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    update?: work_order_servicesUpdateWithWhereUniqueWithoutServicesInput | work_order_servicesUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: work_order_servicesUpdateManyWithWhereWithoutServicesInput | work_order_servicesUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: work_order_servicesScalarWhereInput | work_order_servicesScalarWhereInput[]
  }

  export type invoice_itemsUpdateManyWithoutServicesNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutServicesInput, invoice_itemsUncheckedCreateWithoutServicesInput> | invoice_itemsCreateWithoutServicesInput[] | invoice_itemsUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutServicesInput | invoice_itemsCreateOrConnectWithoutServicesInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutServicesInput | invoice_itemsUpsertWithWhereUniqueWithoutServicesInput[]
    createMany?: invoice_itemsCreateManyServicesInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutServicesInput | invoice_itemsUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutServicesInput | invoice_itemsUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type work_order_servicesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<work_order_servicesCreateWithoutServicesInput, work_order_servicesUncheckedCreateWithoutServicesInput> | work_order_servicesCreateWithoutServicesInput[] | work_order_servicesUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutServicesInput | work_order_servicesCreateOrConnectWithoutServicesInput[]
    upsert?: work_order_servicesUpsertWithWhereUniqueWithoutServicesInput | work_order_servicesUpsertWithWhereUniqueWithoutServicesInput[]
    createMany?: work_order_servicesCreateManyServicesInputEnvelope
    set?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    disconnect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    delete?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    update?: work_order_servicesUpdateWithWhereUniqueWithoutServicesInput | work_order_servicesUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: work_order_servicesUpdateManyWithWhereWithoutServicesInput | work_order_servicesUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: work_order_servicesScalarWhereInput | work_order_servicesScalarWhereInput[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutServicesInput, invoice_itemsUncheckedCreateWithoutServicesInput> | invoice_itemsCreateWithoutServicesInput[] | invoice_itemsUncheckedCreateWithoutServicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutServicesInput | invoice_itemsCreateOrConnectWithoutServicesInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutServicesInput | invoice_itemsUpsertWithWhereUniqueWithoutServicesInput[]
    createMany?: invoice_itemsCreateManyServicesInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutServicesInput | invoice_itemsUpdateWithWhereUniqueWithoutServicesInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutServicesInput | invoice_itemsUpdateManyWithWhereWithoutServicesInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type organizationsCreateNestedOneWithoutAssetsInput = {
    create?: XOR<organizationsCreateWithoutAssetsInput, organizationsUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutAssetsInput
    connect?: organizationsWhereUniqueInput
  }

  export type customersCreateNestedOneWithoutAssetsInput = {
    create?: XOR<customersCreateWithoutAssetsInput, customersUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: customersCreateOrConnectWithoutAssetsInput
    connect?: customersWhereUniqueInput
  }

  export type work_ordersCreateNestedManyWithoutAssetsInput = {
    create?: XOR<work_ordersCreateWithoutAssetsInput, work_ordersUncheckedCreateWithoutAssetsInput> | work_ordersCreateWithoutAssetsInput[] | work_ordersUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutAssetsInput | work_ordersCreateOrConnectWithoutAssetsInput[]
    createMany?: work_ordersCreateManyAssetsInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type work_ordersUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<work_ordersCreateWithoutAssetsInput, work_ordersUncheckedCreateWithoutAssetsInput> | work_ordersCreateWithoutAssetsInput[] | work_ordersUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutAssetsInput | work_ordersCreateOrConnectWithoutAssetsInput[]
    createMany?: work_ordersCreateManyAssetsInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type EnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus
  }

  export type organizationsUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<organizationsCreateWithoutAssetsInput, organizationsUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutAssetsInput
    upsert?: organizationsUpsertWithoutAssetsInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutAssetsInput, organizationsUpdateWithoutAssetsInput>, organizationsUncheckedUpdateWithoutAssetsInput>
  }

  export type customersUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<customersCreateWithoutAssetsInput, customersUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: customersCreateOrConnectWithoutAssetsInput
    upsert?: customersUpsertWithoutAssetsInput
    connect?: customersWhereUniqueInput
    update?: XOR<XOR<customersUpdateToOneWithWhereWithoutAssetsInput, customersUpdateWithoutAssetsInput>, customersUncheckedUpdateWithoutAssetsInput>
  }

  export type work_ordersUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<work_ordersCreateWithoutAssetsInput, work_ordersUncheckedCreateWithoutAssetsInput> | work_ordersCreateWithoutAssetsInput[] | work_ordersUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutAssetsInput | work_ordersCreateOrConnectWithoutAssetsInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutAssetsInput | work_ordersUpsertWithWhereUniqueWithoutAssetsInput[]
    createMany?: work_ordersCreateManyAssetsInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutAssetsInput | work_ordersUpdateWithWhereUniqueWithoutAssetsInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutAssetsInput | work_ordersUpdateManyWithWhereWithoutAssetsInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type work_ordersUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<work_ordersCreateWithoutAssetsInput, work_ordersUncheckedCreateWithoutAssetsInput> | work_ordersCreateWithoutAssetsInput[] | work_ordersUncheckedCreateWithoutAssetsInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutAssetsInput | work_ordersCreateOrConnectWithoutAssetsInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutAssetsInput | work_ordersUpsertWithWhereUniqueWithoutAssetsInput[]
    createMany?: work_ordersCreateManyAssetsInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutAssetsInput | work_ordersUpdateWithWhereUniqueWithoutAssetsInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutAssetsInput | work_ordersUpdateManyWithWhereWithoutAssetsInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type organizationsCreateNestedOneWithoutPartsInput = {
    create?: XOR<organizationsCreateWithoutPartsInput, organizationsUncheckedCreateWithoutPartsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutPartsInput
    connect?: organizationsWhereUniqueInput
  }

  export type invoice_itemsCreateNestedManyWithoutPartsInput = {
    create?: XOR<invoice_itemsCreateWithoutPartsInput, invoice_itemsUncheckedCreateWithoutPartsInput> | invoice_itemsCreateWithoutPartsInput[] | invoice_itemsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPartsInput | invoice_itemsCreateOrConnectWithoutPartsInput[]
    createMany?: invoice_itemsCreateManyPartsInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type invoice_itemsUncheckedCreateNestedManyWithoutPartsInput = {
    create?: XOR<invoice_itemsCreateWithoutPartsInput, invoice_itemsUncheckedCreateWithoutPartsInput> | invoice_itemsCreateWithoutPartsInput[] | invoice_itemsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPartsInput | invoice_itemsCreateOrConnectWithoutPartsInput[]
    createMany?: invoice_itemsCreateManyPartsInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type organizationsUpdateOneRequiredWithoutPartsNestedInput = {
    create?: XOR<organizationsCreateWithoutPartsInput, organizationsUncheckedCreateWithoutPartsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutPartsInput
    upsert?: organizationsUpsertWithoutPartsInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutPartsInput, organizationsUpdateWithoutPartsInput>, organizationsUncheckedUpdateWithoutPartsInput>
  }

  export type invoice_itemsUpdateManyWithoutPartsNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutPartsInput, invoice_itemsUncheckedCreateWithoutPartsInput> | invoice_itemsCreateWithoutPartsInput[] | invoice_itemsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPartsInput | invoice_itemsCreateOrConnectWithoutPartsInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutPartsInput | invoice_itemsUpsertWithWhereUniqueWithoutPartsInput[]
    createMany?: invoice_itemsCreateManyPartsInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutPartsInput | invoice_itemsUpdateWithWhereUniqueWithoutPartsInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutPartsInput | invoice_itemsUpdateManyWithWhereWithoutPartsInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutPartsNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutPartsInput, invoice_itemsUncheckedCreateWithoutPartsInput> | invoice_itemsCreateWithoutPartsInput[] | invoice_itemsUncheckedCreateWithoutPartsInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutPartsInput | invoice_itemsCreateOrConnectWithoutPartsInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutPartsInput | invoice_itemsUpsertWithWhereUniqueWithoutPartsInput[]
    createMany?: invoice_itemsCreateManyPartsInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutPartsInput | invoice_itemsUpdateWithWhereUniqueWithoutPartsInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutPartsInput | invoice_itemsUpdateManyWithWhereWithoutPartsInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type organizationsCreateNestedOneWithoutMaintenance_plansInput = {
    create?: XOR<organizationsCreateWithoutMaintenance_plansInput, organizationsUncheckedCreateWithoutMaintenance_plansInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutMaintenance_plansInput
    connect?: organizationsWhereUniqueInput
  }

  export type maintenance_plan_assetsCreateNestedManyWithoutMaintenance_plansInput = {
    create?: XOR<maintenance_plan_assetsCreateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput> | maintenance_plan_assetsCreateWithoutMaintenance_plansInput[] | maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput | maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput[]
    createMany?: maintenance_plan_assetsCreateManyMaintenance_plansInputEnvelope
    connect?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
  }

  export type work_ordersCreateNestedManyWithoutMaintenance_plansInput = {
    create?: XOR<work_ordersCreateWithoutMaintenance_plansInput, work_ordersUncheckedCreateWithoutMaintenance_plansInput> | work_ordersCreateWithoutMaintenance_plansInput[] | work_ordersUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutMaintenance_plansInput | work_ordersCreateOrConnectWithoutMaintenance_plansInput[]
    createMany?: work_ordersCreateManyMaintenance_plansInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type maintenance_plan_assetsUncheckedCreateNestedManyWithoutMaintenance_plansInput = {
    create?: XOR<maintenance_plan_assetsCreateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput> | maintenance_plan_assetsCreateWithoutMaintenance_plansInput[] | maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput | maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput[]
    createMany?: maintenance_plan_assetsCreateManyMaintenance_plansInputEnvelope
    connect?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
  }

  export type work_ordersUncheckedCreateNestedManyWithoutMaintenance_plansInput = {
    create?: XOR<work_ordersCreateWithoutMaintenance_plansInput, work_ordersUncheckedCreateWithoutMaintenance_plansInput> | work_ordersCreateWithoutMaintenance_plansInput[] | work_ordersUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutMaintenance_plansInput | work_ordersCreateOrConnectWithoutMaintenance_plansInput[]
    createMany?: work_ordersCreateManyMaintenance_plansInputEnvelope
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
  }

  export type EnumFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.Frequency
  }

  export type EnumFrequencyUnitTypeFieldUpdateOperationsInput = {
    set?: $Enums.FrequencyUnitType
  }

  export type organizationsUpdateOneRequiredWithoutMaintenance_plansNestedInput = {
    create?: XOR<organizationsCreateWithoutMaintenance_plansInput, organizationsUncheckedCreateWithoutMaintenance_plansInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutMaintenance_plansInput
    upsert?: organizationsUpsertWithoutMaintenance_plansInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutMaintenance_plansInput, organizationsUpdateWithoutMaintenance_plansInput>, organizationsUncheckedUpdateWithoutMaintenance_plansInput>
  }

  export type maintenance_plan_assetsUpdateManyWithoutMaintenance_plansNestedInput = {
    create?: XOR<maintenance_plan_assetsCreateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput> | maintenance_plan_assetsCreateWithoutMaintenance_plansInput[] | maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput | maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput[]
    upsert?: maintenance_plan_assetsUpsertWithWhereUniqueWithoutMaintenance_plansInput | maintenance_plan_assetsUpsertWithWhereUniqueWithoutMaintenance_plansInput[]
    createMany?: maintenance_plan_assetsCreateManyMaintenance_plansInputEnvelope
    set?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    disconnect?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    delete?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    connect?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    update?: maintenance_plan_assetsUpdateWithWhereUniqueWithoutMaintenance_plansInput | maintenance_plan_assetsUpdateWithWhereUniqueWithoutMaintenance_plansInput[]
    updateMany?: maintenance_plan_assetsUpdateManyWithWhereWithoutMaintenance_plansInput | maintenance_plan_assetsUpdateManyWithWhereWithoutMaintenance_plansInput[]
    deleteMany?: maintenance_plan_assetsScalarWhereInput | maintenance_plan_assetsScalarWhereInput[]
  }

  export type work_ordersUpdateManyWithoutMaintenance_plansNestedInput = {
    create?: XOR<work_ordersCreateWithoutMaintenance_plansInput, work_ordersUncheckedCreateWithoutMaintenance_plansInput> | work_ordersCreateWithoutMaintenance_plansInput[] | work_ordersUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutMaintenance_plansInput | work_ordersCreateOrConnectWithoutMaintenance_plansInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutMaintenance_plansInput | work_ordersUpsertWithWhereUniqueWithoutMaintenance_plansInput[]
    createMany?: work_ordersCreateManyMaintenance_plansInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutMaintenance_plansInput | work_ordersUpdateWithWhereUniqueWithoutMaintenance_plansInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutMaintenance_plansInput | work_ordersUpdateManyWithWhereWithoutMaintenance_plansInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type maintenance_plan_assetsUncheckedUpdateManyWithoutMaintenance_plansNestedInput = {
    create?: XOR<maintenance_plan_assetsCreateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput> | maintenance_plan_assetsCreateWithoutMaintenance_plansInput[] | maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput | maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput[]
    upsert?: maintenance_plan_assetsUpsertWithWhereUniqueWithoutMaintenance_plansInput | maintenance_plan_assetsUpsertWithWhereUniqueWithoutMaintenance_plansInput[]
    createMany?: maintenance_plan_assetsCreateManyMaintenance_plansInputEnvelope
    set?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    disconnect?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    delete?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    connect?: maintenance_plan_assetsWhereUniqueInput | maintenance_plan_assetsWhereUniqueInput[]
    update?: maintenance_plan_assetsUpdateWithWhereUniqueWithoutMaintenance_plansInput | maintenance_plan_assetsUpdateWithWhereUniqueWithoutMaintenance_plansInput[]
    updateMany?: maintenance_plan_assetsUpdateManyWithWhereWithoutMaintenance_plansInput | maintenance_plan_assetsUpdateManyWithWhereWithoutMaintenance_plansInput[]
    deleteMany?: maintenance_plan_assetsScalarWhereInput | maintenance_plan_assetsScalarWhereInput[]
  }

  export type work_ordersUncheckedUpdateManyWithoutMaintenance_plansNestedInput = {
    create?: XOR<work_ordersCreateWithoutMaintenance_plansInput, work_ordersUncheckedCreateWithoutMaintenance_plansInput> | work_ordersCreateWithoutMaintenance_plansInput[] | work_ordersUncheckedCreateWithoutMaintenance_plansInput[]
    connectOrCreate?: work_ordersCreateOrConnectWithoutMaintenance_plansInput | work_ordersCreateOrConnectWithoutMaintenance_plansInput[]
    upsert?: work_ordersUpsertWithWhereUniqueWithoutMaintenance_plansInput | work_ordersUpsertWithWhereUniqueWithoutMaintenance_plansInput[]
    createMany?: work_ordersCreateManyMaintenance_plansInputEnvelope
    set?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    disconnect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    delete?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    connect?: work_ordersWhereUniqueInput | work_ordersWhereUniqueInput[]
    update?: work_ordersUpdateWithWhereUniqueWithoutMaintenance_plansInput | work_ordersUpdateWithWhereUniqueWithoutMaintenance_plansInput[]
    updateMany?: work_ordersUpdateManyWithWhereWithoutMaintenance_plansInput | work_ordersUpdateManyWithWhereWithoutMaintenance_plansInput[]
    deleteMany?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
  }

  export type maintenance_plansCreateNestedOneWithoutMaintenance_plan_assetsInput = {
    create?: XOR<maintenance_plansCreateWithoutMaintenance_plan_assetsInput, maintenance_plansUncheckedCreateWithoutMaintenance_plan_assetsInput>
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutMaintenance_plan_assetsInput
    connect?: maintenance_plansWhereUniqueInput
  }

  export type maintenance_plansUpdateOneRequiredWithoutMaintenance_plan_assetsNestedInput = {
    create?: XOR<maintenance_plansCreateWithoutMaintenance_plan_assetsInput, maintenance_plansUncheckedCreateWithoutMaintenance_plan_assetsInput>
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutMaintenance_plan_assetsInput
    upsert?: maintenance_plansUpsertWithoutMaintenance_plan_assetsInput
    connect?: maintenance_plansWhereUniqueInput
    update?: XOR<XOR<maintenance_plansUpdateToOneWithWhereWithoutMaintenance_plan_assetsInput, maintenance_plansUpdateWithoutMaintenance_plan_assetsInput>, maintenance_plansUncheckedUpdateWithoutMaintenance_plan_assetsInput>
  }

  export type organizationsCreateNestedOneWithoutWork_ordersInput = {
    create?: XOR<organizationsCreateWithoutWork_ordersInput, organizationsUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutWork_ordersInput
    connect?: organizationsWhereUniqueInput
  }

  export type customersCreateNestedOneWithoutWork_ordersInput = {
    create?: XOR<customersCreateWithoutWork_ordersInput, customersUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: customersCreateOrConnectWithoutWork_ordersInput
    connect?: customersWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutWork_ordersInput = {
    create?: XOR<companiesCreateWithoutWork_ordersInput, companiesUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutWork_ordersInput
    connect?: companiesWhereUniqueInput
  }

  export type assetsCreateNestedOneWithoutWork_ordersInput = {
    create?: XOR<assetsCreateWithoutWork_ordersInput, assetsUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: assetsCreateOrConnectWithoutWork_ordersInput
    connect?: assetsWhereUniqueInput
  }

  export type maintenance_plansCreateNestedOneWithoutWork_ordersInput = {
    create?: XOR<maintenance_plansCreateWithoutWork_ordersInput, maintenance_plansUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutWork_ordersInput
    connect?: maintenance_plansWhereUniqueInput
  }

  export type work_order_servicesCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_servicesCreateWithoutWork_ordersInput, work_order_servicesUncheckedCreateWithoutWork_ordersInput> | work_order_servicesCreateWithoutWork_ordersInput[] | work_order_servicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutWork_ordersInput | work_order_servicesCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_servicesCreateManyWork_ordersInputEnvelope
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
  }

  export type work_order_tasksCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_tasksCreateWithoutWork_ordersInput, work_order_tasksUncheckedCreateWithoutWork_ordersInput> | work_order_tasksCreateWithoutWork_ordersInput[] | work_order_tasksUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_tasksCreateOrConnectWithoutWork_ordersInput | work_order_tasksCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_tasksCreateManyWork_ordersInputEnvelope
    connect?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
  }

  export type work_order_assetsCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_assetsCreateWithoutWork_ordersInput, work_order_assetsUncheckedCreateWithoutWork_ordersInput> | work_order_assetsCreateWithoutWork_ordersInput[] | work_order_assetsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_assetsCreateOrConnectWithoutWork_ordersInput | work_order_assetsCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_assetsCreateManyWork_ordersInputEnvelope
    connect?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
  }

  export type work_order_crewCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_crewCreateWithoutWork_ordersInput, work_order_crewUncheckedCreateWithoutWork_ordersInput> | work_order_crewCreateWithoutWork_ordersInput[] | work_order_crewUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutWork_ordersInput | work_order_crewCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_crewCreateManyWork_ordersInputEnvelope
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
  }

  export type work_order_approvalsCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_approvalsCreateWithoutWork_ordersInput, work_order_approvalsUncheckedCreateWithoutWork_ordersInput> | work_order_approvalsCreateWithoutWork_ordersInput[] | work_order_approvalsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_approvalsCreateOrConnectWithoutWork_ordersInput | work_order_approvalsCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_approvalsCreateManyWork_ordersInputEnvelope
    connect?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
  }

  export type invoicesCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<invoicesCreateWithoutWork_ordersInput, invoicesUncheckedCreateWithoutWork_ordersInput> | invoicesCreateWithoutWork_ordersInput[] | invoicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutWork_ordersInput | invoicesCreateOrConnectWithoutWork_ordersInput[]
    createMany?: invoicesCreateManyWork_ordersInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_servicesCreateWithoutWork_ordersInput, work_order_servicesUncheckedCreateWithoutWork_ordersInput> | work_order_servicesCreateWithoutWork_ordersInput[] | work_order_servicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutWork_ordersInput | work_order_servicesCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_servicesCreateManyWork_ordersInputEnvelope
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
  }

  export type work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_tasksCreateWithoutWork_ordersInput, work_order_tasksUncheckedCreateWithoutWork_ordersInput> | work_order_tasksCreateWithoutWork_ordersInput[] | work_order_tasksUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_tasksCreateOrConnectWithoutWork_ordersInput | work_order_tasksCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_tasksCreateManyWork_ordersInputEnvelope
    connect?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
  }

  export type work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_assetsCreateWithoutWork_ordersInput, work_order_assetsUncheckedCreateWithoutWork_ordersInput> | work_order_assetsCreateWithoutWork_ordersInput[] | work_order_assetsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_assetsCreateOrConnectWithoutWork_ordersInput | work_order_assetsCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_assetsCreateManyWork_ordersInputEnvelope
    connect?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
  }

  export type work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_crewCreateWithoutWork_ordersInput, work_order_crewUncheckedCreateWithoutWork_ordersInput> | work_order_crewCreateWithoutWork_ordersInput[] | work_order_crewUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutWork_ordersInput | work_order_crewCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_crewCreateManyWork_ordersInputEnvelope
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
  }

  export type work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<work_order_approvalsCreateWithoutWork_ordersInput, work_order_approvalsUncheckedCreateWithoutWork_ordersInput> | work_order_approvalsCreateWithoutWork_ordersInput[] | work_order_approvalsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_approvalsCreateOrConnectWithoutWork_ordersInput | work_order_approvalsCreateOrConnectWithoutWork_ordersInput[]
    createMany?: work_order_approvalsCreateManyWork_ordersInputEnvelope
    connect?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
  }

  export type invoicesUncheckedCreateNestedManyWithoutWork_ordersInput = {
    create?: XOR<invoicesCreateWithoutWork_ordersInput, invoicesUncheckedCreateWithoutWork_ordersInput> | invoicesCreateWithoutWork_ordersInput[] | invoicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutWork_ordersInput | invoicesCreateOrConnectWithoutWork_ordersInput[]
    createMany?: invoicesCreateManyWork_ordersInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type EnumPrioirtyFieldUpdateOperationsInput = {
    set?: $Enums.Prioirty
  }

  export type EnumWorkOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkOrderStatus
  }

  export type organizationsUpdateOneRequiredWithoutWork_ordersNestedInput = {
    create?: XOR<organizationsCreateWithoutWork_ordersInput, organizationsUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutWork_ordersInput
    upsert?: organizationsUpsertWithoutWork_ordersInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<XOR<organizationsUpdateToOneWithWhereWithoutWork_ordersInput, organizationsUpdateWithoutWork_ordersInput>, organizationsUncheckedUpdateWithoutWork_ordersInput>
  }

  export type customersUpdateOneRequiredWithoutWork_ordersNestedInput = {
    create?: XOR<customersCreateWithoutWork_ordersInput, customersUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: customersCreateOrConnectWithoutWork_ordersInput
    upsert?: customersUpsertWithoutWork_ordersInput
    connect?: customersWhereUniqueInput
    update?: XOR<XOR<customersUpdateToOneWithWhereWithoutWork_ordersInput, customersUpdateWithoutWork_ordersInput>, customersUncheckedUpdateWithoutWork_ordersInput>
  }

  export type companiesUpdateOneRequiredWithoutWork_ordersNestedInput = {
    create?: XOR<companiesCreateWithoutWork_ordersInput, companiesUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutWork_ordersInput
    upsert?: companiesUpsertWithoutWork_ordersInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutWork_ordersInput, companiesUpdateWithoutWork_ordersInput>, companiesUncheckedUpdateWithoutWork_ordersInput>
  }

  export type assetsUpdateOneRequiredWithoutWork_ordersNestedInput = {
    create?: XOR<assetsCreateWithoutWork_ordersInput, assetsUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: assetsCreateOrConnectWithoutWork_ordersInput
    upsert?: assetsUpsertWithoutWork_ordersInput
    connect?: assetsWhereUniqueInput
    update?: XOR<XOR<assetsUpdateToOneWithWhereWithoutWork_ordersInput, assetsUpdateWithoutWork_ordersInput>, assetsUncheckedUpdateWithoutWork_ordersInput>
  }

  export type maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput = {
    create?: XOR<maintenance_plansCreateWithoutWork_ordersInput, maintenance_plansUncheckedCreateWithoutWork_ordersInput>
    connectOrCreate?: maintenance_plansCreateOrConnectWithoutWork_ordersInput
    upsert?: maintenance_plansUpsertWithoutWork_ordersInput
    connect?: maintenance_plansWhereUniqueInput
    update?: XOR<XOR<maintenance_plansUpdateToOneWithWhereWithoutWork_ordersInput, maintenance_plansUpdateWithoutWork_ordersInput>, maintenance_plansUncheckedUpdateWithoutWork_ordersInput>
  }

  export type work_order_servicesUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_servicesCreateWithoutWork_ordersInput, work_order_servicesUncheckedCreateWithoutWork_ordersInput> | work_order_servicesCreateWithoutWork_ordersInput[] | work_order_servicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutWork_ordersInput | work_order_servicesCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_servicesUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_servicesUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_servicesCreateManyWork_ordersInputEnvelope
    set?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    disconnect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    delete?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    update?: work_order_servicesUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_servicesUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_servicesUpdateManyWithWhereWithoutWork_ordersInput | work_order_servicesUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_servicesScalarWhereInput | work_order_servicesScalarWhereInput[]
  }

  export type work_order_tasksUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_tasksCreateWithoutWork_ordersInput, work_order_tasksUncheckedCreateWithoutWork_ordersInput> | work_order_tasksCreateWithoutWork_ordersInput[] | work_order_tasksUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_tasksCreateOrConnectWithoutWork_ordersInput | work_order_tasksCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_tasksUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_tasksUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_tasksCreateManyWork_ordersInputEnvelope
    set?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    disconnect?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    delete?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    connect?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    update?: work_order_tasksUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_tasksUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_tasksUpdateManyWithWhereWithoutWork_ordersInput | work_order_tasksUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_tasksScalarWhereInput | work_order_tasksScalarWhereInput[]
  }

  export type work_order_assetsUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_assetsCreateWithoutWork_ordersInput, work_order_assetsUncheckedCreateWithoutWork_ordersInput> | work_order_assetsCreateWithoutWork_ordersInput[] | work_order_assetsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_assetsCreateOrConnectWithoutWork_ordersInput | work_order_assetsCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_assetsUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_assetsUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_assetsCreateManyWork_ordersInputEnvelope
    set?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    disconnect?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    delete?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    connect?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    update?: work_order_assetsUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_assetsUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_assetsUpdateManyWithWhereWithoutWork_ordersInput | work_order_assetsUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_assetsScalarWhereInput | work_order_assetsScalarWhereInput[]
  }

  export type work_order_crewUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_crewCreateWithoutWork_ordersInput, work_order_crewUncheckedCreateWithoutWork_ordersInput> | work_order_crewCreateWithoutWork_ordersInput[] | work_order_crewUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutWork_ordersInput | work_order_crewCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_crewUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_crewUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_crewCreateManyWork_ordersInputEnvelope
    set?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    disconnect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    delete?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    update?: work_order_crewUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_crewUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_crewUpdateManyWithWhereWithoutWork_ordersInput | work_order_crewUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_crewScalarWhereInput | work_order_crewScalarWhereInput[]
  }

  export type work_order_approvalsUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_approvalsCreateWithoutWork_ordersInput, work_order_approvalsUncheckedCreateWithoutWork_ordersInput> | work_order_approvalsCreateWithoutWork_ordersInput[] | work_order_approvalsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_approvalsCreateOrConnectWithoutWork_ordersInput | work_order_approvalsCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_approvalsUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_approvalsUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_approvalsCreateManyWork_ordersInputEnvelope
    set?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    disconnect?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    delete?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    connect?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    update?: work_order_approvalsUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_approvalsUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_approvalsUpdateManyWithWhereWithoutWork_ordersInput | work_order_approvalsUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_approvalsScalarWhereInput | work_order_approvalsScalarWhereInput[]
  }

  export type invoicesUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<invoicesCreateWithoutWork_ordersInput, invoicesUncheckedCreateWithoutWork_ordersInput> | invoicesCreateWithoutWork_ordersInput[] | invoicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutWork_ordersInput | invoicesCreateOrConnectWithoutWork_ordersInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutWork_ordersInput | invoicesUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: invoicesCreateManyWork_ordersInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutWork_ordersInput | invoicesUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutWork_ordersInput | invoicesUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_servicesCreateWithoutWork_ordersInput, work_order_servicesUncheckedCreateWithoutWork_ordersInput> | work_order_servicesCreateWithoutWork_ordersInput[] | work_order_servicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_servicesCreateOrConnectWithoutWork_ordersInput | work_order_servicesCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_servicesUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_servicesUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_servicesCreateManyWork_ordersInputEnvelope
    set?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    disconnect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    delete?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    connect?: work_order_servicesWhereUniqueInput | work_order_servicesWhereUniqueInput[]
    update?: work_order_servicesUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_servicesUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_servicesUpdateManyWithWhereWithoutWork_ordersInput | work_order_servicesUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_servicesScalarWhereInput | work_order_servicesScalarWhereInput[]
  }

  export type work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_tasksCreateWithoutWork_ordersInput, work_order_tasksUncheckedCreateWithoutWork_ordersInput> | work_order_tasksCreateWithoutWork_ordersInput[] | work_order_tasksUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_tasksCreateOrConnectWithoutWork_ordersInput | work_order_tasksCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_tasksUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_tasksUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_tasksCreateManyWork_ordersInputEnvelope
    set?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    disconnect?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    delete?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    connect?: work_order_tasksWhereUniqueInput | work_order_tasksWhereUniqueInput[]
    update?: work_order_tasksUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_tasksUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_tasksUpdateManyWithWhereWithoutWork_ordersInput | work_order_tasksUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_tasksScalarWhereInput | work_order_tasksScalarWhereInput[]
  }

  export type work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_assetsCreateWithoutWork_ordersInput, work_order_assetsUncheckedCreateWithoutWork_ordersInput> | work_order_assetsCreateWithoutWork_ordersInput[] | work_order_assetsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_assetsCreateOrConnectWithoutWork_ordersInput | work_order_assetsCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_assetsUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_assetsUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_assetsCreateManyWork_ordersInputEnvelope
    set?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    disconnect?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    delete?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    connect?: work_order_assetsWhereUniqueInput | work_order_assetsWhereUniqueInput[]
    update?: work_order_assetsUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_assetsUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_assetsUpdateManyWithWhereWithoutWork_ordersInput | work_order_assetsUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_assetsScalarWhereInput | work_order_assetsScalarWhereInput[]
  }

  export type work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_crewCreateWithoutWork_ordersInput, work_order_crewUncheckedCreateWithoutWork_ordersInput> | work_order_crewCreateWithoutWork_ordersInput[] | work_order_crewUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_crewCreateOrConnectWithoutWork_ordersInput | work_order_crewCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_crewUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_crewUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_crewCreateManyWork_ordersInputEnvelope
    set?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    disconnect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    delete?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    connect?: work_order_crewWhereUniqueInput | work_order_crewWhereUniqueInput[]
    update?: work_order_crewUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_crewUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_crewUpdateManyWithWhereWithoutWork_ordersInput | work_order_crewUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_crewScalarWhereInput | work_order_crewScalarWhereInput[]
  }

  export type work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<work_order_approvalsCreateWithoutWork_ordersInput, work_order_approvalsUncheckedCreateWithoutWork_ordersInput> | work_order_approvalsCreateWithoutWork_ordersInput[] | work_order_approvalsUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: work_order_approvalsCreateOrConnectWithoutWork_ordersInput | work_order_approvalsCreateOrConnectWithoutWork_ordersInput[]
    upsert?: work_order_approvalsUpsertWithWhereUniqueWithoutWork_ordersInput | work_order_approvalsUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: work_order_approvalsCreateManyWork_ordersInputEnvelope
    set?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    disconnect?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    delete?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    connect?: work_order_approvalsWhereUniqueInput | work_order_approvalsWhereUniqueInput[]
    update?: work_order_approvalsUpdateWithWhereUniqueWithoutWork_ordersInput | work_order_approvalsUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: work_order_approvalsUpdateManyWithWhereWithoutWork_ordersInput | work_order_approvalsUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: work_order_approvalsScalarWhereInput | work_order_approvalsScalarWhereInput[]
  }

  export type invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput = {
    create?: XOR<invoicesCreateWithoutWork_ordersInput, invoicesUncheckedCreateWithoutWork_ordersInput> | invoicesCreateWithoutWork_ordersInput[] | invoicesUncheckedCreateWithoutWork_ordersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutWork_ordersInput | invoicesCreateOrConnectWithoutWork_ordersInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutWork_ordersInput | invoicesUpsertWithWhereUniqueWithoutWork_ordersInput[]
    createMany?: invoicesCreateManyWork_ordersInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutWork_ordersInput | invoicesUpdateWithWhereUniqueWithoutWork_ordersInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutWork_ordersInput | invoicesUpdateManyWithWhereWithoutWork_ordersInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type work_ordersCreateNestedOneWithoutWork_order_servicesInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_servicesInput, work_ordersUncheckedCreateWithoutWork_order_servicesInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_servicesInput
    connect?: work_ordersWhereUniqueInput
  }

  export type servicesCreateNestedOneWithoutWork_order_servicesInput = {
    create?: XOR<servicesCreateWithoutWork_order_servicesInput, servicesUncheckedCreateWithoutWork_order_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutWork_order_servicesInput
    connect?: servicesWhereUniqueInput
  }

  export type work_ordersUpdateOneRequiredWithoutWork_order_servicesNestedInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_servicesInput, work_ordersUncheckedCreateWithoutWork_order_servicesInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_servicesInput
    upsert?: work_ordersUpsertWithoutWork_order_servicesInput
    connect?: work_ordersWhereUniqueInput
    update?: XOR<XOR<work_ordersUpdateToOneWithWhereWithoutWork_order_servicesInput, work_ordersUpdateWithoutWork_order_servicesInput>, work_ordersUncheckedUpdateWithoutWork_order_servicesInput>
  }

  export type servicesUpdateOneRequiredWithoutWork_order_servicesNestedInput = {
    create?: XOR<servicesCreateWithoutWork_order_servicesInput, servicesUncheckedCreateWithoutWork_order_servicesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutWork_order_servicesInput
    upsert?: servicesUpsertWithoutWork_order_servicesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<XOR<servicesUpdateToOneWithWhereWithoutWork_order_servicesInput, servicesUpdateWithoutWork_order_servicesInput>, servicesUncheckedUpdateWithoutWork_order_servicesInput>
  }

  export type work_ordersCreateNestedOneWithoutWork_order_tasksInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_tasksInput, work_ordersUncheckedCreateWithoutWork_order_tasksInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_tasksInput
    connect?: work_ordersWhereUniqueInput
  }

  export type EnumWorkOrderTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkOrderTaskStatus
  }

  export type work_ordersUpdateOneRequiredWithoutWork_order_tasksNestedInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_tasksInput, work_ordersUncheckedCreateWithoutWork_order_tasksInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_tasksInput
    upsert?: work_ordersUpsertWithoutWork_order_tasksInput
    connect?: work_ordersWhereUniqueInput
    update?: XOR<XOR<work_ordersUpdateToOneWithWhereWithoutWork_order_tasksInput, work_ordersUpdateWithoutWork_order_tasksInput>, work_ordersUncheckedUpdateWithoutWork_order_tasksInput>
  }

  export type work_ordersCreateNestedOneWithoutWork_order_assetsInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_assetsInput, work_ordersUncheckedCreateWithoutWork_order_assetsInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_assetsInput
    connect?: work_ordersWhereUniqueInput
  }

  export type work_ordersUpdateOneRequiredWithoutWork_order_assetsNestedInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_assetsInput, work_ordersUncheckedCreateWithoutWork_order_assetsInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_assetsInput
    upsert?: work_ordersUpsertWithoutWork_order_assetsInput
    connect?: work_ordersWhereUniqueInput
    update?: XOR<XOR<work_ordersUpdateToOneWithWhereWithoutWork_order_assetsInput, work_ordersUpdateWithoutWork_order_assetsInput>, work_ordersUncheckedUpdateWithoutWork_order_assetsInput>
  }

  export type work_ordersCreateNestedOneWithoutWork_order_crewInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_crewInput, work_ordersUncheckedCreateWithoutWork_order_crewInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_crewInput
    connect?: work_ordersWhereUniqueInput
  }

  export type crewsCreateNestedOneWithoutWork_order_crewInput = {
    create?: XOR<crewsCreateWithoutWork_order_crewInput, crewsUncheckedCreateWithoutWork_order_crewInput>
    connectOrCreate?: crewsCreateOrConnectWithoutWork_order_crewInput
    connect?: crewsWhereUniqueInput
  }

  export type work_ordersUpdateOneRequiredWithoutWork_order_crewNestedInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_crewInput, work_ordersUncheckedCreateWithoutWork_order_crewInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_crewInput
    upsert?: work_ordersUpsertWithoutWork_order_crewInput
    connect?: work_ordersWhereUniqueInput
    update?: XOR<XOR<work_ordersUpdateToOneWithWhereWithoutWork_order_crewInput, work_ordersUpdateWithoutWork_order_crewInput>, work_ordersUncheckedUpdateWithoutWork_order_crewInput>
  }

  export type crewsUpdateOneRequiredWithoutWork_order_crewNestedInput = {
    create?: XOR<crewsCreateWithoutWork_order_crewInput, crewsUncheckedCreateWithoutWork_order_crewInput>
    connectOrCreate?: crewsCreateOrConnectWithoutWork_order_crewInput
    upsert?: crewsUpsertWithoutWork_order_crewInput
    connect?: crewsWhereUniqueInput
    update?: XOR<XOR<crewsUpdateToOneWithWhereWithoutWork_order_crewInput, crewsUpdateWithoutWork_order_crewInput>, crewsUncheckedUpdateWithoutWork_order_crewInput>
  }

  export type work_ordersCreateNestedOneWithoutWork_order_approvalsInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_approvalsInput, work_ordersUncheckedCreateWithoutWork_order_approvalsInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_approvalsInput
    connect?: work_ordersWhereUniqueInput
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type work_ordersUpdateOneRequiredWithoutWork_order_approvalsNestedInput = {
    create?: XOR<work_ordersCreateWithoutWork_order_approvalsInput, work_ordersUncheckedCreateWithoutWork_order_approvalsInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutWork_order_approvalsInput
    upsert?: work_ordersUpsertWithoutWork_order_approvalsInput
    connect?: work_ordersWhereUniqueInput
    update?: XOR<XOR<work_ordersUpdateToOneWithWhereWithoutWork_order_approvalsInput, work_ordersUpdateWithoutWork_order_approvalsInput>, work_ordersUncheckedUpdateWithoutWork_order_approvalsInput>
  }

  export type work_ordersCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<work_ordersCreateWithoutInvoicesInput, work_ordersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutInvoicesInput
    connect?: work_ordersWhereUniqueInput
  }

  export type invoice_itemsCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type work_ordersUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<work_ordersCreateWithoutInvoicesInput, work_ordersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: work_ordersCreateOrConnectWithoutInvoicesInput
    upsert?: work_ordersUpsertWithoutInvoicesInput
    connect?: work_ordersWhereUniqueInput
    update?: XOR<XOR<work_ordersUpdateToOneWithWhereWithoutInvoicesInput, work_ordersUpdateWithoutInvoicesInput>, work_ordersUncheckedUpdateWithoutInvoicesInput>
  }

  export type invoice_itemsUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutInvoicesInput | invoice_itemsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutInvoicesInput | paymentsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutInvoicesInput | paymentsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutInvoicesInput | paymentsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput> | invoice_itemsCreateWithoutInvoicesInput[] | invoice_itemsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: invoice_itemsCreateOrConnectWithoutInvoicesInput | invoice_itemsCreateOrConnectWithoutInvoicesInput[]
    upsert?: invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: invoice_itemsCreateManyInvoicesInputEnvelope
    set?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    disconnect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    delete?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    connect?: invoice_itemsWhereUniqueInput | invoice_itemsWhereUniqueInput[]
    update?: invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput | invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: invoice_itemsUpdateManyWithWhereWithoutInvoicesInput | invoice_itemsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput> | paymentsCreateWithoutInvoicesInput[] | paymentsUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoicesInput | paymentsCreateOrConnectWithoutInvoicesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutInvoicesInput | paymentsUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: paymentsCreateManyInvoicesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutInvoicesInput | paymentsUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutInvoicesInput | paymentsUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type invoicesCreateNestedOneWithoutInvoice_itemsInput = {
    create?: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutInvoice_itemsInput
    connect?: invoicesWhereUniqueInput
  }

  export type servicesCreateNestedOneWithoutInvoice_itemsInput = {
    create?: XOR<servicesCreateWithoutInvoice_itemsInput, servicesUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutInvoice_itemsInput
    connect?: servicesWhereUniqueInput
  }

  export type partsCreateNestedOneWithoutInvoice_itemsInput = {
    create?: XOR<partsCreateWithoutInvoice_itemsInput, partsUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: partsCreateOrConnectWithoutInvoice_itemsInput
    connect?: partsWhereUniqueInput
  }

  export type invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput = {
    create?: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutInvoice_itemsInput
    upsert?: invoicesUpsertWithoutInvoice_itemsInput
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutInvoice_itemsInput, invoicesUpdateWithoutInvoice_itemsInput>, invoicesUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type servicesUpdateOneRequiredWithoutInvoice_itemsNestedInput = {
    create?: XOR<servicesCreateWithoutInvoice_itemsInput, servicesUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: servicesCreateOrConnectWithoutInvoice_itemsInput
    upsert?: servicesUpsertWithoutInvoice_itemsInput
    connect?: servicesWhereUniqueInput
    update?: XOR<XOR<servicesUpdateToOneWithWhereWithoutInvoice_itemsInput, servicesUpdateWithoutInvoice_itemsInput>, servicesUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type partsUpdateOneRequiredWithoutInvoice_itemsNestedInput = {
    create?: XOR<partsCreateWithoutInvoice_itemsInput, partsUncheckedCreateWithoutInvoice_itemsInput>
    connectOrCreate?: partsCreateOrConnectWithoutInvoice_itemsInput
    upsert?: partsUpsertWithoutInvoice_itemsInput
    connect?: partsWhereUniqueInput
    update?: XOR<XOR<partsUpdateToOneWithWhereWithoutInvoice_itemsInput, partsUpdateWithoutInvoice_itemsInput>, partsUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type invoicesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutPaymentsInput
    connect?: invoicesWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type invoicesUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutPaymentsInput
    upsert?: invoicesUpsertWithoutPaymentsInput
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutPaymentsInput, invoicesUpdateWithoutPaymentsInput>, invoicesUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type usersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersCreateNestedOneWithoutAudit_logsInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumLogTypeFieldUpdateOperationsInput = {
    set?: $Enums.LogType
  }

  export type usersUpdateOneRequiredWithoutAudit_logsNestedInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    upsert?: usersUpsertWithoutAudit_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAudit_logsInput, usersUpdateWithoutAudit_logsInput>, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumProficiencyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ProficiencyLevel | EnumProficiencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyLevelFilter<$PrismaModel> | $Enums.ProficiencyLevel
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumProficiencyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProficiencyLevel | EnumProficiencyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProficiencyLevel[] | ListEnumProficiencyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumProficiencyLevelWithAggregatesFilter<$PrismaModel> | $Enums.ProficiencyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProficiencyLevelFilter<$PrismaModel>
    _max?: NestedEnumProficiencyLevelFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumEqupmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EqupmentStatus | EnumEqupmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEqupmentStatusFilter<$PrismaModel> | $Enums.EqupmentStatus
  }

  export type NestedEnumEqupmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EqupmentStatus | EnumEqupmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EqupmentStatus[] | ListEnumEqupmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEqupmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EqupmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEqupmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEqupmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type NestedEnumFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyFilter<$PrismaModel> | $Enums.Frequency
  }

  export type NestedEnumFrequencyUnitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyUnitType | EnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyUnitTypeFilter<$PrismaModel> | $Enums.FrequencyUnitType
  }

  export type NestedEnumFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.Frequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFrequencyFilter<$PrismaModel>
    _max?: NestedEnumFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumFrequencyUnitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FrequencyUnitType | EnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FrequencyUnitType[] | ListEnumFrequencyUnitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyUnitTypeWithAggregatesFilter<$PrismaModel> | $Enums.FrequencyUnitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFrequencyUnitTypeFilter<$PrismaModel>
    _max?: NestedEnumFrequencyUnitTypeFilter<$PrismaModel>
  }

  export type NestedEnumPrioirtyFilter<$PrismaModel = never> = {
    equals?: $Enums.Prioirty | EnumPrioirtyFieldRefInput<$PrismaModel>
    in?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioirtyFilter<$PrismaModel> | $Enums.Prioirty
  }

  export type NestedEnumWorkOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusFilter<$PrismaModel> | $Enums.WorkOrderStatus
  }

  export type NestedEnumPrioirtyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Prioirty | EnumPrioirtyFieldRefInput<$PrismaModel>
    in?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Prioirty[] | ListEnumPrioirtyFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioirtyWithAggregatesFilter<$PrismaModel> | $Enums.Prioirty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrioirtyFilter<$PrismaModel>
    _max?: NestedEnumPrioirtyFilter<$PrismaModel>
  }

  export type NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderStatus[] | ListEnumWorkOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkOrderTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderTaskStatus | EnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderTaskStatusFilter<$PrismaModel> | $Enums.WorkOrderTaskStatus
  }

  export type NestedEnumWorkOrderTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderTaskStatus | EnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkOrderTaskStatus[] | ListEnumWorkOrderTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkOrderTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeFilter<$PrismaModel> | $Enums.LogType
  }

  export type NestedEnumLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogType[] | ListEnumLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.LogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogTypeFilter<$PrismaModel>
    _max?: NestedEnumLogTypeFilter<$PrismaModel>
  }

  export type usersCreateWithoutOrganizationsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsCreateNestedManyWithoutUsersInput
    crews?: crewsCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsUncheckedCreateNestedManyWithoutUsersInput
    crews?: crewsUncheckedCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput>
  }

  export type usersCreateManyOrganizationsInputEnvelope = {
    data: usersCreateManyOrganizationsInput | usersCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type user_skillsCreateWithoutOrganizationsInput = {
    id?: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutUser_skillsInput
    skills: skillsCreateNestedOneWithoutUser_skillsInput
  }

  export type user_skillsUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    user_id: bigint | number
    skill_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_skillsCreateOrConnectWithoutOrganizationsInput = {
    where: user_skillsWhereUniqueInput
    create: XOR<user_skillsCreateWithoutOrganizationsInput, user_skillsUncheckedCreateWithoutOrganizationsInput>
  }

  export type user_skillsCreateManyOrganizationsInputEnvelope = {
    data: user_skillsCreateManyOrganizationsInput | user_skillsCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type business_hoursCreateWithoutOrganizationsInput = {
    id?: bigint | number
    day_of_week?: $Enums.DayOfWeek
    start_time: string
    end_time: string
    created_at: string
    updated_at: string
  }

  export type business_hoursUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    day_of_week?: $Enums.DayOfWeek
    start_time: string
    end_time: string
    created_at: string
    updated_at: string
  }

  export type business_hoursCreateOrConnectWithoutOrganizationsInput = {
    where: business_hoursWhereUniqueInput
    create: XOR<business_hoursCreateWithoutOrganizationsInput, business_hoursUncheckedCreateWithoutOrganizationsInput>
  }

  export type business_hoursCreateManyOrganizationsInputEnvelope = {
    data: business_hoursCreateManyOrganizationsInput | business_hoursCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type holidaysCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    holiday_date: string
    is_recurring?: number
    created_at: string
    updated_at: string
  }

  export type holidaysUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    holiday_date: string
    is_recurring?: number
    created_at: string
    updated_at: string
  }

  export type holidaysCreateOrConnectWithoutOrganizationsInput = {
    where: holidaysWhereUniqueInput
    create: XOR<holidaysCreateWithoutOrganizationsInput, holidaysUncheckedCreateWithoutOrganizationsInput>
  }

  export type holidaysCreateManyOrganizationsInputEnvelope = {
    data: holidaysCreateManyOrganizationsInput | holidaysCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type crew_membersCreateWithoutOrganizationsInput = {
    id?: bigint | number
    role: string
    created_at: string
    updated_at: string
    crews: crewsCreateNestedOneWithoutCrew_membersInput
    users: usersCreateNestedOneWithoutCrew_membersInput
  }

  export type crew_membersUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    crew_id: bigint | number
    user_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type crew_membersCreateOrConnectWithoutOrganizationsInput = {
    where: crew_membersWhereUniqueInput
    create: XOR<crew_membersCreateWithoutOrganizationsInput, crew_membersUncheckedCreateWithoutOrganizationsInput>
  }

  export type crew_membersCreateManyOrganizationsInputEnvelope = {
    data: crew_membersCreateManyOrganizationsInput | crew_membersCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type equipmentsCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    equipment_type: string
    status: $Enums.EqupmentStatus
    location: string
    availability_date: string
    created_at: string
    updated_at: string
  }

  export type equipmentsUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    equipment_type: string
    status: $Enums.EqupmentStatus
    location: string
    availability_date: string
    created_at: string
    updated_at: string
  }

  export type equipmentsCreateOrConnectWithoutOrganizationsInput = {
    where: equipmentsWhereUniqueInput
    create: XOR<equipmentsCreateWithoutOrganizationsInput, equipmentsUncheckedCreateWithoutOrganizationsInput>
  }

  export type equipmentsCreateManyOrganizationsInputEnvelope = {
    data: equipmentsCreateManyOrganizationsInput | equipmentsCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type companiesCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    customers?: customersCreateNestedManyWithoutCompaniesInput
    work_orders?: work_ordersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    customers?: customersUncheckedCreateNestedManyWithoutCompaniesInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutOrganizationsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutOrganizationsInput, companiesUncheckedCreateWithoutOrganizationsInput>
  }

  export type companiesCreateManyOrganizationsInputEnvelope = {
    data: companiesCreateManyOrganizationsInput | companiesCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type customersCreateWithoutOrganizationsInput = {
    id?: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    companies: companiesCreateNestedOneWithoutCustomersInput
    assets?: assetsCreateNestedManyWithoutCustomersInput
    work_orders?: work_ordersCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    company_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    assets?: assetsUncheckedCreateNestedManyWithoutCustomersInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutOrganizationsInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutOrganizationsInput, customersUncheckedCreateWithoutOrganizationsInput>
  }

  export type customersCreateManyOrganizationsInputEnvelope = {
    data: customersCreateManyOrganizationsInput | customersCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type servicesCreateWithoutOrganizationsInput = {
    id?: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesCreateNestedManyWithoutServicesInput
    invoice_items?: invoice_itemsCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutServicesInput
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutOrganizationsInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutOrganizationsInput, servicesUncheckedCreateWithoutOrganizationsInput>
  }

  export type servicesCreateManyOrganizationsInputEnvelope = {
    data: servicesCreateManyOrganizationsInput | servicesCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type assetsCreateWithoutOrganizationsInput = {
    id?: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    customers: customersCreateNestedOneWithoutAssetsInput
    work_orders?: work_ordersCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    customer_id: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutOrganizationsInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutOrganizationsInput, assetsUncheckedCreateWithoutOrganizationsInput>
  }

  export type assetsCreateManyOrganizationsInputEnvelope = {
    data: assetsCreateManyOrganizationsInput | assetsCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type partsCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsCreateNestedManyWithoutPartsInput
  }

  export type partsUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutPartsInput
  }

  export type partsCreateOrConnectWithoutOrganizationsInput = {
    where: partsWhereUniqueInput
    create: XOR<partsCreateWithoutOrganizationsInput, partsUncheckedCreateWithoutOrganizationsInput>
  }

  export type partsCreateManyOrganizationsInputEnvelope = {
    data: partsCreateManyOrganizationsInput | partsCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type maintenance_plansCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    maintenance_plan_assets?: maintenance_plan_assetsCreateNestedManyWithoutMaintenance_plansInput
    work_orders?: work_ordersCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    maintenance_plan_assets?: maintenance_plan_assetsUncheckedCreateNestedManyWithoutMaintenance_plansInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansCreateOrConnectWithoutOrganizationsInput = {
    where: maintenance_plansWhereUniqueInput
    create: XOR<maintenance_plansCreateWithoutOrganizationsInput, maintenance_plansUncheckedCreateWithoutOrganizationsInput>
  }

  export type maintenance_plansCreateManyOrganizationsInputEnvelope = {
    data: maintenance_plansCreateManyOrganizationsInput | maintenance_plansCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type work_ordersCreateWithoutOrganizationsInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutOrganizationsInput = {
    id?: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutOrganizationsInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutOrganizationsInput, work_ordersUncheckedCreateWithoutOrganizationsInput>
  }

  export type work_ordersCreateManyOrganizationsInputEnvelope = {
    data: work_ordersCreateManyOrganizationsInput | work_ordersCreateManyOrganizationsInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutOrganizationsInput, usersUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutOrganizationsInput, usersUncheckedUpdateWithoutOrganizationsInput>
  }

  export type usersUpdateManyWithWhereWithoutOrganizationsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: BigIntFilter<"users"> | bigint | number
    organization_id?: BigIntFilter<"users"> | bigint | number
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    isVerified_Email?: BoolFilter<"users"> | boolean
    isVerified_PhoneNumber?: BoolFilter<"users"> | boolean
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    phone?: StringFilter<"users"> | string
    job_title?: StringFilter<"users"> | string
    user_type?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    is_active?: IntFilter<"users"> | number
    last_login_at?: StringFilter<"users"> | string
    email_verified?: BoolFilter<"users"> | boolean
    created_at?: StringFilter<"users"> | string
    updated_at?: StringFilter<"users"> | string
  }

  export type user_skillsUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: user_skillsWhereUniqueInput
    update: XOR<user_skillsUpdateWithoutOrganizationsInput, user_skillsUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<user_skillsCreateWithoutOrganizationsInput, user_skillsUncheckedCreateWithoutOrganizationsInput>
  }

  export type user_skillsUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: user_skillsWhereUniqueInput
    data: XOR<user_skillsUpdateWithoutOrganizationsInput, user_skillsUncheckedUpdateWithoutOrganizationsInput>
  }

  export type user_skillsUpdateManyWithWhereWithoutOrganizationsInput = {
    where: user_skillsScalarWhereInput
    data: XOR<user_skillsUpdateManyMutationInput, user_skillsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type user_skillsScalarWhereInput = {
    AND?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
    OR?: user_skillsScalarWhereInput[]
    NOT?: user_skillsScalarWhereInput | user_skillsScalarWhereInput[]
    id?: BigIntFilter<"user_skills"> | bigint | number
    user_id?: BigIntFilter<"user_skills"> | bigint | number
    skill_id?: BigIntFilter<"user_skills"> | bigint | number
    organization_id?: BigIntFilter<"user_skills"> | bigint | number
    proficiency_level?: EnumProficiencyLevelFilter<"user_skills"> | $Enums.ProficiencyLevel
    created_at?: DateTimeFilter<"user_skills"> | Date | string
    updated_at?: DateTimeFilter<"user_skills"> | Date | string
  }

  export type business_hoursUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: business_hoursWhereUniqueInput
    update: XOR<business_hoursUpdateWithoutOrganizationsInput, business_hoursUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<business_hoursCreateWithoutOrganizationsInput, business_hoursUncheckedCreateWithoutOrganizationsInput>
  }

  export type business_hoursUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: business_hoursWhereUniqueInput
    data: XOR<business_hoursUpdateWithoutOrganizationsInput, business_hoursUncheckedUpdateWithoutOrganizationsInput>
  }

  export type business_hoursUpdateManyWithWhereWithoutOrganizationsInput = {
    where: business_hoursScalarWhereInput
    data: XOR<business_hoursUpdateManyMutationInput, business_hoursUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type business_hoursScalarWhereInput = {
    AND?: business_hoursScalarWhereInput | business_hoursScalarWhereInput[]
    OR?: business_hoursScalarWhereInput[]
    NOT?: business_hoursScalarWhereInput | business_hoursScalarWhereInput[]
    id?: BigIntFilter<"business_hours"> | bigint | number
    organization_id?: BigIntFilter<"business_hours"> | bigint | number
    day_of_week?: EnumDayOfWeekFilter<"business_hours"> | $Enums.DayOfWeek
    start_time?: StringFilter<"business_hours"> | string
    end_time?: StringFilter<"business_hours"> | string
    created_at?: StringFilter<"business_hours"> | string
    updated_at?: StringFilter<"business_hours"> | string
  }

  export type holidaysUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: holidaysWhereUniqueInput
    update: XOR<holidaysUpdateWithoutOrganizationsInput, holidaysUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<holidaysCreateWithoutOrganizationsInput, holidaysUncheckedCreateWithoutOrganizationsInput>
  }

  export type holidaysUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: holidaysWhereUniqueInput
    data: XOR<holidaysUpdateWithoutOrganizationsInput, holidaysUncheckedUpdateWithoutOrganizationsInput>
  }

  export type holidaysUpdateManyWithWhereWithoutOrganizationsInput = {
    where: holidaysScalarWhereInput
    data: XOR<holidaysUpdateManyMutationInput, holidaysUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type holidaysScalarWhereInput = {
    AND?: holidaysScalarWhereInput | holidaysScalarWhereInput[]
    OR?: holidaysScalarWhereInput[]
    NOT?: holidaysScalarWhereInput | holidaysScalarWhereInput[]
    id?: BigIntFilter<"holidays"> | bigint | number
    organization_id?: BigIntFilter<"holidays"> | bigint | number
    name?: StringFilter<"holidays"> | string
    holiday_date?: StringFilter<"holidays"> | string
    is_recurring?: IntFilter<"holidays"> | number
    created_at?: StringFilter<"holidays"> | string
    updated_at?: StringFilter<"holidays"> | string
  }

  export type crew_membersUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: crew_membersWhereUniqueInput
    update: XOR<crew_membersUpdateWithoutOrganizationsInput, crew_membersUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<crew_membersCreateWithoutOrganizationsInput, crew_membersUncheckedCreateWithoutOrganizationsInput>
  }

  export type crew_membersUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: crew_membersWhereUniqueInput
    data: XOR<crew_membersUpdateWithoutOrganizationsInput, crew_membersUncheckedUpdateWithoutOrganizationsInput>
  }

  export type crew_membersUpdateManyWithWhereWithoutOrganizationsInput = {
    where: crew_membersScalarWhereInput
    data: XOR<crew_membersUpdateManyMutationInput, crew_membersUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type crew_membersScalarWhereInput = {
    AND?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
    OR?: crew_membersScalarWhereInput[]
    NOT?: crew_membersScalarWhereInput | crew_membersScalarWhereInput[]
    id?: BigIntFilter<"crew_members"> | bigint | number
    organization_id?: BigIntFilter<"crew_members"> | bigint | number
    crew_id?: BigIntFilter<"crew_members"> | bigint | number
    user_id?: BigIntFilter<"crew_members"> | bigint | number
    role?: StringFilter<"crew_members"> | string
    created_at?: StringFilter<"crew_members"> | string
    updated_at?: StringFilter<"crew_members"> | string
  }

  export type equipmentsUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: equipmentsWhereUniqueInput
    update: XOR<equipmentsUpdateWithoutOrganizationsInput, equipmentsUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<equipmentsCreateWithoutOrganizationsInput, equipmentsUncheckedCreateWithoutOrganizationsInput>
  }

  export type equipmentsUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: equipmentsWhereUniqueInput
    data: XOR<equipmentsUpdateWithoutOrganizationsInput, equipmentsUncheckedUpdateWithoutOrganizationsInput>
  }

  export type equipmentsUpdateManyWithWhereWithoutOrganizationsInput = {
    where: equipmentsScalarWhereInput
    data: XOR<equipmentsUpdateManyMutationInput, equipmentsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type equipmentsScalarWhereInput = {
    AND?: equipmentsScalarWhereInput | equipmentsScalarWhereInput[]
    OR?: equipmentsScalarWhereInput[]
    NOT?: equipmentsScalarWhereInput | equipmentsScalarWhereInput[]
    id?: BigIntFilter<"equipments"> | bigint | number
    organization_id?: BigIntFilter<"equipments"> | bigint | number
    name?: StringFilter<"equipments"> | string
    equipment_type?: StringFilter<"equipments"> | string
    status?: EnumEqupmentStatusFilter<"equipments"> | $Enums.EqupmentStatus
    location?: StringFilter<"equipments"> | string
    availability_date?: StringFilter<"equipments"> | string
    created_at?: StringFilter<"equipments"> | string
    updated_at?: StringFilter<"equipments"> | string
  }

  export type companiesUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: companiesWhereUniqueInput
    update: XOR<companiesUpdateWithoutOrganizationsInput, companiesUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<companiesCreateWithoutOrganizationsInput, companiesUncheckedCreateWithoutOrganizationsInput>
  }

  export type companiesUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: companiesWhereUniqueInput
    data: XOR<companiesUpdateWithoutOrganizationsInput, companiesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type companiesUpdateManyWithWhereWithoutOrganizationsInput = {
    where: companiesScalarWhereInput
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type companiesScalarWhereInput = {
    AND?: companiesScalarWhereInput | companiesScalarWhereInput[]
    OR?: companiesScalarWhereInput[]
    NOT?: companiesScalarWhereInput | companiesScalarWhereInput[]
    id?: BigIntFilter<"companies"> | bigint | number
    organization_id?: BigIntFilter<"companies"> | bigint | number
    name?: StringFilter<"companies"> | string
    industry?: StringFilter<"companies"> | string
    tax_id?: StringFilter<"companies"> | string
    address?: StringFilter<"companies"> | string
    phone?: StringFilter<"companies"> | string
    email?: StringFilter<"companies"> | string
    website?: StringFilter<"companies"> | string
    created_at?: StringFilter<"companies"> | string
    updated_at?: StringFilter<"companies"> | string
  }

  export type customersUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: customersWhereUniqueInput
    update: XOR<customersUpdateWithoutOrganizationsInput, customersUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<customersCreateWithoutOrganizationsInput, customersUncheckedCreateWithoutOrganizationsInput>
  }

  export type customersUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: customersWhereUniqueInput
    data: XOR<customersUpdateWithoutOrganizationsInput, customersUncheckedUpdateWithoutOrganizationsInput>
  }

  export type customersUpdateManyWithWhereWithoutOrganizationsInput = {
    where: customersScalarWhereInput
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type customersScalarWhereInput = {
    AND?: customersScalarWhereInput | customersScalarWhereInput[]
    OR?: customersScalarWhereInput[]
    NOT?: customersScalarWhereInput | customersScalarWhereInput[]
    id?: BigIntFilter<"customers"> | bigint | number
    organization_id?: BigIntFilter<"customers"> | bigint | number
    company_id?: BigIntFilter<"customers"> | bigint | number
    first_name?: StringFilter<"customers"> | string
    last_name?: StringFilter<"customers"> | string
    email?: StringFilter<"customers"> | string
    phone?: StringFilter<"customers"> | string
    address?: StringFilter<"customers"> | string
    is_active?: IntFilter<"customers"> | number
    created_at?: StringFilter<"customers"> | string
    updated_at?: StringFilter<"customers"> | string
  }

  export type servicesUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: servicesWhereUniqueInput
    update: XOR<servicesUpdateWithoutOrganizationsInput, servicesUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<servicesCreateWithoutOrganizationsInput, servicesUncheckedCreateWithoutOrganizationsInput>
  }

  export type servicesUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: servicesWhereUniqueInput
    data: XOR<servicesUpdateWithoutOrganizationsInput, servicesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type servicesUpdateManyWithWhereWithoutOrganizationsInput = {
    where: servicesScalarWhereInput
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type servicesScalarWhereInput = {
    AND?: servicesScalarWhereInput | servicesScalarWhereInput[]
    OR?: servicesScalarWhereInput[]
    NOT?: servicesScalarWhereInput | servicesScalarWhereInput[]
    id?: BigIntFilter<"services"> | bigint | number
    organization_id?: BigIntFilter<"services"> | bigint | number
    description?: StringFilter<"services"> | string
    duration?: IntFilter<"services"> | number
    price?: DecimalFilter<"services"> | Decimal | DecimalJsLike | number | string
    required_skills?: JsonFilter<"services">
    created_at?: StringFilter<"services"> | string
    updated_at?: StringFilter<"services"> | string
  }

  export type assetsUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: assetsWhereUniqueInput
    update: XOR<assetsUpdateWithoutOrganizationsInput, assetsUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<assetsCreateWithoutOrganizationsInput, assetsUncheckedCreateWithoutOrganizationsInput>
  }

  export type assetsUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: assetsWhereUniqueInput
    data: XOR<assetsUpdateWithoutOrganizationsInput, assetsUncheckedUpdateWithoutOrganizationsInput>
  }

  export type assetsUpdateManyWithWhereWithoutOrganizationsInput = {
    where: assetsScalarWhereInput
    data: XOR<assetsUpdateManyMutationInput, assetsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type assetsScalarWhereInput = {
    AND?: assetsScalarWhereInput | assetsScalarWhereInput[]
    OR?: assetsScalarWhereInput[]
    NOT?: assetsScalarWhereInput | assetsScalarWhereInput[]
    id?: BigIntFilter<"assets"> | bigint | number
    organization_id?: BigIntFilter<"assets"> | bigint | number
    customer_id?: BigIntFilter<"assets"> | bigint | number
    asset_name?: StringFilter<"assets"> | string
    serial_number?: StringFilter<"assets"> | string
    model?: StringFilter<"assets"> | string
    manufacturer?: StringFilter<"assets"> | string
    status?: EnumAssetStatusFilter<"assets"> | $Enums.AssetStatus
    location?: StringFilter<"assets"> | string
    notes?: StringFilter<"assets"> | string
    purchase_date?: StringFilter<"assets"> | string
    warranty_expiry?: StringFilter<"assets"> | string
    created_at?: StringFilter<"assets"> | string
    updated_at?: StringFilter<"assets"> | string
  }

  export type partsUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: partsWhereUniqueInput
    update: XOR<partsUpdateWithoutOrganizationsInput, partsUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<partsCreateWithoutOrganizationsInput, partsUncheckedCreateWithoutOrganizationsInput>
  }

  export type partsUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: partsWhereUniqueInput
    data: XOR<partsUpdateWithoutOrganizationsInput, partsUncheckedUpdateWithoutOrganizationsInput>
  }

  export type partsUpdateManyWithWhereWithoutOrganizationsInput = {
    where: partsScalarWhereInput
    data: XOR<partsUpdateManyMutationInput, partsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type partsScalarWhereInput = {
    AND?: partsScalarWhereInput | partsScalarWhereInput[]
    OR?: partsScalarWhereInput[]
    NOT?: partsScalarWhereInput | partsScalarWhereInput[]
    id?: BigIntFilter<"parts"> | bigint | number
    organization_id?: BigIntFilter<"parts"> | bigint | number
    name?: StringFilter<"parts"> | string
    description?: StringFilter<"parts"> | string
    price?: DecimalFilter<"parts"> | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFilter<"parts"> | number
    reorder_level?: IntFilter<"parts"> | number
    created_at?: StringFilter<"parts"> | string
    updated_at?: StringFilter<"parts"> | string
  }

  export type maintenance_plansUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: maintenance_plansWhereUniqueInput
    update: XOR<maintenance_plansUpdateWithoutOrganizationsInput, maintenance_plansUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<maintenance_plansCreateWithoutOrganizationsInput, maintenance_plansUncheckedCreateWithoutOrganizationsInput>
  }

  export type maintenance_plansUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: maintenance_plansWhereUniqueInput
    data: XOR<maintenance_plansUpdateWithoutOrganizationsInput, maintenance_plansUncheckedUpdateWithoutOrganizationsInput>
  }

  export type maintenance_plansUpdateManyWithWhereWithoutOrganizationsInput = {
    where: maintenance_plansScalarWhereInput
    data: XOR<maintenance_plansUpdateManyMutationInput, maintenance_plansUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type maintenance_plansScalarWhereInput = {
    AND?: maintenance_plansScalarWhereInput | maintenance_plansScalarWhereInput[]
    OR?: maintenance_plansScalarWhereInput[]
    NOT?: maintenance_plansScalarWhereInput | maintenance_plansScalarWhereInput[]
    id?: BigIntFilter<"maintenance_plans"> | bigint | number
    organization_id?: BigIntFilter<"maintenance_plans"> | bigint | number
    name?: StringFilter<"maintenance_plans"> | string
    description?: StringFilter<"maintenance_plans"> | string
    start_date?: StringFilter<"maintenance_plans"> | string
    end_date?: StringFilter<"maintenance_plans"> | string
    frequency?: EnumFrequencyFilter<"maintenance_plans"> | $Enums.Frequency
    frequency_unit?: IntFilter<"maintenance_plans"> | number
    frequency_unit_type?: EnumFrequencyUnitTypeFilter<"maintenance_plans"> | $Enums.FrequencyUnitType
    is_active?: IntFilter<"maintenance_plans"> | number
    created_at?: StringFilter<"maintenance_plans"> | string
    updated_at?: StringFilter<"maintenance_plans"> | string
  }

  export type work_ordersUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: work_ordersWhereUniqueInput
    update: XOR<work_ordersUpdateWithoutOrganizationsInput, work_ordersUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<work_ordersCreateWithoutOrganizationsInput, work_ordersUncheckedCreateWithoutOrganizationsInput>
  }

  export type work_ordersUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: work_ordersWhereUniqueInput
    data: XOR<work_ordersUpdateWithoutOrganizationsInput, work_ordersUncheckedUpdateWithoutOrganizationsInput>
  }

  export type work_ordersUpdateManyWithWhereWithoutOrganizationsInput = {
    where: work_ordersScalarWhereInput
    data: XOR<work_ordersUpdateManyMutationInput, work_ordersUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type work_ordersScalarWhereInput = {
    AND?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
    OR?: work_ordersScalarWhereInput[]
    NOT?: work_ordersScalarWhereInput | work_ordersScalarWhereInput[]
    id?: BigIntFilter<"work_orders"> | bigint | number
    organization_id?: BigIntFilter<"work_orders"> | bigint | number
    customer_id?: BigIntFilter<"work_orders"> | bigint | number
    company_id?: BigIntFilter<"work_orders"> | bigint | number
    asset_id?: BigIntFilter<"work_orders"> | bigint | number
    maintenance_plan_id?: BigIntFilter<"work_orders"> | bigint | number
    title?: StringFilter<"work_orders"> | string
    description?: StringFilter<"work_orders"> | string
    priority?: EnumPrioirtyFilter<"work_orders"> | $Enums.Prioirty
    status?: EnumWorkOrderStatusFilter<"work_orders"> | $Enums.WorkOrderStatus
    assigned_to?: StringFilter<"work_orders"> | string
    assigned_crew_id?: IntFilter<"work_orders"> | number
    scheduled_start_date?: StringFilter<"work_orders"> | string
    scheduled_end_date?: StringFilter<"work_orders"> | string
    actual_start_date?: StringFilter<"work_orders"> | string
    actual_end_date?: StringFilter<"work_orders"> | string
    currency_id?: IntFilter<"work_orders"> | number
    estimated_cost?: DecimalFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFilter<"work_orders"> | Decimal | DecimalJsLike | number | string
    address?: StringFilter<"work_orders"> | string
    city?: StringFilter<"work_orders"> | string
    state?: StringFilter<"work_orders"> | string
    postal_code?: StringFilter<"work_orders"> | string
    country?: StringFilter<"work_orders"> | string
    is_multi_day?: IntFilter<"work_orders"> | number
    created_at?: StringFilter<"work_orders"> | string
    updated_at?: StringFilter<"work_orders"> | string
  }

  export type organizationsCreateWithoutUsersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutUsersInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
  }

  export type user_skillsCreateWithoutUsersInput = {
    id?: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
    skills: skillsCreateNestedOneWithoutUser_skillsInput
    organizations: organizationsCreateNestedOneWithoutUser_skillsInput
  }

  export type user_skillsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    skill_id: bigint | number
    organization_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_skillsCreateOrConnectWithoutUsersInput = {
    where: user_skillsWhereUniqueInput
    create: XOR<user_skillsCreateWithoutUsersInput, user_skillsUncheckedCreateWithoutUsersInput>
  }

  export type user_skillsCreateManyUsersInputEnvelope = {
    data: user_skillsCreateManyUsersInput | user_skillsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type time_off_requestsCreateWithoutUsersInput = {
    id?: bigint | number
    start_date: string
    end_date: string
    reason: string
    status?: $Enums.RequestStatus
    created_at: string
    updated_at: string
  }

  export type time_off_requestsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    start_date: string
    end_date: string
    reason: string
    status?: $Enums.RequestStatus
    created_at: string
    updated_at: string
  }

  export type time_off_requestsCreateOrConnectWithoutUsersInput = {
    where: time_off_requestsWhereUniqueInput
    create: XOR<time_off_requestsCreateWithoutUsersInput, time_off_requestsUncheckedCreateWithoutUsersInput>
  }

  export type time_off_requestsCreateManyUsersInputEnvelope = {
    data: time_off_requestsCreateManyUsersInput | time_off_requestsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type crewsCreateWithoutUsersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    created_at: string
    updated_at: string
    crew_members?: crew_membersCreateNestedManyWithoutCrewsInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutCrewsInput
  }

  export type crewsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    created_at: string
    updated_at: string
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutCrewsInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type crewsCreateOrConnectWithoutUsersInput = {
    where: crewsWhereUniqueInput
    create: XOR<crewsCreateWithoutUsersInput, crewsUncheckedCreateWithoutUsersInput>
  }

  export type crewsCreateManyUsersInputEnvelope = {
    data: crewsCreateManyUsersInput | crewsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type crew_membersCreateWithoutUsersInput = {
    id?: bigint | number
    role: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCrew_membersInput
    crews: crewsCreateNestedOneWithoutCrew_membersInput
  }

  export type crew_membersUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    organization_id: bigint | number
    crew_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type crew_membersCreateOrConnectWithoutUsersInput = {
    where: crew_membersWhereUniqueInput
    create: XOR<crew_membersCreateWithoutUsersInput, crew_membersUncheckedCreateWithoutUsersInput>
  }

  export type crew_membersCreateManyUsersInputEnvelope = {
    data: crew_membersCreateManyUsersInput | crew_membersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsersInput = {
    id?: bigint | number
    notification_type: $Enums.NotificationType
    message: string
    status: $Enums.NotificationStatus
    created_at: string
    updated_at: string
  }

  export type notificationsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    notification_type: $Enums.NotificationType
    message: string
    status: $Enums.NotificationStatus
    created_at: string
    updated_at: string
  }

  export type notificationsCreateOrConnectWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsCreateManyUsersInputEnvelope = {
    data: notificationsCreateManyUsersInput | notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type audit_logsCreateWithoutUsersInput = {
    id?: bigint | number
    action: string
    entity_type: $Enums.LogType
    entity_id: bigint | number
    changes: string
    created_at: string
    updated_at: string
  }

  export type audit_logsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    action: string
    entity_type: $Enums.LogType
    entity_id: bigint | number
    changes: string
    created_at: string
    updated_at: string
  }

  export type audit_logsCreateOrConnectWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsCreateManyUsersInputEnvelope = {
    data: audit_logsCreateManyUsersInput | audit_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutUsersInput = {
    update: XOR<organizationsUpdateWithoutUsersInput, organizationsUncheckedUpdateWithoutUsersInput>
    create: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutUsersInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutUsersInput, organizationsUncheckedUpdateWithoutUsersInput>
  }

  export type organizationsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type user_skillsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_skillsWhereUniqueInput
    update: XOR<user_skillsUpdateWithoutUsersInput, user_skillsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_skillsCreateWithoutUsersInput, user_skillsUncheckedCreateWithoutUsersInput>
  }

  export type user_skillsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_skillsWhereUniqueInput
    data: XOR<user_skillsUpdateWithoutUsersInput, user_skillsUncheckedUpdateWithoutUsersInput>
  }

  export type user_skillsUpdateManyWithWhereWithoutUsersInput = {
    where: user_skillsScalarWhereInput
    data: XOR<user_skillsUpdateManyMutationInput, user_skillsUncheckedUpdateManyWithoutUsersInput>
  }

  export type time_off_requestsUpsertWithWhereUniqueWithoutUsersInput = {
    where: time_off_requestsWhereUniqueInput
    update: XOR<time_off_requestsUpdateWithoutUsersInput, time_off_requestsUncheckedUpdateWithoutUsersInput>
    create: XOR<time_off_requestsCreateWithoutUsersInput, time_off_requestsUncheckedCreateWithoutUsersInput>
  }

  export type time_off_requestsUpdateWithWhereUniqueWithoutUsersInput = {
    where: time_off_requestsWhereUniqueInput
    data: XOR<time_off_requestsUpdateWithoutUsersInput, time_off_requestsUncheckedUpdateWithoutUsersInput>
  }

  export type time_off_requestsUpdateManyWithWhereWithoutUsersInput = {
    where: time_off_requestsScalarWhereInput
    data: XOR<time_off_requestsUpdateManyMutationInput, time_off_requestsUncheckedUpdateManyWithoutUsersInput>
  }

  export type time_off_requestsScalarWhereInput = {
    AND?: time_off_requestsScalarWhereInput | time_off_requestsScalarWhereInput[]
    OR?: time_off_requestsScalarWhereInput[]
    NOT?: time_off_requestsScalarWhereInput | time_off_requestsScalarWhereInput[]
    id?: BigIntFilter<"time_off_requests"> | bigint | number
    user_id?: BigIntFilter<"time_off_requests"> | bigint | number
    start_date?: StringFilter<"time_off_requests"> | string
    end_date?: StringFilter<"time_off_requests"> | string
    reason?: StringFilter<"time_off_requests"> | string
    status?: EnumRequestStatusFilter<"time_off_requests"> | $Enums.RequestStatus
    created_at?: StringFilter<"time_off_requests"> | string
    updated_at?: StringFilter<"time_off_requests"> | string
  }

  export type crewsUpsertWithWhereUniqueWithoutUsersInput = {
    where: crewsWhereUniqueInput
    update: XOR<crewsUpdateWithoutUsersInput, crewsUncheckedUpdateWithoutUsersInput>
    create: XOR<crewsCreateWithoutUsersInput, crewsUncheckedCreateWithoutUsersInput>
  }

  export type crewsUpdateWithWhereUniqueWithoutUsersInput = {
    where: crewsWhereUniqueInput
    data: XOR<crewsUpdateWithoutUsersInput, crewsUncheckedUpdateWithoutUsersInput>
  }

  export type crewsUpdateManyWithWhereWithoutUsersInput = {
    where: crewsScalarWhereInput
    data: XOR<crewsUpdateManyMutationInput, crewsUncheckedUpdateManyWithoutUsersInput>
  }

  export type crewsScalarWhereInput = {
    AND?: crewsScalarWhereInput | crewsScalarWhereInput[]
    OR?: crewsScalarWhereInput[]
    NOT?: crewsScalarWhereInput | crewsScalarWhereInput[]
    id?: BigIntFilter<"crews"> | bigint | number
    organization_id?: BigIntFilter<"crews"> | bigint | number
    name?: StringFilter<"crews"> | string
    leader_id?: BigIntFilter<"crews"> | bigint | number
    created_at?: StringFilter<"crews"> | string
    updated_at?: StringFilter<"crews"> | string
  }

  export type crew_membersUpsertWithWhereUniqueWithoutUsersInput = {
    where: crew_membersWhereUniqueInput
    update: XOR<crew_membersUpdateWithoutUsersInput, crew_membersUncheckedUpdateWithoutUsersInput>
    create: XOR<crew_membersCreateWithoutUsersInput, crew_membersUncheckedCreateWithoutUsersInput>
  }

  export type crew_membersUpdateWithWhereUniqueWithoutUsersInput = {
    where: crew_membersWhereUniqueInput
    data: XOR<crew_membersUpdateWithoutUsersInput, crew_membersUncheckedUpdateWithoutUsersInput>
  }

  export type crew_membersUpdateManyWithWhereWithoutUsersInput = {
    where: crew_membersScalarWhereInput
    data: XOR<crew_membersUpdateManyMutationInput, crew_membersUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: BigIntFilter<"notifications"> | bigint | number
    user_id?: BigIntFilter<"notifications"> | bigint | number
    notification_type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    message?: StringFilter<"notifications"> | string
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    created_at?: StringFilter<"notifications"> | string
    updated_at?: StringFilter<"notifications"> | string
  }

  export type audit_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    update: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    data: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
  }

  export type audit_logsUpdateManyWithWhereWithoutUsersInput = {
    where: audit_logsScalarWhereInput
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type audit_logsScalarWhereInput = {
    AND?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    OR?: audit_logsScalarWhereInput[]
    NOT?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    id?: BigIntFilter<"audit_logs"> | bigint | number
    user_id?: BigIntFilter<"audit_logs"> | bigint | number
    action?: StringFilter<"audit_logs"> | string
    entity_type?: EnumLogTypeFilter<"audit_logs"> | $Enums.LogType
    entity_id?: BigIntFilter<"audit_logs"> | bigint | number
    changes?: StringFilter<"audit_logs"> | string
    created_at?: StringFilter<"audit_logs"> | string
    updated_at?: StringFilter<"audit_logs"> | string
  }

  export type user_skillsCreateWithoutSkillsInput = {
    id?: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutUser_skillsInput
    organizations: organizationsCreateNestedOneWithoutUser_skillsInput
  }

  export type user_skillsUncheckedCreateWithoutSkillsInput = {
    id?: bigint | number
    user_id: bigint | number
    organization_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_skillsCreateOrConnectWithoutSkillsInput = {
    where: user_skillsWhereUniqueInput
    create: XOR<user_skillsCreateWithoutSkillsInput, user_skillsUncheckedCreateWithoutSkillsInput>
  }

  export type user_skillsCreateManySkillsInputEnvelope = {
    data: user_skillsCreateManySkillsInput | user_skillsCreateManySkillsInput[]
    skipDuplicates?: boolean
  }

  export type user_skillsUpsertWithWhereUniqueWithoutSkillsInput = {
    where: user_skillsWhereUniqueInput
    update: XOR<user_skillsUpdateWithoutSkillsInput, user_skillsUncheckedUpdateWithoutSkillsInput>
    create: XOR<user_skillsCreateWithoutSkillsInput, user_skillsUncheckedCreateWithoutSkillsInput>
  }

  export type user_skillsUpdateWithWhereUniqueWithoutSkillsInput = {
    where: user_skillsWhereUniqueInput
    data: XOR<user_skillsUpdateWithoutSkillsInput, user_skillsUncheckedUpdateWithoutSkillsInput>
  }

  export type user_skillsUpdateManyWithWhereWithoutSkillsInput = {
    where: user_skillsScalarWhereInput
    data: XOR<user_skillsUpdateManyMutationInput, user_skillsUncheckedUpdateManyWithoutSkillsInput>
  }

  export type usersCreateWithoutUser_skillsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    organizations: organizationsCreateNestedOneWithoutUsersInput
    time_off_requests?: time_off_requestsCreateNestedManyWithoutUsersInput
    crews?: crewsCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_skillsInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    time_off_requests?: time_off_requestsUncheckedCreateNestedManyWithoutUsersInput
    crews?: crewsUncheckedCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_skillsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_skillsInput, usersUncheckedCreateWithoutUser_skillsInput>
  }

  export type skillsCreateWithoutUser_skillsInput = {
    id?: bigint | number
    name: string
    description: string
    created_at: string
    updated_at: string
  }

  export type skillsUncheckedCreateWithoutUser_skillsInput = {
    id?: bigint | number
    name: string
    description: string
    created_at: string
    updated_at: string
  }

  export type skillsCreateOrConnectWithoutUser_skillsInput = {
    where: skillsWhereUniqueInput
    create: XOR<skillsCreateWithoutUser_skillsInput, skillsUncheckedCreateWithoutUser_skillsInput>
  }

  export type organizationsCreateWithoutUser_skillsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutUser_skillsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutUser_skillsInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutUser_skillsInput, organizationsUncheckedCreateWithoutUser_skillsInput>
  }

  export type usersUpsertWithoutUser_skillsInput = {
    update: XOR<usersUpdateWithoutUser_skillsInput, usersUncheckedUpdateWithoutUser_skillsInput>
    create: XOR<usersCreateWithoutUser_skillsInput, usersUncheckedCreateWithoutUser_skillsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_skillsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_skillsInput, usersUncheckedUpdateWithoutUser_skillsInput>
  }

  export type usersUpdateWithoutUser_skillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUpdateManyWithoutUsersNestedInput
    crews?: crewsUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_skillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    time_off_requests?: time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput
    crews?: crewsUncheckedUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type skillsUpsertWithoutUser_skillsInput = {
    update: XOR<skillsUpdateWithoutUser_skillsInput, skillsUncheckedUpdateWithoutUser_skillsInput>
    create: XOR<skillsCreateWithoutUser_skillsInput, skillsUncheckedCreateWithoutUser_skillsInput>
    where?: skillsWhereInput
  }

  export type skillsUpdateToOneWithWhereWithoutUser_skillsInput = {
    where?: skillsWhereInput
    data: XOR<skillsUpdateWithoutUser_skillsInput, skillsUncheckedUpdateWithoutUser_skillsInput>
  }

  export type skillsUpdateWithoutUser_skillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type skillsUncheckedUpdateWithoutUser_skillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type organizationsUpsertWithoutUser_skillsInput = {
    update: XOR<organizationsUpdateWithoutUser_skillsInput, organizationsUncheckedUpdateWithoutUser_skillsInput>
    create: XOR<organizationsCreateWithoutUser_skillsInput, organizationsUncheckedCreateWithoutUser_skillsInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutUser_skillsInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutUser_skillsInput, organizationsUncheckedUpdateWithoutUser_skillsInput>
  }

  export type organizationsUpdateWithoutUser_skillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutUser_skillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsCreateWithoutBusiness_hoursInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutBusiness_hoursInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutBusiness_hoursInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutBusiness_hoursInput, organizationsUncheckedCreateWithoutBusiness_hoursInput>
  }

  export type organizationsUpsertWithoutBusiness_hoursInput = {
    update: XOR<organizationsUpdateWithoutBusiness_hoursInput, organizationsUncheckedUpdateWithoutBusiness_hoursInput>
    create: XOR<organizationsCreateWithoutBusiness_hoursInput, organizationsUncheckedCreateWithoutBusiness_hoursInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutBusiness_hoursInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutBusiness_hoursInput, organizationsUncheckedUpdateWithoutBusiness_hoursInput>
  }

  export type organizationsUpdateWithoutBusiness_hoursInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutBusiness_hoursInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsCreateWithoutHolidaysInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutHolidaysInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutHolidaysInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutHolidaysInput, organizationsUncheckedCreateWithoutHolidaysInput>
  }

  export type organizationsUpsertWithoutHolidaysInput = {
    update: XOR<organizationsUpdateWithoutHolidaysInput, organizationsUncheckedUpdateWithoutHolidaysInput>
    create: XOR<organizationsCreateWithoutHolidaysInput, organizationsUncheckedCreateWithoutHolidaysInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutHolidaysInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutHolidaysInput, organizationsUncheckedUpdateWithoutHolidaysInput>
  }

  export type organizationsUpdateWithoutHolidaysInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutHolidaysInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type usersCreateWithoutTime_off_requestsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    organizations: organizationsCreateNestedOneWithoutUsersInput
    user_skills?: user_skillsCreateNestedManyWithoutUsersInput
    crews?: crewsCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTime_off_requestsInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutUsersInput
    crews?: crewsUncheckedCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTime_off_requestsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTime_off_requestsInput, usersUncheckedCreateWithoutTime_off_requestsInput>
  }

  export type usersUpsertWithoutTime_off_requestsInput = {
    update: XOR<usersUpdateWithoutTime_off_requestsInput, usersUncheckedUpdateWithoutTime_off_requestsInput>
    create: XOR<usersCreateWithoutTime_off_requestsInput, usersUncheckedCreateWithoutTime_off_requestsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTime_off_requestsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTime_off_requestsInput, usersUncheckedUpdateWithoutTime_off_requestsInput>
  }

  export type usersUpdateWithoutTime_off_requestsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    user_skills?: user_skillsUpdateManyWithoutUsersNestedInput
    crews?: crewsUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTime_off_requestsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutUsersNestedInput
    crews?: crewsUncheckedUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutCrewsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    organizations: organizationsCreateNestedOneWithoutUsersInput
    user_skills?: user_skillsCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCrewsInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsUncheckedCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCrewsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCrewsInput, usersUncheckedCreateWithoutCrewsInput>
  }

  export type crew_membersCreateWithoutCrewsInput = {
    id?: bigint | number
    role: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCrew_membersInput
    users: usersCreateNestedOneWithoutCrew_membersInput
  }

  export type crew_membersUncheckedCreateWithoutCrewsInput = {
    id?: bigint | number
    organization_id: bigint | number
    user_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type crew_membersCreateOrConnectWithoutCrewsInput = {
    where: crew_membersWhereUniqueInput
    create: XOR<crew_membersCreateWithoutCrewsInput, crew_membersUncheckedCreateWithoutCrewsInput>
  }

  export type crew_membersCreateManyCrewsInputEnvelope = {
    data: crew_membersCreateManyCrewsInput | crew_membersCreateManyCrewsInput[]
    skipDuplicates?: boolean
  }

  export type work_order_crewCreateWithoutCrewsInput = {
    id?: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutWork_order_crewInput
  }

  export type work_order_crewUncheckedCreateWithoutCrewsInput = {
    id?: bigint | number
    work_order_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_crewCreateOrConnectWithoutCrewsInput = {
    where: work_order_crewWhereUniqueInput
    create: XOR<work_order_crewCreateWithoutCrewsInput, work_order_crewUncheckedCreateWithoutCrewsInput>
  }

  export type work_order_crewCreateManyCrewsInputEnvelope = {
    data: work_order_crewCreateManyCrewsInput | work_order_crewCreateManyCrewsInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutCrewsInput = {
    update: XOR<usersUpdateWithoutCrewsInput, usersUncheckedUpdateWithoutCrewsInput>
    create: XOR<usersCreateWithoutCrewsInput, usersUncheckedCreateWithoutCrewsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCrewsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCrewsInput, usersUncheckedUpdateWithoutCrewsInput>
  }

  export type usersUpdateWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    user_skills?: user_skillsUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type crew_membersUpsertWithWhereUniqueWithoutCrewsInput = {
    where: crew_membersWhereUniqueInput
    update: XOR<crew_membersUpdateWithoutCrewsInput, crew_membersUncheckedUpdateWithoutCrewsInput>
    create: XOR<crew_membersCreateWithoutCrewsInput, crew_membersUncheckedCreateWithoutCrewsInput>
  }

  export type crew_membersUpdateWithWhereUniqueWithoutCrewsInput = {
    where: crew_membersWhereUniqueInput
    data: XOR<crew_membersUpdateWithoutCrewsInput, crew_membersUncheckedUpdateWithoutCrewsInput>
  }

  export type crew_membersUpdateManyWithWhereWithoutCrewsInput = {
    where: crew_membersScalarWhereInput
    data: XOR<crew_membersUpdateManyMutationInput, crew_membersUncheckedUpdateManyWithoutCrewsInput>
  }

  export type work_order_crewUpsertWithWhereUniqueWithoutCrewsInput = {
    where: work_order_crewWhereUniqueInput
    update: XOR<work_order_crewUpdateWithoutCrewsInput, work_order_crewUncheckedUpdateWithoutCrewsInput>
    create: XOR<work_order_crewCreateWithoutCrewsInput, work_order_crewUncheckedCreateWithoutCrewsInput>
  }

  export type work_order_crewUpdateWithWhereUniqueWithoutCrewsInput = {
    where: work_order_crewWhereUniqueInput
    data: XOR<work_order_crewUpdateWithoutCrewsInput, work_order_crewUncheckedUpdateWithoutCrewsInput>
  }

  export type work_order_crewUpdateManyWithWhereWithoutCrewsInput = {
    where: work_order_crewScalarWhereInput
    data: XOR<work_order_crewUpdateManyMutationInput, work_order_crewUncheckedUpdateManyWithoutCrewsInput>
  }

  export type work_order_crewScalarWhereInput = {
    AND?: work_order_crewScalarWhereInput | work_order_crewScalarWhereInput[]
    OR?: work_order_crewScalarWhereInput[]
    NOT?: work_order_crewScalarWhereInput | work_order_crewScalarWhereInput[]
    id?: BigIntFilter<"work_order_crew"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_crew"> | bigint | number
    crew_id?: BigIntFilter<"work_order_crew"> | bigint | number
    assigned_at?: StringFilter<"work_order_crew"> | string
    created_at?: StringFilter<"work_order_crew"> | string
    updated_at?: StringFilter<"work_order_crew"> | string
  }

  export type organizationsCreateWithoutCrew_membersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutCrew_membersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutCrew_membersInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutCrew_membersInput, organizationsUncheckedCreateWithoutCrew_membersInput>
  }

  export type crewsCreateWithoutCrew_membersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    created_at: string
    updated_at: string
    users: usersCreateNestedOneWithoutCrewsInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutCrewsInput
  }

  export type crewsUncheckedCreateWithoutCrew_membersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    leader_id: bigint | number
    created_at: string
    updated_at: string
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type crewsCreateOrConnectWithoutCrew_membersInput = {
    where: crewsWhereUniqueInput
    create: XOR<crewsCreateWithoutCrew_membersInput, crewsUncheckedCreateWithoutCrew_membersInput>
  }

  export type usersCreateWithoutCrew_membersInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    organizations: organizationsCreateNestedOneWithoutUsersInput
    user_skills?: user_skillsCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsCreateNestedManyWithoutUsersInput
    crews?: crewsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCrew_membersInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsUncheckedCreateNestedManyWithoutUsersInput
    crews?: crewsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCrew_membersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCrew_membersInput, usersUncheckedCreateWithoutCrew_membersInput>
  }

  export type organizationsUpsertWithoutCrew_membersInput = {
    update: XOR<organizationsUpdateWithoutCrew_membersInput, organizationsUncheckedUpdateWithoutCrew_membersInput>
    create: XOR<organizationsCreateWithoutCrew_membersInput, organizationsUncheckedCreateWithoutCrew_membersInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutCrew_membersInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutCrew_membersInput, organizationsUncheckedUpdateWithoutCrew_membersInput>
  }

  export type organizationsUpdateWithoutCrew_membersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutCrew_membersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type crewsUpsertWithoutCrew_membersInput = {
    update: XOR<crewsUpdateWithoutCrew_membersInput, crewsUncheckedUpdateWithoutCrew_membersInput>
    create: XOR<crewsCreateWithoutCrew_membersInput, crewsUncheckedCreateWithoutCrew_membersInput>
    where?: crewsWhereInput
  }

  export type crewsUpdateToOneWithWhereWithoutCrew_membersInput = {
    where?: crewsWhereInput
    data: XOR<crewsUpdateWithoutCrew_membersInput, crewsUncheckedUpdateWithoutCrew_membersInput>
  }

  export type crewsUpdateWithoutCrew_membersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutCrewsNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutCrewsNestedInput
  }

  export type crewsUncheckedUpdateWithoutCrew_membersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type usersUpsertWithoutCrew_membersInput = {
    update: XOR<usersUpdateWithoutCrew_membersInput, usersUncheckedUpdateWithoutCrew_membersInput>
    create: XOR<usersCreateWithoutCrew_membersInput, usersUncheckedCreateWithoutCrew_membersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCrew_membersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCrew_membersInput, usersUncheckedUpdateWithoutCrew_membersInput>
  }

  export type usersUpdateWithoutCrew_membersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    user_skills?: user_skillsUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUpdateManyWithoutUsersNestedInput
    crews?: crewsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCrew_membersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput
    crews?: crewsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type organizationsCreateWithoutEquipmentsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutEquipmentsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutEquipmentsInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutEquipmentsInput, organizationsUncheckedCreateWithoutEquipmentsInput>
  }

  export type organizationsUpsertWithoutEquipmentsInput = {
    update: XOR<organizationsUpdateWithoutEquipmentsInput, organizationsUncheckedUpdateWithoutEquipmentsInput>
    create: XOR<organizationsCreateWithoutEquipmentsInput, organizationsUncheckedCreateWithoutEquipmentsInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutEquipmentsInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutEquipmentsInput, organizationsUncheckedUpdateWithoutEquipmentsInput>
  }

  export type organizationsUpdateWithoutEquipmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutEquipmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutCompaniesInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutCompaniesInput, organizationsUncheckedCreateWithoutCompaniesInput>
  }

  export type customersCreateWithoutCompaniesInput = {
    id?: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCustomersInput
    assets?: assetsCreateNestedManyWithoutCustomersInput
    work_orders?: work_ordersCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    organization_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    assets?: assetsUncheckedCreateNestedManyWithoutCustomersInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutCompaniesInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutCompaniesInput, customersUncheckedCreateWithoutCompaniesInput>
  }

  export type customersCreateManyCompaniesInputEnvelope = {
    data: customersCreateManyCompaniesInput | customersCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type work_ordersCreateWithoutCompaniesInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutCompaniesInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutCompaniesInput, work_ordersUncheckedCreateWithoutCompaniesInput>
  }

  export type work_ordersCreateManyCompaniesInputEnvelope = {
    data: work_ordersCreateManyCompaniesInput | work_ordersCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutCompaniesInput = {
    update: XOR<organizationsUpdateWithoutCompaniesInput, organizationsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<organizationsCreateWithoutCompaniesInput, organizationsUncheckedCreateWithoutCompaniesInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutCompaniesInput, organizationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type organizationsUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type customersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: customersWhereUniqueInput
    update: XOR<customersUpdateWithoutCompaniesInput, customersUncheckedUpdateWithoutCompaniesInput>
    create: XOR<customersCreateWithoutCompaniesInput, customersUncheckedCreateWithoutCompaniesInput>
  }

  export type customersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: customersWhereUniqueInput
    data: XOR<customersUpdateWithoutCompaniesInput, customersUncheckedUpdateWithoutCompaniesInput>
  }

  export type customersUpdateManyWithWhereWithoutCompaniesInput = {
    where: customersScalarWhereInput
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type work_ordersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: work_ordersWhereUniqueInput
    update: XOR<work_ordersUpdateWithoutCompaniesInput, work_ordersUncheckedUpdateWithoutCompaniesInput>
    create: XOR<work_ordersCreateWithoutCompaniesInput, work_ordersUncheckedCreateWithoutCompaniesInput>
  }

  export type work_ordersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: work_ordersWhereUniqueInput
    data: XOR<work_ordersUpdateWithoutCompaniesInput, work_ordersUncheckedUpdateWithoutCompaniesInput>
  }

  export type work_ordersUpdateManyWithWhereWithoutCompaniesInput = {
    where: work_ordersScalarWhereInput
    data: XOR<work_ordersUpdateManyMutationInput, work_ordersUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type organizationsCreateWithoutCustomersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutCustomersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutCustomersInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutCustomersInput, organizationsUncheckedCreateWithoutCustomersInput>
  }

  export type companiesCreateWithoutCustomersInput = {
    id?: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCompaniesInput
    work_orders?: work_ordersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCustomersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCustomersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCustomersInput, companiesUncheckedCreateWithoutCustomersInput>
  }

  export type assetsCreateWithoutCustomersInput = {
    id?: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutAssetsInput
    work_orders?: work_ordersCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutCustomersInput = {
    id?: bigint | number
    organization_id: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutCustomersInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutCustomersInput, assetsUncheckedCreateWithoutCustomersInput>
  }

  export type assetsCreateManyCustomersInputEnvelope = {
    data: assetsCreateManyCustomersInput | assetsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type work_ordersCreateWithoutCustomersInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutCustomersInput = {
    id?: bigint | number
    organization_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutCustomersInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutCustomersInput, work_ordersUncheckedCreateWithoutCustomersInput>
  }

  export type work_ordersCreateManyCustomersInputEnvelope = {
    data: work_ordersCreateManyCustomersInput | work_ordersCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutCustomersInput = {
    update: XOR<organizationsUpdateWithoutCustomersInput, organizationsUncheckedUpdateWithoutCustomersInput>
    create: XOR<organizationsCreateWithoutCustomersInput, organizationsUncheckedCreateWithoutCustomersInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutCustomersInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutCustomersInput, organizationsUncheckedUpdateWithoutCustomersInput>
  }

  export type organizationsUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type companiesUpsertWithoutCustomersInput = {
    update: XOR<companiesUpdateWithoutCustomersInput, companiesUncheckedUpdateWithoutCustomersInput>
    create: XOR<companiesCreateWithoutCustomersInput, companiesUncheckedCreateWithoutCustomersInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCustomersInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCustomersInput, companiesUncheckedUpdateWithoutCustomersInput>
  }

  export type companiesUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCompaniesNestedInput
    work_orders?: work_ordersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type assetsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: assetsWhereUniqueInput
    update: XOR<assetsUpdateWithoutCustomersInput, assetsUncheckedUpdateWithoutCustomersInput>
    create: XOR<assetsCreateWithoutCustomersInput, assetsUncheckedCreateWithoutCustomersInput>
  }

  export type assetsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: assetsWhereUniqueInput
    data: XOR<assetsUpdateWithoutCustomersInput, assetsUncheckedUpdateWithoutCustomersInput>
  }

  export type assetsUpdateManyWithWhereWithoutCustomersInput = {
    where: assetsScalarWhereInput
    data: XOR<assetsUpdateManyMutationInput, assetsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type work_ordersUpsertWithWhereUniqueWithoutCustomersInput = {
    where: work_ordersWhereUniqueInput
    update: XOR<work_ordersUpdateWithoutCustomersInput, work_ordersUncheckedUpdateWithoutCustomersInput>
    create: XOR<work_ordersCreateWithoutCustomersInput, work_ordersUncheckedCreateWithoutCustomersInput>
  }

  export type work_ordersUpdateWithWhereUniqueWithoutCustomersInput = {
    where: work_ordersWhereUniqueInput
    data: XOR<work_ordersUpdateWithoutCustomersInput, work_ordersUncheckedUpdateWithoutCustomersInput>
  }

  export type work_ordersUpdateManyWithWhereWithoutCustomersInput = {
    where: work_ordersScalarWhereInput
    data: XOR<work_ordersUpdateManyMutationInput, work_ordersUncheckedUpdateManyWithoutCustomersInput>
  }

  export type organizationsCreateWithoutServicesInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutServicesInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutServicesInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutServicesInput, organizationsUncheckedCreateWithoutServicesInput>
  }

  export type work_order_servicesCreateWithoutServicesInput = {
    id?: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutWork_order_servicesInput
  }

  export type work_order_servicesUncheckedCreateWithoutServicesInput = {
    id?: bigint | number
    work_order_id: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
  }

  export type work_order_servicesCreateOrConnectWithoutServicesInput = {
    where: work_order_servicesWhereUniqueInput
    create: XOR<work_order_servicesCreateWithoutServicesInput, work_order_servicesUncheckedCreateWithoutServicesInput>
  }

  export type work_order_servicesCreateManyServicesInputEnvelope = {
    data: work_order_servicesCreateManyServicesInput | work_order_servicesCreateManyServicesInput[]
    skipDuplicates?: boolean
  }

  export type invoice_itemsCreateWithoutServicesInput = {
    id?: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
    invoices: invoicesCreateNestedOneWithoutInvoice_itemsInput
    parts: partsCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateWithoutServicesInput = {
    id?: bigint | number
    invoice_id: bigint | number
    part_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsCreateOrConnectWithoutServicesInput = {
    where: invoice_itemsWhereUniqueInput
    create: XOR<invoice_itemsCreateWithoutServicesInput, invoice_itemsUncheckedCreateWithoutServicesInput>
  }

  export type invoice_itemsCreateManyServicesInputEnvelope = {
    data: invoice_itemsCreateManyServicesInput | invoice_itemsCreateManyServicesInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutServicesInput = {
    update: XOR<organizationsUpdateWithoutServicesInput, organizationsUncheckedUpdateWithoutServicesInput>
    create: XOR<organizationsCreateWithoutServicesInput, organizationsUncheckedCreateWithoutServicesInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutServicesInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutServicesInput, organizationsUncheckedUpdateWithoutServicesInput>
  }

  export type organizationsUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type work_order_servicesUpsertWithWhereUniqueWithoutServicesInput = {
    where: work_order_servicesWhereUniqueInput
    update: XOR<work_order_servicesUpdateWithoutServicesInput, work_order_servicesUncheckedUpdateWithoutServicesInput>
    create: XOR<work_order_servicesCreateWithoutServicesInput, work_order_servicesUncheckedCreateWithoutServicesInput>
  }

  export type work_order_servicesUpdateWithWhereUniqueWithoutServicesInput = {
    where: work_order_servicesWhereUniqueInput
    data: XOR<work_order_servicesUpdateWithoutServicesInput, work_order_servicesUncheckedUpdateWithoutServicesInput>
  }

  export type work_order_servicesUpdateManyWithWhereWithoutServicesInput = {
    where: work_order_servicesScalarWhereInput
    data: XOR<work_order_servicesUpdateManyMutationInput, work_order_servicesUncheckedUpdateManyWithoutServicesInput>
  }

  export type work_order_servicesScalarWhereInput = {
    AND?: work_order_servicesScalarWhereInput | work_order_servicesScalarWhereInput[]
    OR?: work_order_servicesScalarWhereInput[]
    NOT?: work_order_servicesScalarWhereInput | work_order_servicesScalarWhereInput[]
    id?: BigIntFilter<"work_order_services"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_services"> | bigint | number
    service_id?: BigIntFilter<"work_order_services"> | bigint | number
    quantity?: IntFilter<"work_order_services"> | number
    service_cost?: DecimalFilter<"work_order_services"> | Decimal | DecimalJsLike | number | string
    created_at?: StringFilter<"work_order_services"> | string
    updated_at?: StringFilter<"work_order_services"> | string
  }

  export type invoice_itemsUpsertWithWhereUniqueWithoutServicesInput = {
    where: invoice_itemsWhereUniqueInput
    update: XOR<invoice_itemsUpdateWithoutServicesInput, invoice_itemsUncheckedUpdateWithoutServicesInput>
    create: XOR<invoice_itemsCreateWithoutServicesInput, invoice_itemsUncheckedCreateWithoutServicesInput>
  }

  export type invoice_itemsUpdateWithWhereUniqueWithoutServicesInput = {
    where: invoice_itemsWhereUniqueInput
    data: XOR<invoice_itemsUpdateWithoutServicesInput, invoice_itemsUncheckedUpdateWithoutServicesInput>
  }

  export type invoice_itemsUpdateManyWithWhereWithoutServicesInput = {
    where: invoice_itemsScalarWhereInput
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyWithoutServicesInput>
  }

  export type invoice_itemsScalarWhereInput = {
    AND?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
    OR?: invoice_itemsScalarWhereInput[]
    NOT?: invoice_itemsScalarWhereInput | invoice_itemsScalarWhereInput[]
    id?: BigIntFilter<"invoice_items"> | bigint | number
    invoice_id?: BigIntFilter<"invoice_items"> | bigint | number
    service_id?: BigIntFilter<"invoice_items"> | bigint | number
    part_id?: BigIntFilter<"invoice_items"> | bigint | number
    quantity?: IntFilter<"invoice_items"> | number
    unit_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFilter<"invoice_items"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"invoice_items"> | string
    created_at?: StringFilter<"invoice_items"> | string
    updated_at?: StringFilter<"invoice_items"> | string
  }

  export type organizationsCreateWithoutAssetsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutAssetsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutAssetsInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutAssetsInput, organizationsUncheckedCreateWithoutAssetsInput>
  }

  export type customersCreateWithoutAssetsInput = {
    id?: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCustomersInput
    companies: companiesCreateNestedOneWithoutCustomersInput
    work_orders?: work_ordersCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutAssetsInput = {
    id?: bigint | number
    organization_id: bigint | number
    company_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutAssetsInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutAssetsInput, customersUncheckedCreateWithoutAssetsInput>
  }

  export type work_ordersCreateWithoutAssetsInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutAssetsInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutAssetsInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutAssetsInput, work_ordersUncheckedCreateWithoutAssetsInput>
  }

  export type work_ordersCreateManyAssetsInputEnvelope = {
    data: work_ordersCreateManyAssetsInput | work_ordersCreateManyAssetsInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutAssetsInput = {
    update: XOR<organizationsUpdateWithoutAssetsInput, organizationsUncheckedUpdateWithoutAssetsInput>
    create: XOR<organizationsCreateWithoutAssetsInput, organizationsUncheckedCreateWithoutAssetsInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutAssetsInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutAssetsInput, organizationsUncheckedUpdateWithoutAssetsInput>
  }

  export type organizationsUpdateWithoutAssetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutAssetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type customersUpsertWithoutAssetsInput = {
    update: XOR<customersUpdateWithoutAssetsInput, customersUncheckedUpdateWithoutAssetsInput>
    create: XOR<customersCreateWithoutAssetsInput, customersUncheckedCreateWithoutAssetsInput>
    where?: customersWhereInput
  }

  export type customersUpdateToOneWithWhereWithoutAssetsInput = {
    where?: customersWhereInput
    data: XOR<customersUpdateWithoutAssetsInput, customersUncheckedUpdateWithoutAssetsInput>
  }

  export type customersUpdateWithoutAssetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCustomersNestedInput
    companies?: companiesUpdateOneRequiredWithoutCustomersNestedInput
    work_orders?: work_ordersUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateWithoutAssetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type work_ordersUpsertWithWhereUniqueWithoutAssetsInput = {
    where: work_ordersWhereUniqueInput
    update: XOR<work_ordersUpdateWithoutAssetsInput, work_ordersUncheckedUpdateWithoutAssetsInput>
    create: XOR<work_ordersCreateWithoutAssetsInput, work_ordersUncheckedCreateWithoutAssetsInput>
  }

  export type work_ordersUpdateWithWhereUniqueWithoutAssetsInput = {
    where: work_ordersWhereUniqueInput
    data: XOR<work_ordersUpdateWithoutAssetsInput, work_ordersUncheckedUpdateWithoutAssetsInput>
  }

  export type work_ordersUpdateManyWithWhereWithoutAssetsInput = {
    where: work_ordersScalarWhereInput
    data: XOR<work_ordersUpdateManyMutationInput, work_ordersUncheckedUpdateManyWithoutAssetsInput>
  }

  export type organizationsCreateWithoutPartsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutPartsInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutPartsInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutPartsInput, organizationsUncheckedCreateWithoutPartsInput>
  }

  export type invoice_itemsCreateWithoutPartsInput = {
    id?: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
    invoices: invoicesCreateNestedOneWithoutInvoice_itemsInput
    services: servicesCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateWithoutPartsInput = {
    id?: bigint | number
    invoice_id: bigint | number
    service_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsCreateOrConnectWithoutPartsInput = {
    where: invoice_itemsWhereUniqueInput
    create: XOR<invoice_itemsCreateWithoutPartsInput, invoice_itemsUncheckedCreateWithoutPartsInput>
  }

  export type invoice_itemsCreateManyPartsInputEnvelope = {
    data: invoice_itemsCreateManyPartsInput | invoice_itemsCreateManyPartsInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutPartsInput = {
    update: XOR<organizationsUpdateWithoutPartsInput, organizationsUncheckedUpdateWithoutPartsInput>
    create: XOR<organizationsCreateWithoutPartsInput, organizationsUncheckedCreateWithoutPartsInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutPartsInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutPartsInput, organizationsUncheckedUpdateWithoutPartsInput>
  }

  export type organizationsUpdateWithoutPartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutPartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type invoice_itemsUpsertWithWhereUniqueWithoutPartsInput = {
    where: invoice_itemsWhereUniqueInput
    update: XOR<invoice_itemsUpdateWithoutPartsInput, invoice_itemsUncheckedUpdateWithoutPartsInput>
    create: XOR<invoice_itemsCreateWithoutPartsInput, invoice_itemsUncheckedCreateWithoutPartsInput>
  }

  export type invoice_itemsUpdateWithWhereUniqueWithoutPartsInput = {
    where: invoice_itemsWhereUniqueInput
    data: XOR<invoice_itemsUpdateWithoutPartsInput, invoice_itemsUncheckedUpdateWithoutPartsInput>
  }

  export type invoice_itemsUpdateManyWithWhereWithoutPartsInput = {
    where: invoice_itemsScalarWhereInput
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyWithoutPartsInput>
  }

  export type organizationsCreateWithoutMaintenance_plansInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutMaintenance_plansInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutMaintenance_plansInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutMaintenance_plansInput, organizationsUncheckedCreateWithoutMaintenance_plansInput>
  }

  export type maintenance_plan_assetsCreateWithoutMaintenance_plansInput = {
    id?: bigint | number
    asset_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput = {
    id?: bigint | number
    asset_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type maintenance_plan_assetsCreateOrConnectWithoutMaintenance_plansInput = {
    where: maintenance_plan_assetsWhereUniqueInput
    create: XOR<maintenance_plan_assetsCreateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput>
  }

  export type maintenance_plan_assetsCreateManyMaintenance_plansInputEnvelope = {
    data: maintenance_plan_assetsCreateManyMaintenance_plansInput | maintenance_plan_assetsCreateManyMaintenance_plansInput[]
    skipDuplicates?: boolean
  }

  export type work_ordersCreateWithoutMaintenance_plansInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutMaintenance_plansInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutMaintenance_plansInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutMaintenance_plansInput, work_ordersUncheckedCreateWithoutMaintenance_plansInput>
  }

  export type work_ordersCreateManyMaintenance_plansInputEnvelope = {
    data: work_ordersCreateManyMaintenance_plansInput | work_ordersCreateManyMaintenance_plansInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutMaintenance_plansInput = {
    update: XOR<organizationsUpdateWithoutMaintenance_plansInput, organizationsUncheckedUpdateWithoutMaintenance_plansInput>
    create: XOR<organizationsCreateWithoutMaintenance_plansInput, organizationsUncheckedCreateWithoutMaintenance_plansInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutMaintenance_plansInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutMaintenance_plansInput, organizationsUncheckedUpdateWithoutMaintenance_plansInput>
  }

  export type organizationsUpdateWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type maintenance_plan_assetsUpsertWithWhereUniqueWithoutMaintenance_plansInput = {
    where: maintenance_plan_assetsWhereUniqueInput
    update: XOR<maintenance_plan_assetsUpdateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedUpdateWithoutMaintenance_plansInput>
    create: XOR<maintenance_plan_assetsCreateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedCreateWithoutMaintenance_plansInput>
  }

  export type maintenance_plan_assetsUpdateWithWhereUniqueWithoutMaintenance_plansInput = {
    where: maintenance_plan_assetsWhereUniqueInput
    data: XOR<maintenance_plan_assetsUpdateWithoutMaintenance_plansInput, maintenance_plan_assetsUncheckedUpdateWithoutMaintenance_plansInput>
  }

  export type maintenance_plan_assetsUpdateManyWithWhereWithoutMaintenance_plansInput = {
    where: maintenance_plan_assetsScalarWhereInput
    data: XOR<maintenance_plan_assetsUpdateManyMutationInput, maintenance_plan_assetsUncheckedUpdateManyWithoutMaintenance_plansInput>
  }

  export type maintenance_plan_assetsScalarWhereInput = {
    AND?: maintenance_plan_assetsScalarWhereInput | maintenance_plan_assetsScalarWhereInput[]
    OR?: maintenance_plan_assetsScalarWhereInput[]
    NOT?: maintenance_plan_assetsScalarWhereInput | maintenance_plan_assetsScalarWhereInput[]
    id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    maintenance_plan_id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    asset_id?: BigIntFilter<"maintenance_plan_assets"> | bigint | number
    assigned_at?: StringFilter<"maintenance_plan_assets"> | string
    created_at?: StringFilter<"maintenance_plan_assets"> | string
    updated_at?: StringFilter<"maintenance_plan_assets"> | string
  }

  export type work_ordersUpsertWithWhereUniqueWithoutMaintenance_plansInput = {
    where: work_ordersWhereUniqueInput
    update: XOR<work_ordersUpdateWithoutMaintenance_plansInput, work_ordersUncheckedUpdateWithoutMaintenance_plansInput>
    create: XOR<work_ordersCreateWithoutMaintenance_plansInput, work_ordersUncheckedCreateWithoutMaintenance_plansInput>
  }

  export type work_ordersUpdateWithWhereUniqueWithoutMaintenance_plansInput = {
    where: work_ordersWhereUniqueInput
    data: XOR<work_ordersUpdateWithoutMaintenance_plansInput, work_ordersUncheckedUpdateWithoutMaintenance_plansInput>
  }

  export type work_ordersUpdateManyWithWhereWithoutMaintenance_plansInput = {
    where: work_ordersScalarWhereInput
    data: XOR<work_ordersUpdateManyMutationInput, work_ordersUncheckedUpdateManyWithoutMaintenance_plansInput>
  }

  export type maintenance_plansCreateWithoutMaintenance_plan_assetsInput = {
    id?: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutMaintenance_plansInput
    work_orders?: work_ordersCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansUncheckedCreateWithoutMaintenance_plan_assetsInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    work_orders?: work_ordersUncheckedCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansCreateOrConnectWithoutMaintenance_plan_assetsInput = {
    where: maintenance_plansWhereUniqueInput
    create: XOR<maintenance_plansCreateWithoutMaintenance_plan_assetsInput, maintenance_plansUncheckedCreateWithoutMaintenance_plan_assetsInput>
  }

  export type maintenance_plansUpsertWithoutMaintenance_plan_assetsInput = {
    update: XOR<maintenance_plansUpdateWithoutMaintenance_plan_assetsInput, maintenance_plansUncheckedUpdateWithoutMaintenance_plan_assetsInput>
    create: XOR<maintenance_plansCreateWithoutMaintenance_plan_assetsInput, maintenance_plansUncheckedCreateWithoutMaintenance_plan_assetsInput>
    where?: maintenance_plansWhereInput
  }

  export type maintenance_plansUpdateToOneWithWhereWithoutMaintenance_plan_assetsInput = {
    where?: maintenance_plansWhereInput
    data: XOR<maintenance_plansUpdateWithoutMaintenance_plan_assetsInput, maintenance_plansUncheckedUpdateWithoutMaintenance_plan_assetsInput>
  }

  export type maintenance_plansUpdateWithoutMaintenance_plan_assetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutMaintenance_plansNestedInput
    work_orders?: work_ordersUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type maintenance_plansUncheckedUpdateWithoutMaintenance_plan_assetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUncheckedUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type organizationsCreateWithoutWork_ordersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsCreateNestedManyWithoutOrganizationsInput
    companies?: companiesCreateNestedManyWithoutOrganizationsInput
    customers?: customersCreateNestedManyWithoutOrganizationsInput
    services?: servicesCreateNestedManyWithoutOrganizationsInput
    assets?: assetsCreateNestedManyWithoutOrganizationsInput
    parts?: partsCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    name: string
    email: string
    address?: string
    phone?: string
    organization_name?: string
    industry_name?: string
    pincode?: string
    website?: string
    timezone?: string
    plan_type?: $Enums.PlanType
    subscription_start_date?: string
    subscription_end_date?: string
    file_storage_limit?: bigint | number
    data_storage_limit?: bigint | number
    created_at?: string
    updated_at?: string
    currencyid?: bigint | number
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutOrganizationsInput
    business_hours?: business_hoursUncheckedCreateNestedManyWithoutOrganizationsInput
    holidays?: holidaysUncheckedCreateNestedManyWithoutOrganizationsInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutOrganizationsInput
    equipments?: equipmentsUncheckedCreateNestedManyWithoutOrganizationsInput
    companies?: companiesUncheckedCreateNestedManyWithoutOrganizationsInput
    customers?: customersUncheckedCreateNestedManyWithoutOrganizationsInput
    services?: servicesUncheckedCreateNestedManyWithoutOrganizationsInput
    assets?: assetsUncheckedCreateNestedManyWithoutOrganizationsInput
    parts?: partsUncheckedCreateNestedManyWithoutOrganizationsInput
    maintenance_plans?: maintenance_plansUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutWork_ordersInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutWork_ordersInput, organizationsUncheckedCreateWithoutWork_ordersInput>
  }

  export type customersCreateWithoutWork_ordersInput = {
    id?: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCustomersInput
    companies: companiesCreateNestedOneWithoutCustomersInput
    assets?: assetsCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    organization_id: bigint | number
    company_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
    assets?: assetsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersCreateOrConnectWithoutWork_ordersInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutWork_ordersInput, customersUncheckedCreateWithoutWork_ordersInput>
  }

  export type companiesCreateWithoutWork_ordersInput = {
    id?: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutCompaniesInput
    customers?: customersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
    customers?: customersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutWork_ordersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutWork_ordersInput, companiesUncheckedCreateWithoutWork_ordersInput>
  }

  export type assetsCreateWithoutWork_ordersInput = {
    id?: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutAssetsInput
    customers: customersCreateNestedOneWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
  }

  export type assetsCreateOrConnectWithoutWork_ordersInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutWork_ordersInput, assetsUncheckedCreateWithoutWork_ordersInput>
  }

  export type maintenance_plansCreateWithoutWork_ordersInput = {
    id?: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutMaintenance_plansInput
    maintenance_plan_assets?: maintenance_plan_assetsCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
    maintenance_plan_assets?: maintenance_plan_assetsUncheckedCreateNestedManyWithoutMaintenance_plansInput
  }

  export type maintenance_plansCreateOrConnectWithoutWork_ordersInput = {
    where: maintenance_plansWhereUniqueInput
    create: XOR<maintenance_plansCreateWithoutWork_ordersInput, maintenance_plansUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_servicesCreateWithoutWork_ordersInput = {
    id?: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
    services: servicesCreateNestedOneWithoutWork_order_servicesInput
  }

  export type work_order_servicesUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    service_id: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
  }

  export type work_order_servicesCreateOrConnectWithoutWork_ordersInput = {
    where: work_order_servicesWhereUniqueInput
    create: XOR<work_order_servicesCreateWithoutWork_ordersInput, work_order_servicesUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_servicesCreateManyWork_ordersInputEnvelope = {
    data: work_order_servicesCreateManyWork_ordersInput | work_order_servicesCreateManyWork_ordersInput[]
    skipDuplicates?: boolean
  }

  export type work_order_tasksCreateWithoutWork_ordersInput = {
    id?: bigint | number
    task_name: string
    task_description: string
    assigned_to: bigint | number
    status?: $Enums.WorkOrderTaskStatus
    due_date: string
    created_at: string
    updated_at: string
  }

  export type work_order_tasksUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    task_name: string
    task_description: string
    assigned_to: bigint | number
    status?: $Enums.WorkOrderTaskStatus
    due_date: string
    created_at: string
    updated_at: string
  }

  export type work_order_tasksCreateOrConnectWithoutWork_ordersInput = {
    where: work_order_tasksWhereUniqueInput
    create: XOR<work_order_tasksCreateWithoutWork_ordersInput, work_order_tasksUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_tasksCreateManyWork_ordersInputEnvelope = {
    data: work_order_tasksCreateManyWork_ordersInput | work_order_tasksCreateManyWork_ordersInput[]
    skipDuplicates?: boolean
  }

  export type work_order_assetsCreateWithoutWork_ordersInput = {
    id?: bigint | number
    asset_id: bigint | number
    quantity: number
    created_at: string
    updated_at: string
  }

  export type work_order_assetsUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    asset_id: bigint | number
    quantity: number
    created_at: string
    updated_at: string
  }

  export type work_order_assetsCreateOrConnectWithoutWork_ordersInput = {
    where: work_order_assetsWhereUniqueInput
    create: XOR<work_order_assetsCreateWithoutWork_ordersInput, work_order_assetsUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_assetsCreateManyWork_ordersInputEnvelope = {
    data: work_order_assetsCreateManyWork_ordersInput | work_order_assetsCreateManyWork_ordersInput[]
    skipDuplicates?: boolean
  }

  export type work_order_crewCreateWithoutWork_ordersInput = {
    id?: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
    crews: crewsCreateNestedOneWithoutWork_order_crewInput
  }

  export type work_order_crewUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    crew_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_crewCreateOrConnectWithoutWork_ordersInput = {
    where: work_order_crewWhereUniqueInput
    create: XOR<work_order_crewCreateWithoutWork_ordersInput, work_order_crewUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_crewCreateManyWork_ordersInputEnvelope = {
    data: work_order_crewCreateManyWork_ordersInput | work_order_crewCreateManyWork_ordersInput[]
    skipDuplicates?: boolean
  }

  export type work_order_approvalsCreateWithoutWork_ordersInput = {
    id?: bigint | number
    approved_by: bigint | number
    approval_status: $Enums.ApprovalStatus
    approved_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_approvalsUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    approved_by: bigint | number
    approval_status: $Enums.ApprovalStatus
    approved_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_approvalsCreateOrConnectWithoutWork_ordersInput = {
    where: work_order_approvalsWhereUniqueInput
    create: XOR<work_order_approvalsCreateWithoutWork_ordersInput, work_order_approvalsUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_approvalsCreateManyWork_ordersInputEnvelope = {
    data: work_order_approvalsCreateManyWork_ordersInput | work_order_approvalsCreateManyWork_ordersInput[]
    skipDuplicates?: boolean
  }

  export type invoicesCreateWithoutWork_ordersInput = {
    id?: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutWork_ordersInput = {
    id?: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutWork_ordersInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutWork_ordersInput, invoicesUncheckedCreateWithoutWork_ordersInput>
  }

  export type invoicesCreateManyWork_ordersInputEnvelope = {
    data: invoicesCreateManyWork_ordersInput | invoicesCreateManyWork_ordersInput[]
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithoutWork_ordersInput = {
    update: XOR<organizationsUpdateWithoutWork_ordersInput, organizationsUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<organizationsCreateWithoutWork_ordersInput, organizationsUncheckedCreateWithoutWork_ordersInput>
    where?: organizationsWhereInput
  }

  export type organizationsUpdateToOneWithWhereWithoutWork_ordersInput = {
    where?: organizationsWhereInput
    data: XOR<organizationsUpdateWithoutWork_ordersInput, organizationsUncheckedUpdateWithoutWork_ordersInput>
  }

  export type organizationsUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    organization_name?: StringFieldUpdateOperationsInput | string
    industry_name?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    plan_type?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscription_start_date?: StringFieldUpdateOperationsInput | string
    subscription_end_date?: StringFieldUpdateOperationsInput | string
    file_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    data_storage_limit?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    currencyid?: BigIntFieldUpdateOperationsInput | bigint | number
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    user_skills?: user_skillsUncheckedUpdateManyWithoutOrganizationsNestedInput
    business_hours?: business_hoursUncheckedUpdateManyWithoutOrganizationsNestedInput
    holidays?: holidaysUncheckedUpdateManyWithoutOrganizationsNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutOrganizationsNestedInput
    equipments?: equipmentsUncheckedUpdateManyWithoutOrganizationsNestedInput
    companies?: companiesUncheckedUpdateManyWithoutOrganizationsNestedInput
    customers?: customersUncheckedUpdateManyWithoutOrganizationsNestedInput
    services?: servicesUncheckedUpdateManyWithoutOrganizationsNestedInput
    assets?: assetsUncheckedUpdateManyWithoutOrganizationsNestedInput
    parts?: partsUncheckedUpdateManyWithoutOrganizationsNestedInput
    maintenance_plans?: maintenance_plansUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type customersUpsertWithoutWork_ordersInput = {
    update: XOR<customersUpdateWithoutWork_ordersInput, customersUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<customersCreateWithoutWork_ordersInput, customersUncheckedCreateWithoutWork_ordersInput>
    where?: customersWhereInput
  }

  export type customersUpdateToOneWithWhereWithoutWork_ordersInput = {
    where?: customersWhereInput
    data: XOR<customersUpdateWithoutWork_ordersInput, customersUncheckedUpdateWithoutWork_ordersInput>
  }

  export type customersUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCustomersNestedInput
    companies?: companiesUpdateOneRequiredWithoutCustomersNestedInput
    assets?: assetsUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    assets?: assetsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type companiesUpsertWithoutWork_ordersInput = {
    update: XOR<companiesUpdateWithoutWork_ordersInput, companiesUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<companiesCreateWithoutWork_ordersInput, companiesUncheckedCreateWithoutWork_ordersInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutWork_ordersInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutWork_ordersInput, companiesUncheckedUpdateWithoutWork_ordersInput>
  }

  export type companiesUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCompaniesNestedInput
    customers?: customersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    customers?: customersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type assetsUpsertWithoutWork_ordersInput = {
    update: XOR<assetsUpdateWithoutWork_ordersInput, assetsUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<assetsCreateWithoutWork_ordersInput, assetsUncheckedCreateWithoutWork_ordersInput>
    where?: assetsWhereInput
  }

  export type assetsUpdateToOneWithWhereWithoutWork_ordersInput = {
    where?: assetsWhereInput
    data: XOR<assetsUpdateWithoutWork_ordersInput, assetsUncheckedUpdateWithoutWork_ordersInput>
  }

  export type assetsUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutAssetsNestedInput
    customers?: customersUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plansUpsertWithoutWork_ordersInput = {
    update: XOR<maintenance_plansUpdateWithoutWork_ordersInput, maintenance_plansUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<maintenance_plansCreateWithoutWork_ordersInput, maintenance_plansUncheckedCreateWithoutWork_ordersInput>
    where?: maintenance_plansWhereInput
  }

  export type maintenance_plansUpdateToOneWithWhereWithoutWork_ordersInput = {
    where?: maintenance_plansWhereInput
    data: XOR<maintenance_plansUpdateWithoutWork_ordersInput, maintenance_plansUncheckedUpdateWithoutWork_ordersInput>
  }

  export type maintenance_plansUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutMaintenance_plansNestedInput
    maintenance_plan_assets?: maintenance_plan_assetsUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type maintenance_plansUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    maintenance_plan_assets?: maintenance_plan_assetsUncheckedUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type work_order_servicesUpsertWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_servicesWhereUniqueInput
    update: XOR<work_order_servicesUpdateWithoutWork_ordersInput, work_order_servicesUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<work_order_servicesCreateWithoutWork_ordersInput, work_order_servicesUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_servicesUpdateWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_servicesWhereUniqueInput
    data: XOR<work_order_servicesUpdateWithoutWork_ordersInput, work_order_servicesUncheckedUpdateWithoutWork_ordersInput>
  }

  export type work_order_servicesUpdateManyWithWhereWithoutWork_ordersInput = {
    where: work_order_servicesScalarWhereInput
    data: XOR<work_order_servicesUpdateManyMutationInput, work_order_servicesUncheckedUpdateManyWithoutWork_ordersInput>
  }

  export type work_order_tasksUpsertWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_tasksWhereUniqueInput
    update: XOR<work_order_tasksUpdateWithoutWork_ordersInput, work_order_tasksUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<work_order_tasksCreateWithoutWork_ordersInput, work_order_tasksUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_tasksUpdateWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_tasksWhereUniqueInput
    data: XOR<work_order_tasksUpdateWithoutWork_ordersInput, work_order_tasksUncheckedUpdateWithoutWork_ordersInput>
  }

  export type work_order_tasksUpdateManyWithWhereWithoutWork_ordersInput = {
    where: work_order_tasksScalarWhereInput
    data: XOR<work_order_tasksUpdateManyMutationInput, work_order_tasksUncheckedUpdateManyWithoutWork_ordersInput>
  }

  export type work_order_tasksScalarWhereInput = {
    AND?: work_order_tasksScalarWhereInput | work_order_tasksScalarWhereInput[]
    OR?: work_order_tasksScalarWhereInput[]
    NOT?: work_order_tasksScalarWhereInput | work_order_tasksScalarWhereInput[]
    id?: BigIntFilter<"work_order_tasks"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_tasks"> | bigint | number
    task_name?: StringFilter<"work_order_tasks"> | string
    task_description?: StringFilter<"work_order_tasks"> | string
    assigned_to?: BigIntFilter<"work_order_tasks"> | bigint | number
    status?: EnumWorkOrderTaskStatusFilter<"work_order_tasks"> | $Enums.WorkOrderTaskStatus
    due_date?: StringFilter<"work_order_tasks"> | string
    created_at?: StringFilter<"work_order_tasks"> | string
    updated_at?: StringFilter<"work_order_tasks"> | string
  }

  export type work_order_assetsUpsertWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_assetsWhereUniqueInput
    update: XOR<work_order_assetsUpdateWithoutWork_ordersInput, work_order_assetsUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<work_order_assetsCreateWithoutWork_ordersInput, work_order_assetsUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_assetsUpdateWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_assetsWhereUniqueInput
    data: XOR<work_order_assetsUpdateWithoutWork_ordersInput, work_order_assetsUncheckedUpdateWithoutWork_ordersInput>
  }

  export type work_order_assetsUpdateManyWithWhereWithoutWork_ordersInput = {
    where: work_order_assetsScalarWhereInput
    data: XOR<work_order_assetsUpdateManyMutationInput, work_order_assetsUncheckedUpdateManyWithoutWork_ordersInput>
  }

  export type work_order_assetsScalarWhereInput = {
    AND?: work_order_assetsScalarWhereInput | work_order_assetsScalarWhereInput[]
    OR?: work_order_assetsScalarWhereInput[]
    NOT?: work_order_assetsScalarWhereInput | work_order_assetsScalarWhereInput[]
    id?: BigIntFilter<"work_order_assets"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_assets"> | bigint | number
    asset_id?: BigIntFilter<"work_order_assets"> | bigint | number
    quantity?: IntFilter<"work_order_assets"> | number
    created_at?: StringFilter<"work_order_assets"> | string
    updated_at?: StringFilter<"work_order_assets"> | string
  }

  export type work_order_crewUpsertWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_crewWhereUniqueInput
    update: XOR<work_order_crewUpdateWithoutWork_ordersInput, work_order_crewUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<work_order_crewCreateWithoutWork_ordersInput, work_order_crewUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_crewUpdateWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_crewWhereUniqueInput
    data: XOR<work_order_crewUpdateWithoutWork_ordersInput, work_order_crewUncheckedUpdateWithoutWork_ordersInput>
  }

  export type work_order_crewUpdateManyWithWhereWithoutWork_ordersInput = {
    where: work_order_crewScalarWhereInput
    data: XOR<work_order_crewUpdateManyMutationInput, work_order_crewUncheckedUpdateManyWithoutWork_ordersInput>
  }

  export type work_order_approvalsUpsertWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_approvalsWhereUniqueInput
    update: XOR<work_order_approvalsUpdateWithoutWork_ordersInput, work_order_approvalsUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<work_order_approvalsCreateWithoutWork_ordersInput, work_order_approvalsUncheckedCreateWithoutWork_ordersInput>
  }

  export type work_order_approvalsUpdateWithWhereUniqueWithoutWork_ordersInput = {
    where: work_order_approvalsWhereUniqueInput
    data: XOR<work_order_approvalsUpdateWithoutWork_ordersInput, work_order_approvalsUncheckedUpdateWithoutWork_ordersInput>
  }

  export type work_order_approvalsUpdateManyWithWhereWithoutWork_ordersInput = {
    where: work_order_approvalsScalarWhereInput
    data: XOR<work_order_approvalsUpdateManyMutationInput, work_order_approvalsUncheckedUpdateManyWithoutWork_ordersInput>
  }

  export type work_order_approvalsScalarWhereInput = {
    AND?: work_order_approvalsScalarWhereInput | work_order_approvalsScalarWhereInput[]
    OR?: work_order_approvalsScalarWhereInput[]
    NOT?: work_order_approvalsScalarWhereInput | work_order_approvalsScalarWhereInput[]
    id?: BigIntFilter<"work_order_approvals"> | bigint | number
    work_order_id?: BigIntFilter<"work_order_approvals"> | bigint | number
    approved_by?: BigIntFilter<"work_order_approvals"> | bigint | number
    approval_status?: EnumApprovalStatusFilter<"work_order_approvals"> | $Enums.ApprovalStatus
    approved_at?: StringFilter<"work_order_approvals"> | string
    created_at?: StringFilter<"work_order_approvals"> | string
    updated_at?: StringFilter<"work_order_approvals"> | string
  }

  export type invoicesUpsertWithWhereUniqueWithoutWork_ordersInput = {
    where: invoicesWhereUniqueInput
    update: XOR<invoicesUpdateWithoutWork_ordersInput, invoicesUncheckedUpdateWithoutWork_ordersInput>
    create: XOR<invoicesCreateWithoutWork_ordersInput, invoicesUncheckedCreateWithoutWork_ordersInput>
  }

  export type invoicesUpdateWithWhereUniqueWithoutWork_ordersInput = {
    where: invoicesWhereUniqueInput
    data: XOR<invoicesUpdateWithoutWork_ordersInput, invoicesUncheckedUpdateWithoutWork_ordersInput>
  }

  export type invoicesUpdateManyWithWhereWithoutWork_ordersInput = {
    where: invoicesScalarWhereInput
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyWithoutWork_ordersInput>
  }

  export type invoicesScalarWhereInput = {
    AND?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
    OR?: invoicesScalarWhereInput[]
    NOT?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
    id?: BigIntFilter<"invoices"> | bigint | number
    work_order_id?: BigIntFilter<"invoices"> | bigint | number
    invoice_number?: StringFilter<"invoices"> | string
    invoice_date?: StringFilter<"invoices"> | string
    due_date?: StringFilter<"invoices"> | string
    total_amount?: DecimalFilter<"invoices"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"invoices"> | $Enums.InvoiceStatus
    currency_id?: IntFilter<"invoices"> | number
    created_at?: StringFilter<"invoices"> | string
    updated_at?: StringFilter<"invoices"> | string
  }

  export type work_ordersCreateWithoutWork_order_servicesInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutWork_order_servicesInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutWork_order_servicesInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutWork_order_servicesInput, work_ordersUncheckedCreateWithoutWork_order_servicesInput>
  }

  export type servicesCreateWithoutWork_order_servicesInput = {
    id?: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutServicesInput
    invoice_items?: invoice_itemsCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutWork_order_servicesInput = {
    id?: bigint | number
    organization_id: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutWork_order_servicesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutWork_order_servicesInput, servicesUncheckedCreateWithoutWork_order_servicesInput>
  }

  export type work_ordersUpsertWithoutWork_order_servicesInput = {
    update: XOR<work_ordersUpdateWithoutWork_order_servicesInput, work_ordersUncheckedUpdateWithoutWork_order_servicesInput>
    create: XOR<work_ordersCreateWithoutWork_order_servicesInput, work_ordersUncheckedCreateWithoutWork_order_servicesInput>
    where?: work_ordersWhereInput
  }

  export type work_ordersUpdateToOneWithWhereWithoutWork_order_servicesInput = {
    where?: work_ordersWhereInput
    data: XOR<work_ordersUpdateWithoutWork_order_servicesInput, work_ordersUncheckedUpdateWithoutWork_order_servicesInput>
  }

  export type work_ordersUpdateWithoutWork_order_servicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutWork_order_servicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type servicesUpsertWithoutWork_order_servicesInput = {
    update: XOR<servicesUpdateWithoutWork_order_servicesInput, servicesUncheckedUpdateWithoutWork_order_servicesInput>
    create: XOR<servicesCreateWithoutWork_order_servicesInput, servicesUncheckedCreateWithoutWork_order_servicesInput>
    where?: servicesWhereInput
  }

  export type servicesUpdateToOneWithWhereWithoutWork_order_servicesInput = {
    where?: servicesWhereInput
    data: XOR<servicesUpdateWithoutWork_order_servicesInput, servicesUncheckedUpdateWithoutWork_order_servicesInput>
  }

  export type servicesUpdateWithoutWork_order_servicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutServicesNestedInput
    invoice_items?: invoice_itemsUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutWork_order_servicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type work_ordersCreateWithoutWork_order_tasksInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutWork_order_tasksInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutWork_order_tasksInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutWork_order_tasksInput, work_ordersUncheckedCreateWithoutWork_order_tasksInput>
  }

  export type work_ordersUpsertWithoutWork_order_tasksInput = {
    update: XOR<work_ordersUpdateWithoutWork_order_tasksInput, work_ordersUncheckedUpdateWithoutWork_order_tasksInput>
    create: XOR<work_ordersCreateWithoutWork_order_tasksInput, work_ordersUncheckedCreateWithoutWork_order_tasksInput>
    where?: work_ordersWhereInput
  }

  export type work_ordersUpdateToOneWithWhereWithoutWork_order_tasksInput = {
    where?: work_ordersWhereInput
    data: XOR<work_ordersUpdateWithoutWork_order_tasksInput, work_ordersUncheckedUpdateWithoutWork_order_tasksInput>
  }

  export type work_ordersUpdateWithoutWork_order_tasksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutWork_order_tasksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersCreateWithoutWork_order_assetsInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutWork_order_assetsInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutWork_order_assetsInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutWork_order_assetsInput, work_ordersUncheckedCreateWithoutWork_order_assetsInput>
  }

  export type work_ordersUpsertWithoutWork_order_assetsInput = {
    update: XOR<work_ordersUpdateWithoutWork_order_assetsInput, work_ordersUncheckedUpdateWithoutWork_order_assetsInput>
    create: XOR<work_ordersCreateWithoutWork_order_assetsInput, work_ordersUncheckedCreateWithoutWork_order_assetsInput>
    where?: work_ordersWhereInput
  }

  export type work_ordersUpdateToOneWithWhereWithoutWork_order_assetsInput = {
    where?: work_ordersWhereInput
    data: XOR<work_ordersUpdateWithoutWork_order_assetsInput, work_ordersUncheckedUpdateWithoutWork_order_assetsInput>
  }

  export type work_ordersUpdateWithoutWork_order_assetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutWork_order_assetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersCreateWithoutWork_order_crewInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutWork_order_crewInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutWork_order_crewInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutWork_order_crewInput, work_ordersUncheckedCreateWithoutWork_order_crewInput>
  }

  export type crewsCreateWithoutWork_order_crewInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    created_at: string
    updated_at: string
    users: usersCreateNestedOneWithoutCrewsInput
    crew_members?: crew_membersCreateNestedManyWithoutCrewsInput
  }

  export type crewsUncheckedCreateWithoutWork_order_crewInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    leader_id: bigint | number
    created_at: string
    updated_at: string
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type crewsCreateOrConnectWithoutWork_order_crewInput = {
    where: crewsWhereUniqueInput
    create: XOR<crewsCreateWithoutWork_order_crewInput, crewsUncheckedCreateWithoutWork_order_crewInput>
  }

  export type work_ordersUpsertWithoutWork_order_crewInput = {
    update: XOR<work_ordersUpdateWithoutWork_order_crewInput, work_ordersUncheckedUpdateWithoutWork_order_crewInput>
    create: XOR<work_ordersCreateWithoutWork_order_crewInput, work_ordersUncheckedCreateWithoutWork_order_crewInput>
    where?: work_ordersWhereInput
  }

  export type work_ordersUpdateToOneWithWhereWithoutWork_order_crewInput = {
    where?: work_ordersWhereInput
    data: XOR<work_ordersUpdateWithoutWork_order_crewInput, work_ordersUncheckedUpdateWithoutWork_order_crewInput>
  }

  export type work_ordersUpdateWithoutWork_order_crewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutWork_order_crewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type crewsUpsertWithoutWork_order_crewInput = {
    update: XOR<crewsUpdateWithoutWork_order_crewInput, crewsUncheckedUpdateWithoutWork_order_crewInput>
    create: XOR<crewsCreateWithoutWork_order_crewInput, crewsUncheckedCreateWithoutWork_order_crewInput>
    where?: crewsWhereInput
  }

  export type crewsUpdateToOneWithWhereWithoutWork_order_crewInput = {
    where?: crewsWhereInput
    data: XOR<crewsUpdateWithoutWork_order_crewInput, crewsUncheckedUpdateWithoutWork_order_crewInput>
  }

  export type crewsUpdateWithoutWork_order_crewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutCrewsNestedInput
    crew_members?: crew_membersUpdateManyWithoutCrewsNestedInput
  }

  export type crewsUncheckedUpdateWithoutWork_order_crewInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    crew_members?: crew_membersUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type work_ordersCreateWithoutWork_order_approvalsInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutWork_order_approvalsInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutWork_order_approvalsInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutWork_order_approvalsInput, work_ordersUncheckedCreateWithoutWork_order_approvalsInput>
  }

  export type work_ordersUpsertWithoutWork_order_approvalsInput = {
    update: XOR<work_ordersUpdateWithoutWork_order_approvalsInput, work_ordersUncheckedUpdateWithoutWork_order_approvalsInput>
    create: XOR<work_ordersCreateWithoutWork_order_approvalsInput, work_ordersUncheckedCreateWithoutWork_order_approvalsInput>
    where?: work_ordersWhereInput
  }

  export type work_ordersUpdateToOneWithWhereWithoutWork_order_approvalsInput = {
    where?: work_ordersWhereInput
    data: XOR<work_ordersUpdateWithoutWork_order_approvalsInput, work_ordersUncheckedUpdateWithoutWork_order_approvalsInput>
  }

  export type work_ordersUpdateWithoutWork_order_approvalsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutWork_order_approvalsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersCreateWithoutInvoicesInput = {
    id?: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutWork_ordersInput
    customers: customersCreateNestedOneWithoutWork_ordersInput
    companies: companiesCreateNestedOneWithoutWork_ordersInput
    assets: assetsCreateNestedOneWithoutWork_ordersInput
    maintenance_plans: maintenance_plansCreateNestedOneWithoutWork_ordersInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersUncheckedCreateWithoutInvoicesInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_tasks?: work_order_tasksUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_assets?: work_order_assetsUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_crew?: work_order_crewUncheckedCreateNestedManyWithoutWork_ordersInput
    work_order_approvals?: work_order_approvalsUncheckedCreateNestedManyWithoutWork_ordersInput
  }

  export type work_ordersCreateOrConnectWithoutInvoicesInput = {
    where: work_ordersWhereUniqueInput
    create: XOR<work_ordersCreateWithoutInvoicesInput, work_ordersUncheckedCreateWithoutInvoicesInput>
  }

  export type invoice_itemsCreateWithoutInvoicesInput = {
    id?: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
    services: servicesCreateNestedOneWithoutInvoice_itemsInput
    parts: partsCreateNestedOneWithoutInvoice_itemsInput
  }

  export type invoice_itemsUncheckedCreateWithoutInvoicesInput = {
    id?: bigint | number
    service_id: bigint | number
    part_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsCreateOrConnectWithoutInvoicesInput = {
    where: invoice_itemsWhereUniqueInput
    create: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput>
  }

  export type invoice_itemsCreateManyInvoicesInputEnvelope = {
    data: invoice_itemsCreateManyInvoicesInput | invoice_itemsCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutInvoicesInput = {
    id?: bigint | number
    payment_date: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_method: $Enums.PaymentMethod
    payment_status: $Enums.PaymentStatus
    transaction_id: string
    created_at: string
    updated_at: string
  }

  export type paymentsUncheckedCreateWithoutInvoicesInput = {
    id?: bigint | number
    payment_date: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_method: $Enums.PaymentMethod
    payment_status: $Enums.PaymentStatus
    transaction_id: string
    created_at: string
    updated_at: string
  }

  export type paymentsCreateOrConnectWithoutInvoicesInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput>
  }

  export type paymentsCreateManyInvoicesInputEnvelope = {
    data: paymentsCreateManyInvoicesInput | paymentsCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type work_ordersUpsertWithoutInvoicesInput = {
    update: XOR<work_ordersUpdateWithoutInvoicesInput, work_ordersUncheckedUpdateWithoutInvoicesInput>
    create: XOR<work_ordersCreateWithoutInvoicesInput, work_ordersUncheckedCreateWithoutInvoicesInput>
    where?: work_ordersWhereInput
  }

  export type work_ordersUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: work_ordersWhereInput
    data: XOR<work_ordersUpdateWithoutInvoicesInput, work_ordersUncheckedUpdateWithoutInvoicesInput>
  }

  export type work_ordersUpdateWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type invoice_itemsUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: invoice_itemsWhereUniqueInput
    update: XOR<invoice_itemsUpdateWithoutInvoicesInput, invoice_itemsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<invoice_itemsCreateWithoutInvoicesInput, invoice_itemsUncheckedCreateWithoutInvoicesInput>
  }

  export type invoice_itemsUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: invoice_itemsWhereUniqueInput
    data: XOR<invoice_itemsUpdateWithoutInvoicesInput, invoice_itemsUncheckedUpdateWithoutInvoicesInput>
  }

  export type invoice_itemsUpdateManyWithWhereWithoutInvoicesInput = {
    where: invoice_itemsScalarWhereInput
    data: XOR<invoice_itemsUpdateManyMutationInput, invoice_itemsUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutInvoicesInput, paymentsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<paymentsCreateWithoutInvoicesInput, paymentsUncheckedCreateWithoutInvoicesInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutInvoicesInput, paymentsUncheckedUpdateWithoutInvoicesInput>
  }

  export type paymentsUpdateManyWithWhereWithoutInvoicesInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: BigIntFilter<"payments"> | bigint | number
    invoice_id?: BigIntFilter<"payments"> | bigint | number
    payment_date?: StringFilter<"payments"> | string
    payment_amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    transaction_id?: StringFilter<"payments"> | string
    created_at?: StringFilter<"payments"> | string
    updated_at?: StringFilter<"payments"> | string
  }

  export type invoicesCreateWithoutInvoice_itemsInput = {
    id?: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutInvoice_itemsInput = {
    id?: bigint | number
    work_order_id: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutInvoice_itemsInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
  }

  export type servicesCreateWithoutInvoice_itemsInput = {
    id?: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutServicesInput
    work_order_services?: work_order_servicesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateWithoutInvoice_itemsInput = {
    id?: bigint | number
    organization_id: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
    work_order_services?: work_order_servicesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesCreateOrConnectWithoutInvoice_itemsInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutInvoice_itemsInput, servicesUncheckedCreateWithoutInvoice_itemsInput>
  }

  export type partsCreateWithoutInvoice_itemsInput = {
    id?: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
    organizations: organizationsCreateNestedOneWithoutPartsInput
  }

  export type partsUncheckedCreateWithoutInvoice_itemsInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
  }

  export type partsCreateOrConnectWithoutInvoice_itemsInput = {
    where: partsWhereUniqueInput
    create: XOR<partsCreateWithoutInvoice_itemsInput, partsUncheckedCreateWithoutInvoice_itemsInput>
  }

  export type invoicesUpsertWithoutInvoice_itemsInput = {
    update: XOR<invoicesUpdateWithoutInvoice_itemsInput, invoicesUncheckedUpdateWithoutInvoice_itemsInput>
    create: XOR<invoicesCreateWithoutInvoice_itemsInput, invoicesUncheckedCreateWithoutInvoice_itemsInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutInvoice_itemsInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutInvoice_itemsInput, invoicesUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type invoicesUpdateWithoutInvoice_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutInvoice_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type servicesUpsertWithoutInvoice_itemsInput = {
    update: XOR<servicesUpdateWithoutInvoice_itemsInput, servicesUncheckedUpdateWithoutInvoice_itemsInput>
    create: XOR<servicesCreateWithoutInvoice_itemsInput, servicesUncheckedCreateWithoutInvoice_itemsInput>
    where?: servicesWhereInput
  }

  export type servicesUpdateToOneWithWhereWithoutInvoice_itemsInput = {
    where?: servicesWhereInput
    data: XOR<servicesUpdateWithoutInvoice_itemsInput, servicesUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type servicesUpdateWithoutInvoice_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutServicesNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutInvoice_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type partsUpsertWithoutInvoice_itemsInput = {
    update: XOR<partsUpdateWithoutInvoice_itemsInput, partsUncheckedUpdateWithoutInvoice_itemsInput>
    create: XOR<partsCreateWithoutInvoice_itemsInput, partsUncheckedCreateWithoutInvoice_itemsInput>
    where?: partsWhereInput
  }

  export type partsUpdateToOneWithWhereWithoutInvoice_itemsInput = {
    where?: partsWhereInput
    data: XOR<partsUpdateWithoutInvoice_itemsInput, partsUncheckedUpdateWithoutInvoice_itemsInput>
  }

  export type partsUpdateWithoutInvoice_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutPartsNestedInput
  }

  export type partsUncheckedUpdateWithoutInvoice_itemsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesCreateWithoutPaymentsInput = {
    id?: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    work_orders: work_ordersCreateNestedOneWithoutInvoicesInput
    invoice_items?: invoice_itemsCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    work_order_id: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
    invoice_items?: invoice_itemsUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutPaymentsInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
  }

  export type invoicesUpsertWithoutPaymentsInput = {
    update: XOR<invoicesUpdateWithoutPaymentsInput, invoicesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutPaymentsInput, invoicesUncheckedUpdateWithoutPaymentsInput>
  }

  export type invoicesUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutInvoicesNestedInput
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type usersCreateWithoutNotificationsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    organizations: organizationsCreateNestedOneWithoutUsersInput
    user_skills?: user_skillsCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsCreateNestedManyWithoutUsersInput
    crews?: crewsCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsUncheckedCreateNestedManyWithoutUsersInput
    crews?: crewsUncheckedCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutUsersInput
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    user_skills?: user_skillsUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUpdateManyWithoutUsersNestedInput
    crews?: crewsUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput
    crews?: crewsUncheckedUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutAudit_logsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    organizations: organizationsCreateNestedOneWithoutUsersInput
    user_skills?: user_skillsCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsCreateNestedManyWithoutUsersInput
    crews?: crewsCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAudit_logsInput = {
    id?: bigint | number
    organization_id: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
    user_skills?: user_skillsUncheckedCreateNestedManyWithoutUsersInput
    time_off_requests?: time_off_requestsUncheckedCreateNestedManyWithoutUsersInput
    crews?: crewsUncheckedCreateNestedManyWithoutUsersInput
    crew_members?: crew_membersUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAudit_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
  }

  export type usersUpsertWithoutAudit_logsInput = {
    update: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAudit_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type usersUpdateWithoutAudit_logsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    user_skills?: user_skillsUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUpdateManyWithoutUsersNestedInput
    crews?: crewsUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAudit_logsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput
    crews?: crewsUncheckedUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyOrganizationsInput = {
    id?: bigint | number
    email?: string
    password_hash?: string
    isVerified_Email?: boolean
    isVerified_PhoneNumber?: boolean
    first_name?: string
    last_name?: string
    phone?: string
    job_title?: string
    user_type?: $Enums.UserRole
    is_active?: number
    last_login_at?: string
    email_verified?: boolean
    created_at?: string
    updated_at?: string
  }

  export type user_skillsCreateManyOrganizationsInput = {
    id?: bigint | number
    user_id: bigint | number
    skill_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type business_hoursCreateManyOrganizationsInput = {
    id?: bigint | number
    day_of_week?: $Enums.DayOfWeek
    start_time: string
    end_time: string
    created_at: string
    updated_at: string
  }

  export type holidaysCreateManyOrganizationsInput = {
    id?: bigint | number
    name: string
    holiday_date: string
    is_recurring?: number
    created_at: string
    updated_at: string
  }

  export type crew_membersCreateManyOrganizationsInput = {
    id?: bigint | number
    crew_id: bigint | number
    user_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type equipmentsCreateManyOrganizationsInput = {
    id?: bigint | number
    name: string
    equipment_type: string
    status: $Enums.EqupmentStatus
    location: string
    availability_date: string
    created_at: string
    updated_at: string
  }

  export type companiesCreateManyOrganizationsInput = {
    id?: bigint | number
    name: string
    industry: string
    tax_id: string
    address: string
    phone: string
    email: string
    website: string
    created_at: string
    updated_at: string
  }

  export type customersCreateManyOrganizationsInput = {
    id?: bigint | number
    company_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
  }

  export type servicesCreateManyOrganizationsInput = {
    id?: bigint | number
    description: string
    duration: number
    price: Decimal | DecimalJsLike | number | string
    required_skills: JsonNullValueInput | InputJsonValue
    created_at: string
    updated_at: string
  }

  export type assetsCreateManyOrganizationsInput = {
    id?: bigint | number
    customer_id: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
  }

  export type partsCreateManyOrganizationsInput = {
    id?: bigint | number
    name: string
    description: string
    price: Decimal | DecimalJsLike | number | string
    inventory_count: number
    reorder_level: number
    created_at: string
    updated_at: string
  }

  export type maintenance_plansCreateManyOrganizationsInput = {
    id?: bigint | number
    name: string
    description: string
    start_date: string
    end_date: string
    frequency: $Enums.Frequency
    frequency_unit: number
    frequency_unit_type: $Enums.FrequencyUnitType
    is_active: number
    created_at: string
    updated_at: string
  }

  export type work_ordersCreateManyOrganizationsInput = {
    id?: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
  }

  export type usersUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUpdateManyWithoutUsersNestedInput
    crews?: crewsUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    user_skills?: user_skillsUncheckedUpdateManyWithoutUsersNestedInput
    time_off_requests?: time_off_requestsUncheckedUpdateManyWithoutUsersNestedInput
    crews?: crewsUncheckedUpdateManyWithoutUsersNestedInput
    crew_members?: crew_membersUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    isVerified_Email?: BoolFieldUpdateOperationsInput | boolean
    isVerified_PhoneNumber?: BoolFieldUpdateOperationsInput | boolean
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    user_type?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    is_active?: IntFieldUpdateOperationsInput | number
    last_login_at?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_skillsUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_skillsNestedInput
    skills?: skillsUpdateOneRequiredWithoutUser_skillsNestedInput
  }

  export type user_skillsUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_skillsUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type business_hoursUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    day_of_week?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type business_hoursUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    day_of_week?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type business_hoursUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    day_of_week?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type holidaysUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    holiday_date?: StringFieldUpdateOperationsInput | string
    is_recurring?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type holidaysUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    holiday_date?: StringFieldUpdateOperationsInput | string
    is_recurring?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type holidaysUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    holiday_date?: StringFieldUpdateOperationsInput | string
    is_recurring?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    crews?: crewsUpdateOneRequiredWithoutCrew_membersNestedInput
    users?: usersUpdateOneRequiredWithoutCrew_membersNestedInput
  }

  export type crew_membersUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type equipmentsUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    status?: EnumEqupmentStatusFieldUpdateOperationsInput | $Enums.EqupmentStatus
    location?: StringFieldUpdateOperationsInput | string
    availability_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type equipmentsUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    status?: EnumEqupmentStatusFieldUpdateOperationsInput | $Enums.EqupmentStatus
    location?: StringFieldUpdateOperationsInput | string
    availability_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type equipmentsUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    equipment_type?: StringFieldUpdateOperationsInput | string
    status?: EnumEqupmentStatusFieldUpdateOperationsInput | $Enums.EqupmentStatus
    location?: StringFieldUpdateOperationsInput | string
    availability_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type companiesUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    customers?: customersUpdateManyWithoutCompaniesNestedInput
    work_orders?: work_ordersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    customers?: customersUncheckedUpdateManyWithoutCompaniesNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    tax_id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type customersUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    companies?: companiesUpdateOneRequiredWithoutCustomersNestedInput
    assets?: assetsUpdateManyWithoutCustomersNestedInput
    work_orders?: work_ordersUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    assets?: assetsUncheckedUpdateManyWithoutCustomersNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type servicesUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUpdateManyWithoutServicesNestedInput
    invoice_items?: invoice_itemsUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutServicesNestedInput
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    required_skills?: JsonNullValueInput | InputJsonValue
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type assetsUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    customers?: customersUpdateOneRequiredWithoutAssetsNestedInput
    work_orders?: work_ordersUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type partsUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUpdateManyWithoutPartsNestedInput
  }

  export type partsUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutPartsNestedInput
  }

  export type partsUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_count?: IntFieldUpdateOperationsInput | number
    reorder_level?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plansUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    maintenance_plan_assets?: maintenance_plan_assetsUpdateManyWithoutMaintenance_plansNestedInput
    work_orders?: work_ordersUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type maintenance_plansUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    maintenance_plan_assets?: maintenance_plan_assetsUncheckedUpdateManyWithoutMaintenance_plansNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutMaintenance_plansNestedInput
  }

  export type maintenance_plansUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    frequency_unit?: IntFieldUpdateOperationsInput | number
    frequency_unit_type?: EnumFrequencyUnitTypeFieldUpdateOperationsInput | $Enums.FrequencyUnitType
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_ordersUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_skillsCreateManyUsersInput = {
    id?: bigint | number
    skill_id: bigint | number
    organization_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type time_off_requestsCreateManyUsersInput = {
    id?: bigint | number
    start_date: string
    end_date: string
    reason: string
    status?: $Enums.RequestStatus
    created_at: string
    updated_at: string
  }

  export type crewsCreateManyUsersInput = {
    id?: bigint | number
    organization_id: bigint | number
    name: string
    created_at: string
    updated_at: string
  }

  export type crew_membersCreateManyUsersInput = {
    id?: bigint | number
    organization_id: bigint | number
    crew_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type notificationsCreateManyUsersInput = {
    id?: bigint | number
    notification_type: $Enums.NotificationType
    message: string
    status: $Enums.NotificationStatus
    created_at: string
    updated_at: string
  }

  export type audit_logsCreateManyUsersInput = {
    id?: bigint | number
    action: string
    entity_type: $Enums.LogType
    entity_id: bigint | number
    changes: string
    created_at: string
    updated_at: string
  }

  export type user_skillsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: skillsUpdateOneRequiredWithoutUser_skillsNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUser_skillsNestedInput
  }

  export type user_skillsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_skillsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type time_off_requestsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type time_off_requestsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type time_off_requestsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: StringFieldUpdateOperationsInput | string
    end_date?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crewsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    crew_members?: crew_membersUpdateManyWithoutCrewsNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutCrewsNestedInput
  }

  export type crewsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    crew_members?: crew_membersUncheckedUpdateManyWithoutCrewsNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type crewsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCrew_membersNestedInput
    crews?: crewsUpdateOneRequiredWithoutCrew_membersNestedInput
  }

  export type crew_membersUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification_type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification_type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    notification_type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type audit_logsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    entity_type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    entity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type audit_logsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    entity_type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    entity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: StringFieldUpdateOperationsInput | string
    entity_type?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    entity_id?: BigIntFieldUpdateOperationsInput | bigint | number
    changes?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type user_skillsCreateManySkillsInput = {
    id?: bigint | number
    user_id: bigint | number
    organization_id: bigint | number
    proficiency_level?: $Enums.ProficiencyLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_skillsUpdateWithoutSkillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_skillsNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUser_skillsNestedInput
  }

  export type user_skillsUncheckedUpdateWithoutSkillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_skillsUncheckedUpdateManyWithoutSkillsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    proficiency_level?: EnumProficiencyLevelFieldUpdateOperationsInput | $Enums.ProficiencyLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type crew_membersCreateManyCrewsInput = {
    id?: bigint | number
    organization_id: bigint | number
    user_id: bigint | number
    role: string
    created_at: string
    updated_at: string
  }

  export type work_order_crewCreateManyCrewsInput = {
    id?: bigint | number
    work_order_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type crew_membersUpdateWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCrew_membersNestedInput
    users?: usersUpdateOneRequiredWithoutCrew_membersNestedInput
  }

  export type crew_membersUncheckedUpdateWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type crew_membersUncheckedUpdateManyWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_crewUpdateWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutWork_order_crewNestedInput
  }

  export type work_order_crewUncheckedUpdateWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_crewUncheckedUpdateManyWithoutCrewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type customersCreateManyCompaniesInput = {
    id?: bigint | number
    organization_id: bigint | number
    first_name: string
    last_name: string
    email: string
    phone: string
    address: string
    is_active?: number
    created_at: string
    updated_at: string
  }

  export type work_ordersCreateManyCompaniesInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
  }

  export type customersUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutCustomersNestedInput
    assets?: assetsUpdateManyWithoutCustomersNestedInput
    work_orders?: work_ordersUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    assets?: assetsUncheckedUpdateManyWithoutCustomersNestedInput
    work_orders?: work_ordersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_ordersUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type assetsCreateManyCustomersInput = {
    id?: bigint | number
    organization_id: bigint | number
    asset_name: string
    serial_number: string
    model: string
    manufacturer: string
    status: $Enums.AssetStatus
    location: string
    notes: string
    purchase_date: string
    warranty_expiry: string
    created_at: string
    updated_at: string
  }

  export type work_ordersCreateManyCustomersInput = {
    id?: bigint | number
    organization_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
  }

  export type assetsUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutAssetsNestedInput
    work_orders?: work_ordersUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateManyWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_name?: StringFieldUpdateOperationsInput | string
    serial_number?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    purchase_date?: StringFieldUpdateOperationsInput | string
    warranty_expiry?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_ordersUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateManyWithoutCustomersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_servicesCreateManyServicesInput = {
    id?: bigint | number
    work_order_id: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsCreateManyServicesInput = {
    id?: bigint | number
    invoice_id: bigint | number
    part_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type work_order_servicesUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_orders?: work_ordersUpdateOneRequiredWithoutWork_order_servicesNestedInput
  }

  export type work_order_servicesUncheckedUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_servicesUncheckedUpdateManyWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    work_order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    parts?: partsUpdateOneRequiredWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    part_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsUncheckedUpdateManyWithoutServicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    part_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_ordersCreateManyAssetsInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    maintenance_plan_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
  }

  export type work_ordersUpdateWithoutAssetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    maintenance_plans?: maintenance_plansUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutAssetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateManyWithoutAssetsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    maintenance_plan_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsCreateManyPartsInput = {
    id?: bigint | number
    invoice_id: bigint | number
    service_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsUpdateWithoutPartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoices?: invoicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    services?: servicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateWithoutPartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsUncheckedUpdateManyWithoutPartsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plan_assetsCreateManyMaintenance_plansInput = {
    id?: bigint | number
    asset_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type work_ordersCreateManyMaintenance_plansInput = {
    id?: bigint | number
    organization_id: bigint | number
    customer_id: bigint | number
    company_id: bigint | number
    asset_id: bigint | number
    title: string
    description: string
    priority: $Enums.Prioirty
    status?: $Enums.WorkOrderStatus
    assigned_to: string
    assigned_crew_id: number
    scheduled_start_date: string
    scheduled_end_date: string
    actual_start_date: string
    actual_end_date: string
    currency_id: number
    estimated_cost: Decimal | DecimalJsLike | number | string
    actual_cost: Decimal | DecimalJsLike | number | string
    address: string
    city: string
    state: string
    postal_code: string
    country: string
    is_multi_day: number
    created_at: string
    updated_at: string
  }

  export type maintenance_plan_assetsUpdateWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plan_assetsUncheckedUpdateWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type maintenance_plan_assetsUncheckedUpdateManyWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_ordersUpdateWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    organizations?: organizationsUpdateOneRequiredWithoutWork_ordersNestedInput
    customers?: customersUpdateOneRequiredWithoutWork_ordersNestedInput
    companies?: companiesUpdateOneRequiredWithoutWork_ordersNestedInput
    assets?: assetsUpdateOneRequiredWithoutWork_ordersNestedInput
    work_order_services?: work_order_servicesUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    work_order_services?: work_order_servicesUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_tasks?: work_order_tasksUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_assets?: work_order_assetsUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_crew?: work_order_crewUncheckedUpdateManyWithoutWork_ordersNestedInput
    work_order_approvals?: work_order_approvalsUncheckedUpdateManyWithoutWork_ordersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutWork_ordersNestedInput
  }

  export type work_ordersUncheckedUpdateManyWithoutMaintenance_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    organization_id?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumPrioirtyFieldUpdateOperationsInput | $Enums.Prioirty
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    assigned_to?: StringFieldUpdateOperationsInput | string
    assigned_crew_id?: IntFieldUpdateOperationsInput | number
    scheduled_start_date?: StringFieldUpdateOperationsInput | string
    scheduled_end_date?: StringFieldUpdateOperationsInput | string
    actual_start_date?: StringFieldUpdateOperationsInput | string
    actual_end_date?: StringFieldUpdateOperationsInput | string
    currency_id?: IntFieldUpdateOperationsInput | number
    estimated_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actual_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    is_multi_day?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_servicesCreateManyWork_ordersInput = {
    id?: bigint | number
    service_id: bigint | number
    quantity: number
    service_cost: Decimal | DecimalJsLike | number | string
    created_at: string
    updated_at: string
  }

  export type work_order_tasksCreateManyWork_ordersInput = {
    id?: bigint | number
    task_name: string
    task_description: string
    assigned_to: bigint | number
    status?: $Enums.WorkOrderTaskStatus
    due_date: string
    created_at: string
    updated_at: string
  }

  export type work_order_assetsCreateManyWork_ordersInput = {
    id?: bigint | number
    asset_id: bigint | number
    quantity: number
    created_at: string
    updated_at: string
  }

  export type work_order_crewCreateManyWork_ordersInput = {
    id?: bigint | number
    crew_id: bigint | number
    assigned_at: string
    created_at: string
    updated_at: string
  }

  export type work_order_approvalsCreateManyWork_ordersInput = {
    id?: bigint | number
    approved_by: bigint | number
    approval_status: $Enums.ApprovalStatus
    approved_at: string
    created_at: string
    updated_at: string
  }

  export type invoicesCreateManyWork_ordersInput = {
    id?: bigint | number
    invoice_number: string
    invoice_date: string
    due_date: string
    total_amount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    currency_id: number
    created_at: string
    updated_at: string
  }

  export type work_order_servicesUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    services?: servicesUpdateOneRequiredWithoutWork_order_servicesNestedInput
  }

  export type work_order_servicesUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_servicesUncheckedUpdateManyWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    service_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_tasksUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_name?: StringFieldUpdateOperationsInput | string
    task_description?: StringFieldUpdateOperationsInput | string
    assigned_to?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWorkOrderTaskStatusFieldUpdateOperationsInput | $Enums.WorkOrderTaskStatus
    due_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_tasksUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_name?: StringFieldUpdateOperationsInput | string
    task_description?: StringFieldUpdateOperationsInput | string
    assigned_to?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWorkOrderTaskStatusFieldUpdateOperationsInput | $Enums.WorkOrderTaskStatus
    due_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_tasksUncheckedUpdateManyWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    task_name?: StringFieldUpdateOperationsInput | string
    task_description?: StringFieldUpdateOperationsInput | string
    assigned_to?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumWorkOrderTaskStatusFieldUpdateOperationsInput | $Enums.WorkOrderTaskStatus
    due_date?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_assetsUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_assetsUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_assetsUncheckedUpdateManyWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    asset_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_crewUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    crews?: crewsUpdateOneRequiredWithoutWork_order_crewNestedInput
  }

  export type work_order_crewUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_crewUncheckedUpdateManyWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    crew_id?: BigIntFieldUpdateOperationsInput | bigint | number
    assigned_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_approvalsUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    approved_by?: BigIntFieldUpdateOperationsInput | bigint | number
    approval_status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approved_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_approvalsUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    approved_by?: BigIntFieldUpdateOperationsInput | bigint | number
    approval_status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approved_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type work_order_approvalsUncheckedUpdateManyWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    approved_by?: BigIntFieldUpdateOperationsInput | bigint | number
    approval_status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    approved_at?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    invoice_items?: invoice_itemsUncheckedUpdateManyWithoutInvoicesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateManyWithoutWork_ordersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_date?: StringFieldUpdateOperationsInput | string
    due_date?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    currency_id?: IntFieldUpdateOperationsInput | number
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsCreateManyInvoicesInput = {
    id?: bigint | number
    service_id: bigint | number
    part_id: bigint | number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    total_price: Decimal | DecimalJsLike | number | string
    description: string
    created_at: string
    updated_at: string
  }

  export type paymentsCreateManyInvoicesInput = {
    id?: bigint | number
    payment_date: string
    payment_amount: Decimal | DecimalJsLike | number | string
    payment_method: $Enums.PaymentMethod
    payment_status: $Enums.PaymentStatus
    transaction_id: string
    created_at: string
    updated_at: string
  }

  export type invoice_itemsUpdateWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
    services?: servicesUpdateOneRequiredWithoutInvoice_itemsNestedInput
    parts?: partsUpdateOneRequiredWithoutInvoice_itemsNestedInput
  }

  export type invoice_itemsUncheckedUpdateWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    part_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type invoice_itemsUncheckedUpdateManyWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    service_id?: BigIntFieldUpdateOperationsInput | bigint | number
    part_id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsUpdateWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_date?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsUncheckedUpdateWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_date?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsUncheckedUpdateManyWithoutInvoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_date?: StringFieldUpdateOperationsInput | string
    payment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    payment_status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: StringFieldUpdateOperationsInput | string
    updated_at?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}